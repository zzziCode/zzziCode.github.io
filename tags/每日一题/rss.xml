<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>每日一题 on zzzi的小站</title><link>https://zzzicode.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link><description>Recent content in 每日一题 on zzzi的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 17 Apr 2024 16:04:38 +0800</lastBuildDate><atom:link href="https://zzzicode.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/rss.xml" rel="self" type="application/rss+xml"/><item><title>873.最长的斐波那契子序列的长度</title><link>https://zzzicode.github.io/post/873.%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</link><pubDate>Wed, 17 Apr 2024 16:04:38 +0800</pubDate><guid>https://zzzicode.github.io/post/873.%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</guid><description>&lt;blockquote>
&lt;p>🍉 873.最长的斐波那契子序列的长度&lt;/p>
&lt;/blockquote>
&lt;p>如果序列 &lt;code>X_1, X_2, ..., X_n&lt;/code> 满足下列条件，就说它是 &lt;em>斐波那契式&lt;/em> 的：&lt;/p>
&lt;ul>
&lt;li>&lt;code>n &amp;gt;= 3&lt;/code>&lt;/li>
&lt;li>对于所有 &lt;code>i + 2 &amp;lt;= n&lt;/code>，都有 &lt;code>X_i + X_{i+1} = X_{i+2}&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>给定一个&lt;strong>严格递增&lt;/strong>的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。&lt;/p>
&lt;p>&lt;em>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， &lt;code>[3, 5, 8]&lt;/code> 是 &lt;code>[3, 4, 5, 6, 7, 8]&lt;/code> 的一个子序列）&lt;/em>&lt;/p></description></item><item><title>372.超级次方</title><link>https://zzzicode.github.io/post/372.%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</link><pubDate>Thu, 11 Apr 2024 20:03:27 +0800</pubDate><guid>https://zzzicode.github.io/post/372.%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</guid><description>&lt;blockquote>
&lt;p>🍈 372.超级次方&lt;/p>
&lt;/blockquote>
&lt;p>你的任务是计算 &lt;code>a^b&lt;/code> 对 &lt;code>1337&lt;/code> 取模，&lt;code>a&lt;/code> 是一个正整数，&lt;code>b&lt;/code> 是一个非常大的正整数且会以数组形式给出。&lt;/p></description></item><item><title>2385.感染二叉树需要的总时间</title><link>https://zzzicode.github.io/post/2385.%E6%84%9F%E6%9F%93%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9C%80%E8%A6%81%E7%9A%84%E6%80%BB%E6%97%B6%E9%97%B4/</link><pubDate>Mon, 01 Apr 2024 20:33:08 +0800</pubDate><guid>https://zzzicode.github.io/post/2385.%E6%84%9F%E6%9F%93%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9C%80%E8%A6%81%E7%9A%84%E6%80%BB%E6%97%B6%E9%97%B4/</guid><description>&lt;blockquote>
&lt;p>☣ 2385.感染二叉树需要的总时间&lt;/p>
&lt;/blockquote>
&lt;p>给你一棵二叉树的根节点 &lt;code>root&lt;/code> ，二叉树中节点的值 &lt;strong>互不相同&lt;/strong> 。另给你一个整数 &lt;code>start&lt;/code> 。在第 &lt;code>0&lt;/code> 分钟，&lt;strong>感染&lt;/strong> 将会从值为 &lt;code>start&lt;/code> 的节点开始爆发。&lt;/p>
&lt;p>每分钟，如果节点满足以下全部条件，就会被感染：&lt;/p>
&lt;ul>
&lt;li>节点此前还没有感染。&lt;/li>
&lt;li>节点与一个已感染节点相邻。&lt;/li>
&lt;/ul>
&lt;p>返回感染整棵树需要的分钟数*。*&lt;/p></description></item><item><title>1509.三次操作后的最大值与最小值</title><link>https://zzzicode.github.io/post/1509.%E4%B8%89%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%80%BC/</link><pubDate>Fri, 22 Mar 2024 19:59:41 +0800</pubDate><guid>https://zzzicode.github.io/post/1509.%E4%B8%89%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%80%BC/</guid><description>&lt;blockquote>
&lt;p>🧀 1509.三次操作后的最大值与最小值&lt;/p>
&lt;/blockquote>
&lt;p>给你一个数组 &lt;code>nums&lt;/code> 。&lt;/p>
&lt;p>每次操作你可以选择 &lt;code>nums&lt;/code> 中的任意一个元素并将它改成 &lt;strong>任意值&lt;/strong> 。&lt;/p>
&lt;p>在 &lt;strong>执行最多三次移动后&lt;/strong> ，返回 &lt;code>nums&lt;/code> 中最大值与最小值的最小差值。&lt;/p></description></item><item><title>生成特殊数字的最少操作</title><link>https://zzzicode.github.io/post/%E7%94%9F%E6%88%90%E7%89%B9%E6%AE%8A%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 16 Mar 2024 12:40:16 +0800</pubDate><guid>https://zzzicode.github.io/post/%E7%94%9F%E6%88%90%E7%89%B9%E6%AE%8A%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C/</guid><description>&lt;blockquote>
&lt;p>😃 2844.生成特殊数字的最少操作&lt;/p>
&lt;/blockquote>
&lt;p>给你一个下标从 &lt;strong>0&lt;/strong> 开始的字符串 &lt;code>num&lt;/code> ，表示一个非负整数。&lt;/p>
&lt;p>在一次操作中，您可以选择 &lt;code>num&lt;/code> 的任意一位数字并将其删除。请注意，如果你删除 &lt;code>num&lt;/code> 中的所有数字，则 &lt;code>num&lt;/code> 变为 &lt;code>0&lt;/code>。&lt;/p>
&lt;p>返回最少需要多少次操作可以使 &lt;code>num&lt;/code> 变成特殊数字。&lt;/p>
&lt;p>如果整数 &lt;code>x&lt;/code> 能被 &lt;code>25&lt;/code> 整除，则该整数 &lt;code>x&lt;/code> 被认为是特殊数字。&lt;/p></description></item><item><title>2537.统计好子数组的数目</title><link>https://zzzicode.github.io/post/2537.%E7%BB%9F%E8%AE%A1%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</link><pubDate>Tue, 05 Mar 2024 20:16:21 +0800</pubDate><guid>https://zzzicode.github.io/post/2537.%E7%BB%9F%E8%AE%A1%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</guid><description>&lt;blockquote>
&lt;p>💫 2537.统计好子数组的数目&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，请你返回 &lt;code>nums&lt;/code> 中 &lt;strong>好&lt;/strong> 子数组的数目。&lt;/p>
&lt;p>一个子数组 &lt;code>arr&lt;/code> 如果有 &lt;strong>至少&lt;/strong> &lt;code>k&lt;/code> 对下标 &lt;code>(i, j)&lt;/code> 满足 &lt;code>i &amp;lt; j&lt;/code> 且 &lt;code>arr[i] == arr[j]&lt;/code> ，那么称它是一个 &lt;strong>好&lt;/strong> 子数组。&lt;/p>
&lt;p>&lt;strong>子数组&lt;/strong> 是原数组中一段连续 &lt;strong>非空&lt;/strong> 的元素序列。&lt;/p></description></item><item><title>2063.所有子字符串中的元音</title><link>https://zzzicode.github.io/post/2063.%E6%89%80%E6%9C%89%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3/</link><pubDate>Tue, 05 Mar 2024 19:20:25 +0800</pubDate><guid>https://zzzicode.github.io/post/2063.%E6%89%80%E6%9C%89%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3/</guid><description>&lt;blockquote>
&lt;p>🏁 2063.所有子字符串中的元音&lt;/p>
&lt;/blockquote>
&lt;p>给你一个字符串 &lt;code>word&lt;/code> ，返回 &lt;code>word&lt;/code> 的所有子字符串中 &lt;strong>元音的总数&lt;/strong> ，元音是指 &lt;code>'a'&lt;/code>、&lt;code>'e'&lt;/code>&lt;em>、&lt;/em>&lt;code>'i'&lt;/code>&lt;em>、&lt;/em>&lt;code>'o'&lt;/code> 和 &lt;code>'u'&lt;/code> &lt;em>。&lt;/em>&lt;/p>
&lt;p>&lt;strong>子字符串&lt;/strong> 是字符串中一个连续（非空）的字符序列。&lt;/p>
&lt;p>**注意：**由于对 &lt;code>word&lt;/code> 长度的限制比较宽松，答案可能超过有符号 32 位整数的范围。计算时需当心。&lt;/p></description></item><item><title>2976.转换字符串的最小成本I</title><link>https://zzzicode.github.io/post/2976.%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%ACi/</link><pubDate>Mon, 04 Mar 2024 20:06:14 +0800</pubDate><guid>https://zzzicode.github.io/post/2976.%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%ACi/</guid><description>&lt;blockquote>
&lt;p>🎠 2976.转换字符串的最小成本I&lt;/p>
&lt;/blockquote>
&lt;p>给你两个下标从 &lt;strong>0&lt;/strong> 开始的字符串 &lt;code>source&lt;/code> 和 &lt;code>target&lt;/code> ，它们的长度均为 &lt;code>n&lt;/code> 并且由 &lt;strong>小写&lt;/strong> 英文字母组成。&lt;/p>
&lt;p>另给你两个下标从 &lt;strong>0&lt;/strong> 开始的字符数组 &lt;code>original&lt;/code> 和 &lt;code>changed&lt;/code> ，以及一个整数数组 &lt;code>cost&lt;/code> ，其中 &lt;code>cost[i]&lt;/code> 代表将字符 &lt;code>original[i]&lt;/code> 更改为字符 &lt;code>changed[i]&lt;/code> 的成本。&lt;/p>
&lt;p>你从字符串 &lt;code>source&lt;/code> 开始。在一次操作中，&lt;strong>如果&lt;/strong> 存在 &lt;strong>任意&lt;/strong> 下标 &lt;code>j&lt;/code> 满足 &lt;code>cost[j] == z&lt;/code> 、&lt;code>original[j] == x&lt;/code> 以及 &lt;code>changed[j] == y&lt;/code> 。你就可以选择字符串中的一个字符 &lt;code>x&lt;/code> 并以 &lt;code>z&lt;/code> 的成本将其更改为字符 &lt;code>y&lt;/code> 。&lt;/p>
&lt;p>返回将字符串 &lt;code>source&lt;/code> 转换为字符串 &lt;code>target&lt;/code> 所需的 &lt;strong>最小&lt;/strong> 成本。如果不可能完成转换，则返回 &lt;code>-1&lt;/code>&lt;/p></description></item><item><title>875.爱吃香蕉的珂珂</title><link>https://zzzicode.github.io/post/875.%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</link><pubDate>Fri, 01 Mar 2024 19:36:57 +0800</pubDate><guid>https://zzzicode.github.io/post/875.%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</guid><description>&lt;blockquote>
&lt;p>🍌 875.爱吃香蕉的珂珂&lt;/p>
&lt;/blockquote>
&lt;p>珂珂喜欢吃香蕉。这里有 &lt;code>n&lt;/code> 堆香蕉，第 &lt;code>i&lt;/code> 堆中有 &lt;code>piles[i]&lt;/code> 根香蕉。警卫已经离开了，将在 &lt;code>h&lt;/code> 小时后回来。&lt;/p>
&lt;p>珂珂可以决定她吃香蕉的速度 &lt;code>k&lt;/code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 &lt;code>k&lt;/code> 根。如果这堆香蕉少于 &lt;code>k&lt;/code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&lt;/p>
&lt;p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。&lt;/p>
&lt;p>返回她可以在 &lt;code>h&lt;/code> 小时内吃掉所有香蕉的最小速度 &lt;code>k&lt;/code>（&lt;code>k&lt;/code> 为整数）。&lt;/p></description></item><item><title>1887.使数组元素相等的减少操作次数</title><link>https://zzzicode.github.io/post/1887.%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E5%87%8F%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 15 Jan 2024 20:47:56 +0800</pubDate><guid>https://zzzicode.github.io/post/1887.%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E5%87%8F%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</guid><description>&lt;blockquote>
&lt;p>😃 1887.使数组元素相等的减少操作次数&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，你的目标是令 &lt;code>nums&lt;/code> 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：&lt;/p>
&lt;ol>
&lt;li>找出 &lt;code>nums&lt;/code> 中的 &lt;strong>最大&lt;/strong> 值。记这个值为 &lt;code>largest&lt;/code> 并取其下标 &lt;code>i&lt;/code> （&lt;strong>下标从 0 开始计数&lt;/strong>）。如果有多个元素都是最大值，则取最小的 &lt;code>i&lt;/code> 。&lt;/li>
&lt;li>找出 &lt;code>nums&lt;/code> 中的 &lt;strong>下一个最大&lt;/strong> 值，这个值 &lt;strong>严格小于&lt;/strong> &lt;code>largest&lt;/code> ，记为 &lt;code>nextLargest&lt;/code> 。&lt;/li>
&lt;li>将 &lt;code>nums[i]&lt;/code> 减少到 &lt;code>nextLargest&lt;/code> 。&lt;/li>
&lt;/ol>
&lt;p>返回使 &lt;code>nums&lt;/code> 中的所有元素相等的操作次数。&lt;/p></description></item><item><title>2750.将数组划分成若干好子数组的方式</title><link>https://zzzicode.github.io/post/2750.%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%E6%88%90%E8%8B%A5%E5%B9%B2%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 08 Jan 2024 19:57:40 +0800</pubDate><guid>https://zzzicode.github.io/post/2750.%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%E6%88%90%E8%8B%A5%E5%B9%B2%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F/</guid><description>&lt;blockquote>
&lt;p>🧑‍🧒 2750.将数组划分成若干好子数组的方式&lt;/p>
&lt;/blockquote>
&lt;p>给你一个二元数组 &lt;code>nums&lt;/code> 。&lt;/p>
&lt;p>如果数组中的某个子数组 &lt;strong>恰好&lt;/strong> 只存在 &lt;strong>一&lt;/strong> 个值为 &lt;code>1&lt;/code> 的元素，则认为该子数组是一个 &lt;strong>好子数组&lt;/strong> 。&lt;/p>
&lt;p>请你统计将数组 &lt;code>nums&lt;/code> 划分成若干 &lt;strong>好子数组&lt;/strong> 的方法数，并以整数形式返回。由于数字可能很大，返回其对 &lt;code>109 + 7&lt;/code> &lt;strong>取余&lt;/strong> 之后的结果。&lt;/p>
&lt;p>子数组是数组中的一个连续 &lt;strong>非空&lt;/strong> 元素序列。&lt;/p></description></item><item><title>1252.奇数值单元格的数目</title><link>https://zzzicode.github.io/post/1252.%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</link><pubDate>Sun, 07 Jan 2024 19:22:19 +0800</pubDate><guid>https://zzzicode.github.io/post/1252.%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</guid><description>&lt;blockquote>
&lt;p>😀 1252.奇数值单元格的数目&lt;/p>
&lt;/blockquote>
&lt;p>给你一个 &lt;code>m x n&lt;/code> 的矩阵，最开始的时候，每个单元格中的值都是 &lt;code>0&lt;/code>。&lt;/p>
&lt;p>另有一个二维索引数组 &lt;code>indices&lt;/code>，&lt;code>indices[i] = [ri, ci]&lt;/code> 指向矩阵中的某个位置，其中 &lt;code>ri&lt;/code> 和 &lt;code>ci&lt;/code> 分别表示指定的行和列（&lt;strong>从 &lt;code>0&lt;/code> 开始编号&lt;/strong>）。&lt;/p>
&lt;p>对 &lt;code>indices[i]&lt;/code> 所指向的每个位置，应同时执行下述增量操作：&lt;/p>
&lt;ol>
&lt;li>&lt;code>ri&lt;/code> 行上的所有单元格，加 &lt;code>1&lt;/code> 。&lt;/li>
&lt;li>&lt;code>ci&lt;/code> 列上的所有单元格，加 &lt;code>1&lt;/code> 。&lt;/li>
&lt;/ol>
&lt;p>给你 &lt;code>m&lt;/code>、&lt;code>n&lt;/code> 和 &lt;code>indices&lt;/code> 。请你在执行完所有 &lt;code>indices&lt;/code> 指定的增量操作后，返回矩阵中 &lt;strong>奇数值单元格&lt;/strong> 的数目。&lt;/p></description></item><item><title>780.到达终点</title><link>https://zzzicode.github.io/post/780.%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9/</link><pubDate>Mon, 01 Jan 2024 19:50:54 +0800</pubDate><guid>https://zzzicode.github.io/post/780.%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9/</guid><description>&lt;blockquote>
&lt;p>🏁 780.到达终点&lt;/p>
&lt;/blockquote>
&lt;p>给定四个整数 &lt;code>sx&lt;/code> , &lt;code>sy&lt;/code> ，&lt;code>tx&lt;/code> 和 &lt;code>ty&lt;/code>，如果通过一系列的&lt;strong>转换&lt;/strong>可以从起点 &lt;code>(sx, sy)&lt;/code> 到达终点 &lt;code>(tx, ty)&lt;/code>，则返回 &lt;code>true&lt;/code>，否则返回 &lt;code>false&lt;/code>。&lt;/p>
&lt;p>从点 &lt;code>(x, y)&lt;/code> 可以&lt;strong>转换&lt;/strong>到 &lt;code>(x, x+y)&lt;/code> 或者 &lt;code>(x+y, y)&lt;/code>。&lt;/p></description></item><item><title>526.优美的排列</title><link>https://zzzicode.github.io/post/526.%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</link><pubDate>Wed, 27 Dec 2023 21:08:32 +0800</pubDate><guid>https://zzzicode.github.io/post/526.%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</guid><description>&lt;blockquote>
&lt;p>🏐 526.优美的排列&lt;/p>
&lt;/blockquote>
&lt;p>假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 &lt;code>perm&lt;/code>（&lt;strong>下标从 1 开始&lt;/strong>），只要满足下述条件 &lt;strong>之一&lt;/strong> ，该数组就是一个 &lt;strong>优美的排列&lt;/strong> ：&lt;/p>
&lt;ul>
&lt;li>&lt;code>perm[i]&lt;/code> 能够被 &lt;code>i&lt;/code> 整除&lt;/li>
&lt;li>&lt;code>i&lt;/code> 能够被 &lt;code>perm[i]&lt;/code> 整除&lt;/li>
&lt;/ul>
&lt;p>给你一个整数 &lt;code>n&lt;/code> ，返回可以构造的 &lt;strong>优美排列&lt;/strong> 的 &lt;strong>数量&lt;/strong> 。&lt;/p></description></item><item><title>1771.由子序列构造的最长回文串的长度</title><link>https://zzzicode.github.io/post/1771.%E7%94%B1%E5%AD%90%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6/</link><pubDate>Tue, 26 Dec 2023 20:03:34 +0800</pubDate><guid>https://zzzicode.github.io/post/1771.%E7%94%B1%E5%AD%90%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6/</guid><description>&lt;blockquote>
&lt;p>📎 1771.由子序列构造的最长回文串的长度&lt;/p>
&lt;/blockquote>
&lt;p>给你两个字符串 &lt;code>word1&lt;/code> 和 &lt;code>word2&lt;/code> ，请你按下述方法构造一个字符串：&lt;/p>
&lt;ul>
&lt;li>从 &lt;code>word1&lt;/code> 中选出某个 &lt;strong>非空&lt;/strong> 子序列 &lt;code>subsequence1&lt;/code> 。&lt;/li>
&lt;li>从 &lt;code>word2&lt;/code> 中选出某个 &lt;strong>非空&lt;/strong> 子序列 &lt;code>subsequence2&lt;/code> 。&lt;/li>
&lt;li>连接两个子序列 &lt;code>subsequence1 + subsequence2&lt;/code> ，得到字符串。&lt;/li>
&lt;/ul>
&lt;p>返回可按上述方法构造的最长 &lt;strong>回文串&lt;/strong> 的 &lt;strong>长度&lt;/strong> 。如果无法构造回文串，返回 &lt;code>0&lt;/code> 。&lt;/p>
&lt;p>字符串 &lt;code>s&lt;/code> 的一个 &lt;strong>子序列&lt;/strong> 是通过从 &lt;code>s&lt;/code> 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。&lt;/p>
&lt;p>&lt;strong>回文串&lt;/strong> 是正着读和反着读结果一致的字符串。&lt;/p></description></item><item><title>1711.大餐计数</title><link>https://zzzicode.github.io/post/1711.%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</link><pubDate>Mon, 25 Dec 2023 20:44:47 +0800</pubDate><guid>https://zzzicode.github.io/post/1711.%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</guid><description>&lt;blockquote>
&lt;p>🍽 1711.大餐计数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>大餐&lt;/strong> 是指 &lt;strong>恰好包含两道不同餐品&lt;/strong> 的一餐，其美味程度之和等于 2 的幂。&lt;/p>
&lt;p>你可以搭配 &lt;strong>任意&lt;/strong> 两道餐品做一顿大餐。&lt;/p>
&lt;p>给你一个整数数组 &lt;code>deliciousness&lt;/code> ，其中 &lt;code>deliciousness[i]&lt;/code> 是第 &lt;code>i&lt;/code> 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 &lt;strong>大餐&lt;/strong> 的数量。结果需要对 &lt;code>10000000007&lt;/code> 取余。&lt;/p>
&lt;p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。&lt;/p></description></item><item><title>802.找到最终的安全状态</title><link>https://zzzicode.github.io/post/802.%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</link><pubDate>Fri, 22 Dec 2023 13:53:27 +0800</pubDate><guid>https://zzzicode.github.io/post/802.%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</guid><description>&lt;blockquote>
&lt;p>🦺 802.找到最终的安全状态&lt;/p>
&lt;/blockquote>
&lt;p>有一个有 &lt;code>n&lt;/code> 个节点的有向图，节点按 &lt;code>0&lt;/code> 到 &lt;code>n - 1&lt;/code> 编号。图由一个 &lt;strong>索引从 0 开始&lt;/strong> 的 2D 整数数组 &lt;code>graph&lt;/code>表示， &lt;code>graph[i]&lt;/code>是与节点 &lt;code>i&lt;/code> 相邻的节点的整数数组，这意味着从节点 &lt;code>i&lt;/code> 到 &lt;code>graph[i]&lt;/code>中的每个节点都有一条边。&lt;/p>
&lt;p>如果一个节点没有连出的有向边，则该节点是 &lt;strong>终端节点&lt;/strong> 。如果从该节点开始的所有可能路径都通向 &lt;strong>终端节点&lt;/strong> ，则该节点为 &lt;strong>安全节点&lt;/strong> 。&lt;/p>
&lt;p>返回一个由图中所有 &lt;strong>安全节点&lt;/strong> 组成的数组作为答案。答案数组中的元素应当按 &lt;strong>升序&lt;/strong> 排列。&lt;/p></description></item><item><title>迷路的机器人</title><link>https://zzzicode.github.io/post/%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA/</link><pubDate>Thu, 21 Dec 2023 20:36:09 +0800</pubDate><guid>https://zzzicode.github.io/post/%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA/</guid><description>&lt;blockquote>
&lt;p>🤖 迷路的机器人&lt;/p>
&lt;/blockquote>
&lt;p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。&lt;/p>
&lt;p>网格中的障碍物和空位置分别用 &lt;code>1&lt;/code> 和 &lt;code>0&lt;/code> 来表示。&lt;/p>
&lt;p>返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。&lt;/p></description></item><item><title>165.解密数字</title><link>https://zzzicode.github.io/post/165.%E8%A7%A3%E5%AF%86%E6%95%B0%E5%AD%97/</link><pubDate>Wed, 20 Dec 2023 20:34:20 +0800</pubDate><guid>https://zzzicode.github.io/post/165.%E8%A7%A3%E5%AF%86%E6%95%B0%E5%AD%97/</guid><description>&lt;blockquote>
&lt;p>🔓 165.解密数字&lt;/p>
&lt;/blockquote>
&lt;p>现有一串神秘的密文 &lt;code>ciphertext&lt;/code>，经调查，密文的特点和规则如下：&lt;/p>
&lt;ul>
&lt;li>密文由非负整数组成&lt;/li>
&lt;li>数字 0-25 分别对应字母 a-z&lt;/li>
&lt;/ul>
&lt;p>请根据上述规则将密文 &lt;code>ciphertext&lt;/code> 解密为字母，并返回共有多少种解密结果。&lt;/p></description></item><item><title>1144.递减元素使数组呈锯齿状</title><link>https://zzzicode.github.io/post/1144.%E9%80%92%E5%87%8F%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%91%88%E9%94%AF%E9%BD%BF%E7%8A%B6/</link><pubDate>Wed, 20 Dec 2023 19:47:28 +0800</pubDate><guid>https://zzzicode.github.io/post/1144.%E9%80%92%E5%87%8F%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%91%88%E9%94%AF%E9%BD%BF%E7%8A%B6/</guid><description>&lt;blockquote>
&lt;p>🪑 1144.递减元素使数组呈锯齿状&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code>，每次 &lt;strong>操作&lt;/strong> 会从中选择一个元素并 &lt;strong>将该元素的值减少 1&lt;/strong>。&lt;/p>
&lt;p>如果符合下列情况之一，则数组 &lt;code>A&lt;/code> 就是 &lt;strong>锯齿数组&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>每个偶数索引对应的元素都大于相邻的元素，即 &lt;code>A[0] &amp;gt; A[1] &amp;lt; A[2] &amp;gt; A[3] &amp;lt; A[4] &amp;gt; ...&lt;/code>&lt;/li>
&lt;li>或者，每个奇数索引对应的元素都大于相邻的元素，即 &lt;code>A[0] &amp;lt; A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; ...&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>返回将数组 &lt;code>nums&lt;/code> 转换为锯齿数组所需的最小操作次数。&lt;/p></description></item><item><title>120.三角形最小路径和</title><link>https://zzzicode.github.io/post/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</link><pubDate>Wed, 13 Dec 2023 19:55:00 +0800</pubDate><guid>https://zzzicode.github.io/post/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>🔽 120.三角形最小路径和&lt;/p>
&lt;/blockquote>
&lt;p>给定一个三角形 &lt;code>triangle&lt;/code> ，找出自顶向下的最小路径和。&lt;/p>
&lt;p>每一步只能移动到下一行中相邻的结点上。&lt;strong>相邻的结点&lt;/strong> 在这里指的是 &lt;strong>下标&lt;/strong> 与 &lt;strong>上一层结点下标&lt;/strong> 相同或者等于 &lt;strong>上一层结点下标 + 1&lt;/strong> 的两个结点。也就是说，如果正位于当前行的下标 &lt;code>i&lt;/code> ，那么下一步可以移动到下一行的下标 &lt;code>i&lt;/code> 或 &lt;code>i + 1&lt;/code> 。&lt;/p></description></item><item><title>373.查找和最小的k对数字</title><link>https://zzzicode.github.io/post/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/</link><pubDate>Fri, 08 Dec 2023 21:13:18 +0800</pubDate><guid>https://zzzicode.github.io/post/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/</guid><description>&lt;blockquote>
&lt;p>✨ 373.查找和最小的k对数字&lt;/p>
&lt;/blockquote>
&lt;p>给定两个以 &lt;strong>非递减顺序排列&lt;/strong> 的整数数组 &lt;code>nums1&lt;/code> 和 &lt;code>nums2&lt;/code> , 以及一个整数 &lt;code>k&lt;/code> 。&lt;/p>
&lt;p>定义一对值 &lt;code>(u,v)&lt;/code>，其中第一个元素来自 &lt;code>nums1&lt;/code>，第二个元素来自 &lt;code>nums2&lt;/code> 。&lt;/p>
&lt;p>请找到和最小的 &lt;code>k&lt;/code> 个数对 &lt;code>(u1,v1)&lt;/code>, &lt;code> (u2,v2)&lt;/code> &amp;hellip; &lt;code>(uk,vk)&lt;/code> 。&lt;/p></description></item><item><title>918.环形子数组的最大和</title><link>https://zzzicode.github.io/post/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link><pubDate>Mon, 04 Dec 2023 20:46:18 +0800</pubDate><guid>https://zzzicode.github.io/post/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>➰️ 918.环形子数组的最大和&lt;/p>
&lt;/blockquote>
&lt;p>给定一个长度为 &lt;code>n&lt;/code> 的&lt;strong>环形整数数组&lt;/strong> &lt;code>nums&lt;/code> ，返回 &lt;em>&lt;code>nums&lt;/code> 的非空 &lt;strong>子数组&lt;/strong> 的最大可能和&lt;/em> 。&lt;/p>
&lt;p>&lt;strong>环形数组&lt;/strong> 意味着数组的末端将会与开头相连呈环状。形式上， &lt;code>nums[i]&lt;/code> 的下一个元素是 &lt;code>nums[(i + 1) % n]&lt;/code> ， &lt;code>nums[i]&lt;/code> 的前一个元素是 &lt;code>nums[(i - 1 + n) % n]&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>子数组&lt;/strong> 最多只能包含固定缓冲区 &lt;code>nums&lt;/code> 中的每个元素一次。形式上，对于子数组 &lt;code>nums[i], nums[i + 1], ..., nums[j]&lt;/code> ，不存在 &lt;code>i &amp;lt;= k1, k2 &amp;lt;= j&lt;/code> 其中 &lt;code>k1 % n == k2 % n&lt;/code> 。&lt;/p></description></item><item><title>443.最小基因变化</title><link>https://zzzicode.github.io/post/443.%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/</link><pubDate>Thu, 30 Nov 2023 21:07:33 +0800</pubDate><guid>https://zzzicode.github.io/post/443.%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/</guid><description>&lt;blockquote>
&lt;p>🧬 443.最小基因变化&lt;/p>
&lt;/blockquote>
&lt;p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 &lt;code>'A'&lt;/code>、&lt;code>'C'&lt;/code>、&lt;code>'G'&lt;/code> 和 &lt;code>'T'&lt;/code> 之一。&lt;/p>
&lt;p>假设我们需要调查从基因序列 &lt;code>start&lt;/code> 变为 &lt;code>end&lt;/code> 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。&lt;/p>
&lt;ul>
&lt;li>例如，&lt;code>&amp;quot;AACCGGTT&amp;quot; --&amp;gt; &amp;quot;AACCGGTA&amp;quot;&lt;/code> 就是一次基因变化。&lt;/li>
&lt;/ul>
&lt;p>另有一个基因库 &lt;code>bank&lt;/code> 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 &lt;code>bank&lt;/code> 中）&lt;/p>
&lt;p>给你两个基因序列 &lt;code>start&lt;/code> 和 &lt;code>end&lt;/code> ，以及一个基因库 &lt;code>bank&lt;/code> ，请你找出并返回能够使 &lt;code>start&lt;/code> 变化为 &lt;code>end&lt;/code> 所需的最少变化次数。如果无法完成此基因变化，返回 &lt;code>-1&lt;/code> 。&lt;/p>
&lt;p>注意：起始基因序列 &lt;code>start&lt;/code> 默认是有效的，但是它并不一定会出现在基因库中。&lt;/p></description></item><item><title>909.蛇梯棋</title><link>https://zzzicode.github.io/post/909.%E8%9B%87%E6%A2%AF%E6%A3%8B/</link><pubDate>Tue, 28 Nov 2023 20:31:07 +0800</pubDate><guid>https://zzzicode.github.io/post/909.%E8%9B%87%E6%A2%AF%E6%A3%8B/</guid><description>&lt;blockquote>
&lt;p>🐍 909.蛇梯棋&lt;/p>
&lt;/blockquote>
&lt;p>给你一个大小为 &lt;code>n x n&lt;/code> 的整数矩阵 &lt;code>board&lt;/code> ，方格按从 &lt;code>1&lt;/code> 到 &lt;code>n2&lt;/code> 编号，编号遵循
&lt;a href="https://baike.baidu.com/item/%e7%89%9b%e8%80%95%e5%bc%8f%e8%bd%ac%e8%a1%8c%e4%b9%a6%e5%86%99%e6%b3%95/17195786" title="转行交替方式" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
转行交替方式
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a> ，&lt;strong>从左下角开始&lt;/strong> （即，从 &lt;code>board[n - 1][0]&lt;/code> 开始）每一行交替方向。&lt;/p>
&lt;p>玩家从棋盘上的方格 &lt;code>1&lt;/code> （总是在最后一行、第一列）开始出发。&lt;/p>
&lt;p>每一回合，玩家需要从当前方格 &lt;code>curr&lt;/code> 开始出发，按下述要求前进：&lt;/p>
&lt;ul>
&lt;li>选定目标方格&lt;code>next&lt;/code>，目标方格的编号符合范围&lt;code>[curr + 1, min(curr + 6, n2)]&lt;/code>&lt;/li>
&lt;li>该选择模拟了掷 &lt;strong>六面体骰子&lt;/strong> 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。&lt;/li>
&lt;li>传送玩家：如果目标方格 &lt;code>next&lt;/code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 &lt;code>next&lt;/code> 。&lt;/li>
&lt;li>当玩家到达编号 &lt;code>n2&lt;/code> 的方格时，游戏结束。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>r&lt;/code> 行 &lt;code>c&lt;/code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 &lt;code>board[r][c] != -1&lt;/code>，那个蛇或梯子的目的地将会是 &lt;code>board[r][c]&lt;/code>。编号为 &lt;code>1&lt;/code> 和 &lt;code>n2&lt;/code> 的方格上没有蛇或梯子。&lt;/p>
&lt;p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 &lt;strong>不能&lt;/strong> 继续移动。&lt;/p>
&lt;ul>
&lt;li>举个例子，假设棋盘是 &lt;code>[[-1,4],[-1,3]]&lt;/code> ，第一次移动，玩家的目标方格是 &lt;code>2&lt;/code> 。那么这个玩家将会顺着梯子到达方格 &lt;code>3&lt;/code> ，但 &lt;strong>不能&lt;/strong> 顺着方格 &lt;code>3&lt;/code> 上的梯子前往方格 &lt;code>4&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;p>返回达到编号为 &lt;code>n2&lt;/code> 的方格所需的最少移动次数，如果不可能，则返回 &lt;code>-1&lt;/code>。&lt;/p></description></item><item><title>76.最小覆盖子串</title><link>https://zzzicode.github.io/post/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</link><pubDate>Wed, 08 Nov 2023 21:51:45 +0800</pubDate><guid>https://zzzicode.github.io/post/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</guid><description>&lt;blockquote>
&lt;p>🏜️ 76.最小覆盖子串&lt;/p>
&lt;/blockquote>
&lt;p>给你一个字符串 &lt;code>s&lt;/code> 、一个字符串 &lt;code>t&lt;/code> 。返回 &lt;code>s&lt;/code> 中涵盖 &lt;code>t&lt;/code> 所有字符的最小子串。如果 &lt;code>s&lt;/code> 中不存在涵盖 &lt;code>t&lt;/code> 所有字符的子串，则返回空字符串 &lt;code>&amp;quot;&amp;quot;&lt;/code> 。&lt;/p></description></item><item><title>6.N字形变换</title><link>https://zzzicode.github.io/post/6.n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link><pubDate>Sat, 04 Nov 2023 19:31:25 +0800</pubDate><guid>https://zzzicode.github.io/post/6.n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid><description>&lt;blockquote>
&lt;p>🎈 6.N字形变换&lt;/p>
&lt;/blockquote>
&lt;p>将一个给定字符串 &lt;code>s&lt;/code> 根据给定的行数 &lt;code>numRows&lt;/code> ，以从上往下、从左到右进行 Z 字形排列。&lt;/p>
&lt;p>比如输入字符串为 &lt;code>&amp;quot;PAYPALISHIRING&amp;quot;&lt;/code> 行数为 &lt;code>3&lt;/code> 时，排列如下：&lt;/p>
&lt;div class="highlight">&lt;div style="color:#ef9f76;background-color:#303446;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="color:#ef9f76;background-color:#303446;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#774f3b">1
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#774f3b">2
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#774f3b">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="color:#ef9f76;background-color:#303446;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#babbf1">P&lt;/span> &lt;span style="color:#babbf1">A&lt;/span> &lt;span style="color:#babbf1">H&lt;/span> &lt;span style="color:#babbf1">N&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#babbf1">A&lt;/span> &lt;span style="color:#babbf1">P&lt;/span> &lt;span style="color:#babbf1">L&lt;/span> &lt;span style="color:#babbf1">S&lt;/span> &lt;span style="color:#babbf1">I&lt;/span> &lt;span style="color:#babbf1">I&lt;/span> &lt;span style="color:#babbf1">G&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#babbf1">Y&lt;/span> &lt;span style="color:#babbf1">I&lt;/span> &lt;span style="color:#babbf1">R&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&lt;code>&amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/code>。&lt;/p>
&lt;p>请你实现这个将字符串进行指定行数变换的函数：&lt;/p>
&lt;div class="highlight">&lt;div style="color:#ef9f76;background-color:#303446;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="color:#ef9f76;background-color:#303446;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#774f3b">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="color:#ef9f76;background-color:#303446;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#babbf1">string&lt;/span> &lt;span style="color:#99d1db">convert&lt;/span>&lt;span style="color:#99d1db">(&lt;/span>&lt;span style="color:#babbf1">string&lt;/span> &lt;span style="color:#babbf1">s&lt;/span>&lt;span style="color:#99d1db">,&lt;/span> &lt;span style="color:#e5c890">int&lt;/span> &lt;span style="color:#babbf1">numRows&lt;/span>&lt;span style="color:#99d1db">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>整数和罗马数字之间的转换</title><link>https://zzzicode.github.io/post/%E6%95%B4%E6%95%B0%E5%92%8C%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</link><pubDate>Thu, 02 Nov 2023 22:08:10 +0800</pubDate><guid>https://zzzicode.github.io/post/%E6%95%B4%E6%95%B0%E5%92%8C%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid><description>&lt;blockquote>
&lt;p>⛑️ 整数和罗马数字之间的转换&lt;/p>
&lt;/blockquote>
&lt;p>罗马数字包含以下七种字符： &lt;code>I&lt;/code>， &lt;code>V&lt;/code>， &lt;code>X&lt;/code>， &lt;code>L&lt;/code>，&lt;code>C&lt;/code>，&lt;code>D&lt;/code> 和 &lt;code>M&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>字符 数值
I 1
V 5
X 10
L 50
C 100
D 500
M 1000&lt;/p>
&lt;/blockquote>
&lt;p>例如， 罗马数字 2 写做 &lt;code>II&lt;/code> ，即为两个并列的 1。12 写做 &lt;code>XII&lt;/code> ，即为 &lt;code>X&lt;/code> + &lt;code>II&lt;/code> 。 27 写做 &lt;code>XXVII&lt;/code>, 即为 &lt;code>XX&lt;/code> + &lt;code>V&lt;/code> + &lt;code>II&lt;/code> 。&lt;/p>
&lt;p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 &lt;code>IIII&lt;/code>，而是 &lt;code>IV&lt;/code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 &lt;code>IX&lt;/code>。这个特殊的规则只适用于以下六种情况：&lt;/p>
&lt;ul>
&lt;li>&lt;code>I&lt;/code> 可以放在 &lt;code>V&lt;/code> (5) 和 &lt;code>X&lt;/code> (10) 的左边，来表示 4 和 9。&lt;/li>
&lt;li>&lt;code>X&lt;/code> 可以放在 &lt;code>L&lt;/code> (50) 和 &lt;code>C&lt;/code> (100) 的左边，来表示 40 和 90。&lt;/li>
&lt;li>&lt;code>C&lt;/code> 可以放在 &lt;code>D&lt;/code> (500) 和 &lt;code>M&lt;/code> (1000) 的左边，来表示 400 和 900。&lt;/li>
&lt;/ul>
&lt;p>给你一个整数，将其转为罗马数字。&lt;/p></description></item><item><title>380.线性时间时间插入、删除和获取随机元素</title><link>https://zzzicode.github.io/post/380.%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</link><pubDate>Tue, 31 Oct 2023 21:29:42 +0800</pubDate><guid>https://zzzicode.github.io/post/380.%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</guid><description>&lt;blockquote>
&lt;p>🍅 380.线性时间时间插入、删除和获取随机元素&lt;/p>
&lt;/blockquote>
&lt;p>实现&lt;code>RandomizedSet&lt;/code> 类：&lt;/p>
&lt;ul>
&lt;li>&lt;code>RandomizedSet()&lt;/code> 初始化 &lt;code>RandomizedSet&lt;/code> 对象&lt;/li>
&lt;li>&lt;code>bool insert(int val)&lt;/code> 当元素 &lt;code>val&lt;/code> 不存在时，向集合中插入该项，并返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>bool remove(int val)&lt;/code> 当元素 &lt;code>val&lt;/code> 存在时，从集合中移除该项，并返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>int getRandom()&lt;/code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 &lt;strong>相同的概率&lt;/strong> 被返回。&lt;/li>
&lt;/ul>
&lt;p>你必须实现类的所有函数，并满足每个函数的 &lt;strong>平均&lt;/strong> 时间复杂度为 &lt;code>O(1)&lt;/code> 。&lt;/p></description></item><item><title>H指数</title><link>https://zzzicode.github.io/post/h%E6%8C%87%E6%95%B0/</link><pubDate>Mon, 30 Oct 2023 20:02:05 +0800</pubDate><guid>https://zzzicode.github.io/post/h%E6%8C%87%E6%95%B0/</guid><description>&lt;blockquote>
&lt;p>🏞️ H指数&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>citations&lt;/code> ，其中 &lt;code>citations[i]&lt;/code> 表示研究者的第 &lt;code>i&lt;/code> 篇论文被引用的次数。计算并返回该研究者的 &lt;strong>&lt;code>h&lt;/code> 指数&lt;/strong>。&lt;/p>
&lt;p>根据维基百科上
&lt;a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin" title="h 指数的定义" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
h 指数的定义
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>：&lt;code>h&lt;/code> 代表“高引用次数” ，一名科研人员的 &lt;code>h&lt;/code> &lt;strong>指数&lt;/strong> 是指他（她）至少发表了 &lt;code>h&lt;/code> 篇论文，并且每篇论文 &lt;strong>至少&lt;/strong> 被引用 &lt;code>h&lt;/code> 次。如果 &lt;code>h&lt;/code> 有多种可能的值，&lt;strong>&lt;code>h&lt;/code> 指数&lt;/strong> 是其中最大的那个。&lt;/p></description></item><item><title>80.删除有序数组中的重复项II</title><link>https://zzzicode.github.io/post/80.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9ii/</link><pubDate>Sun, 29 Oct 2023 18:35:35 +0800</pubDate><guid>https://zzzicode.github.io/post/80.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9ii/</guid><description>&lt;blockquote>
&lt;p>🕯 80.删除有序数组中的重复项II&lt;/p>
&lt;/blockquote>
&lt;p>给你一个有序数组 &lt;code>nums&lt;/code> ，请你**
&lt;a href="http://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95" title=" 原地" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
原地
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>** 删除重复出现的元素，使得出现次数超过两次的元素&lt;strong>只出现两次&lt;/strong> ，返回删除后数组的新长度。&lt;/p>
&lt;p>不要使用额外的数组空间，你必须在 &lt;strong>
&lt;a href="https://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95" title="原地 " rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
原地
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>修改输入数组&lt;/strong> 并在使用 O(1) 额外空间的条件下完成。&lt;/p></description></item><item><title>278.寻找重复数</title><link>https://zzzicode.github.io/post/278.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</link><pubDate>Sat, 28 Oct 2023 21:16:20 +0800</pubDate><guid>https://zzzicode.github.io/post/278.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</guid><description>&lt;blockquote>
&lt;p>🕊︎ 278.寻找重复数&lt;/p>
&lt;/blockquote>
&lt;p>给定一个包含 &lt;code>n + 1&lt;/code> 个整数的数组 &lt;code>nums&lt;/code> ，其数字都在 &lt;code>[1, n]&lt;/code> 范围内（包括 &lt;code>1&lt;/code> 和 &lt;code>n&lt;/code>），可知至少存在一个重复的整数。&lt;/p>
&lt;p>假设 &lt;code>nums&lt;/code> 只有 &lt;strong>一个重复的整数&lt;/strong> ，返回 &lt;strong>这个重复的数&lt;/strong> 。&lt;/p>
&lt;p>你设计的解决方案必须 &lt;strong>不修改&lt;/strong> 数组 &lt;code>nums&lt;/code> 且只用常量级 &lt;code>O(1)&lt;/code> 的额外空间。&lt;/p></description></item><item><title>31.下一个排列</title><link>https://zzzicode.github.io/post/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</link><pubDate>Sat, 28 Oct 2023 20:20:24 +0800</pubDate><guid>https://zzzicode.github.io/post/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</guid><description>&lt;blockquote>
&lt;p>🧤 31.下一个排列&lt;/p>
&lt;/blockquote>
&lt;p>整数数组的一个 &lt;strong>排列&lt;/strong> 就是将其所有成员以序列或线性顺序排列。&lt;/p>
&lt;ul>
&lt;li>例如，&lt;code>arr = [1,2,3]&lt;/code> ，以下这些都可以视作 &lt;code>arr&lt;/code> 的排列：&lt;code>[1,2,3]&lt;/code>、&lt;code>[1,3,2]&lt;/code>、&lt;code>[3,1,2]&lt;/code>、&lt;code>[2,3,1]&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;p>整数数组的 &lt;strong>下一个排列&lt;/strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 &lt;strong>下一个排列&lt;/strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。&lt;/p>
&lt;ul>
&lt;li>例如，&lt;code>arr = [1,2,3]&lt;/code> 的下一个排列是 &lt;code>[1,3,2]&lt;/code> 。&lt;/li>
&lt;li>类似地，&lt;code>arr = [2,3,1]&lt;/code> 的下一个排列是 &lt;code>[3,1,2]&lt;/code> 。&lt;/li>
&lt;li>而 &lt;code>arr = [3,2,1]&lt;/code> 的下一个排列是 &lt;code>[1,2,3]&lt;/code> ，因为 &lt;code>[3,2,1]&lt;/code> 不存在一个字典序更大的排列。&lt;/li>
&lt;/ul>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，找出 &lt;code>nums&lt;/code> 的下一个排列。&lt;/p>
&lt;p>必须**
&lt;a href="https://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95" title=" 原地 " rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
原地
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>**修改，只允许使用额外常数空间。&lt;/p></description></item><item><title>152.乘积最大子数组</title><link>https://zzzicode.github.io/post/152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 23 Oct 2023 19:34:50 +0800</pubDate><guid>https://zzzicode.github.io/post/152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid><description>&lt;blockquote>
&lt;p>152.乘积最大子数组&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p>
&lt;p>测试用例的答案是一个 &lt;strong>32-位&lt;/strong> 整数。&lt;/p>
&lt;p>&lt;strong>子数组&lt;/strong> 是数组的连续子序列。&lt;/p></description></item><item><title>215.数组中的第k个最大元素</title><link>https://zzzicode.github.io/post/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 13 Oct 2023 21:31:44 +0800</pubDate><guid>https://zzzicode.github.io/post/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid><description>&lt;blockquote>
&lt;p>🍇 215.数组中的第k个最大元素&lt;/p>
&lt;/blockquote>
&lt;p>给定整数数组 &lt;code>nums&lt;/code> 和整数 &lt;code>k&lt;/code>，请返回数组中第 &lt;code>**k**&lt;/code> 个最大的元素。&lt;/p>
&lt;p>请注意，你需要找的是数组排序后的第 &lt;code>k&lt;/code> 个最大的元素，而不是第 &lt;code>k&lt;/code> 个不同的元素。&lt;/p>
&lt;p>你必须设计并实现时间复杂度为 &lt;code>O(n)&lt;/code> 的算法解决此问题。&lt;/p></description></item><item><title>79.单词搜索</title><link>https://zzzicode.github.io/post/79.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</link><pubDate>Sun, 08 Oct 2023 21:21:05 +0800</pubDate><guid>https://zzzicode.github.io/post/79.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</guid><description>&lt;blockquote>
&lt;p>🏳️‍🌈 79.单词搜索&lt;/p>
&lt;/blockquote>
&lt;p>给定一个 &lt;code>m x n&lt;/code> 二维字符网格 &lt;code>board&lt;/code> 和一个字符串单词 &lt;code>word&lt;/code> 。如果 &lt;code>word&lt;/code> 存在于网格中，返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p></description></item><item><title>22.括号生成</title><link>https://zzzicode.github.io/post/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</link><pubDate>Sat, 07 Oct 2023 20:21:15 +0800</pubDate><guid>https://zzzicode.github.io/post/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</guid><description>&lt;blockquote>
&lt;p>🏧 22.括号生成&lt;/p>
&lt;/blockquote>
&lt;p>数字 &lt;code>n&lt;/code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong>有效的&lt;/strong> 括号组合。&lt;/p></description></item><item><title>208.实现前缀树</title><link>https://zzzicode.github.io/post/208.%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/</link><pubDate>Wed, 04 Oct 2023 20:45:51 +0800</pubDate><guid>https://zzzicode.github.io/post/208.%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/</guid><description>&lt;blockquote>
&lt;p>🌴 208.实现前缀树&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>
&lt;a href="https://baike.baidu.com/item/%e5%ad%97%e5%85%b8%e6%a0%91/9825209?fr=aladdin" title="Trie" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
Trie
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/strong>（发音类似 &amp;ldquo;try&amp;rdquo;）或者说 &lt;strong>前缀树&lt;/strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。&lt;/p>
&lt;p>请你实现 Trie 类：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Trie()&lt;/code> 初始化前缀树对象。&lt;/li>
&lt;li>&lt;code>void insert(String word)&lt;/code> 向前缀树中插入字符串 &lt;code>word&lt;/code> 。&lt;/li>
&lt;li>&lt;code>boolean search(String word)&lt;/code> 如果字符串 &lt;code>word&lt;/code> 在前缀树中，返回 &lt;code>true&lt;/code>（即，在检索之前已经插入）；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>boolean startsWith(String prefix)&lt;/code> 如果之前已经插入的字符串 &lt;code>word&lt;/code> 的前缀之一为 &lt;code>prefix&lt;/code> ，返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;/ul></description></item><item><title>207.课程表</title><link>https://zzzicode.github.io/post/207.%E8%AF%BE%E7%A8%8B%E8%A1%A8/</link><pubDate>Tue, 03 Oct 2023 21:20:03 +0800</pubDate><guid>https://zzzicode.github.io/post/207.%E8%AF%BE%E7%A8%8B%E8%A1%A8/</guid><description>&lt;blockquote>
&lt;p>🧑‍💻 207.课程表&lt;/p>
&lt;/blockquote>
&lt;p>你这个学期必须选修 &lt;code>numCourses&lt;/code> 门课程，记为 &lt;code>0&lt;/code> 到 &lt;code>numCourses - 1&lt;/code> 。&lt;/p>
&lt;p>在选修某些课程之前需要一些先修课程。 先修课程按数组 &lt;code>prerequisites&lt;/code> 给出，其中 &lt;code>prerequisites[i] = [ai, bi]&lt;/code> ，表示如果要学习课程 &lt;code>ai&lt;/code> 则 &lt;strong>必须&lt;/strong> 先学习课程 &lt;code>bi&lt;/code> 。&lt;/p>
&lt;ul>
&lt;li>例如，先修课程对 &lt;code>[0, 1]&lt;/code> 表示：想要学习课程 &lt;code>0&lt;/code> ，你需要先完成课程 &lt;code>1&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;p>请你判断是否可能完成所有课程的学习？如果可以，返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/p></description></item><item><title>994.腐烂的橘子</title><link>https://zzzicode.github.io/post/994.%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</link><pubDate>Mon, 02 Oct 2023 21:30:29 +0800</pubDate><guid>https://zzzicode.github.io/post/994.%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</guid><description>&lt;blockquote>
&lt;p>🍊 994.腐烂的橘子&lt;/p>
&lt;/blockquote>
&lt;p>在给定的 &lt;code>m x n&lt;/code> 网格 &lt;code>grid&lt;/code> 中，每个单元格可以有以下三个值之一：&lt;/p>
&lt;ul>
&lt;li>值 &lt;code>0&lt;/code> 代表空单元格；&lt;/li>
&lt;li>值 &lt;code>1&lt;/code> 代表新鲜橘子；&lt;/li>
&lt;li>值 &lt;code>2&lt;/code> 代表腐烂的橘子。&lt;/li>
&lt;/ul>
&lt;p>每分钟，腐烂的橘子 &lt;strong>周围 4 个方向上相邻&lt;/strong> 的新鲜橘子都会腐烂。&lt;/p>
&lt;p>返回 &lt;em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 &lt;code>-1&lt;/code>&lt;/em> 。&lt;/p></description></item><item><title>236.二叉树的最近公共祖先</title><link>https://zzzicode.github.io/post/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Sun, 01 Oct 2023 20:54:57 +0800</pubDate><guid>https://zzzicode.github.io/post/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>&lt;blockquote>
&lt;p>🍇 236.二叉树的最近公共祖先&lt;/p>
&lt;/blockquote>
&lt;p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p>
&lt;p>
&lt;a href="https://baike.baidu.com/item/%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88/8918834?fr=aladdin" title="百度百科" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
百度百科
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong>一个节点也可以是它自己的祖先&lt;/strong>）。”&lt;/p></description></item><item><title>124.二叉树中的最大路径和</title><link>https://zzzicode.github.io/post/124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</link><pubDate>Sat, 30 Sep 2023 21:47:52 +0800</pubDate><guid>https://zzzicode.github.io/post/124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>🍃 124.二叉树中的最大路径和&lt;/p>
&lt;/blockquote>
&lt;p>二叉树中的 &lt;strong>路径&lt;/strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 &lt;strong>至多出现一次&lt;/strong> 。该路径 &lt;strong>至少包含一个&lt;/strong> 节点，且不一定经过根节点。&lt;/p>
&lt;p>&lt;strong>路径和&lt;/strong> 是路径中各节点值的总和。&lt;/p>
&lt;p>给你一个二叉树的根节点 &lt;code>root&lt;/code> ，返回其 &lt;strong>最大路径和&lt;/strong> 。&lt;/p></description></item><item><title>114.二叉树展开为链表</title><link>https://zzzicode.github.io/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 30 Sep 2023 21:07:06 +0800</pubDate><guid>https://zzzicode.github.io/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid><description>&lt;blockquote>
&lt;p>🌳 114.二叉树展开为链表&lt;/p>
&lt;/blockquote>
&lt;p>给你二叉树的根结点 &lt;code>root&lt;/code> ，请你将它展开为一个单链表：&lt;/p>
&lt;ul>
&lt;li>展开后的单链表应该同样使用 &lt;code>TreeNode&lt;/code> ，其中 &lt;code>right&lt;/code> 子指针指向链表中下一个结点，而左子指针始终为 &lt;code>null&lt;/code> 。&lt;/li>
&lt;li>展开后的单链表应该与二叉树
&lt;a href="https://baike.baidu.com/item/%e5%85%88%e5%ba%8f%e9%81%8d%e5%8e%86/6442839?fr=aladdin" title="&amp;lt;strong&amp;gt;先序遍历&amp;lt;/strong&amp;gt;" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
&lt;strong>先序遍历&lt;/strong>
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a> 顺序相同。&lt;/li>
&lt;/ul></description></item><item><title>25.k个一组翻转链表</title><link>https://zzzicode.github.io/post/25.k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 25 Sep 2023 21:19:33 +0800</pubDate><guid>https://zzzicode.github.io/post/25.k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>&lt;blockquote>
&lt;p>🍍 25.k个一组翻转链表&lt;/p>
&lt;/blockquote>
&lt;p>给你链表的头节点 &lt;code>head&lt;/code> ，每 &lt;code>k&lt;/code> 个节点一组进行翻转，请你返回修改后的链表。&lt;/p>
&lt;p>&lt;code>k&lt;/code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 &lt;code>k&lt;/code> 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p>
&lt;p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。&lt;/p>
&lt;img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="img" style="zoom:50%;" />
&lt;blockquote>
&lt;p>注意，不足k个的链表不能翻转，也就是上面的&lt;code>[4,5]&lt;/code>不能翻转&lt;/p>
&lt;/blockquote></description></item><item><title>2.两数相加</title><link>https://zzzicode.github.io/post/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link><pubDate>Mon, 25 Sep 2023 21:19:04 +0800</pubDate><guid>https://zzzicode.github.io/post/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid><description>&lt;blockquote>
&lt;p>2.两数相加&lt;/p>
&lt;/blockquote>
&lt;p>给你两个 &lt;strong>非空&lt;/strong> 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong>逆序&lt;/strong> 的方式存储的，并且每个节点只能存储 &lt;strong>一位&lt;/strong> 数字。&lt;/p>
&lt;p>请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p>
&lt;p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p></description></item><item><title>148.排序链表</title><link>https://zzzicode.github.io/post/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Sun, 24 Sep 2023 21:33:18 +0800</pubDate><guid>https://zzzicode.github.io/post/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description>&lt;blockquote>
&lt;p>🧭 148.排序链表&lt;/p>
&lt;/blockquote>
&lt;p>给你链表的头结点 &lt;code>head&lt;/code> ，请将其按 &lt;strong>升序&lt;/strong> 排列并返回 &lt;strong>排序后的链表&lt;/strong> 。&lt;/p></description></item><item><title>238.除自身以外数组的乘积</title><link>https://zzzicode.github.io/post/238.%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</link><pubDate>Mon, 18 Sep 2023 20:50:12 +0800</pubDate><guid>https://zzzicode.github.io/post/238.%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</guid><description>&lt;blockquote>
&lt;p>238.除自身以外数组的乘积&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code>，返回 &lt;em>数组 &lt;code>answer&lt;/code> ，其中 &lt;code>answer[i]&lt;/code> 等于 &lt;code>nums&lt;/code> 中除 &lt;code>nums[i]&lt;/code> 之外其余各元素的乘积&lt;/em> 。&lt;/p>
&lt;p>题目数据 &lt;strong>保证&lt;/strong> 数组 &lt;code>nums&lt;/code>之中任意元素的全部前缀元素和后缀的乘积都在 &lt;strong>32 位&lt;/strong> 整数范围内。&lt;/p>
&lt;p>请**不要使用除法，**且在 &lt;code>O(*n*)&lt;/code> 时间复杂度内完成此题。&lt;/p></description></item><item><title>239.滑动窗口最大值</title><link>https://zzzicode.github.io/post/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</link><pubDate>Sun, 17 Sep 2023 21:09:03 +0800</pubDate><guid>https://zzzicode.github.io/post/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</guid><description>&lt;blockquote>
&lt;p>🛴 239.滑动窗口最大值&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code>，有一个大小为 &lt;code>k&lt;/code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 &lt;code>k&lt;/code> 个数字。滑动窗口每次只向右移动一位。&lt;/p>
&lt;p>返回 &lt;em>滑动窗口中的最大值&lt;/em> 。&lt;/p></description></item><item><title>560.和为k的子数组</title><link>https://zzzicode.github.io/post/560.%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</link><pubDate>Fri, 15 Sep 2023 17:32:30 +0800</pubDate><guid>https://zzzicode.github.io/post/560.%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</guid><description>&lt;blockquote>
&lt;p>🦺 560.和为k的子数组&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，请你统计并返回 &lt;em>该数组中和为 &lt;code>k&lt;/code> 的连续子数组的个数&lt;/em> 。&lt;/p>
&lt;p>子数组是数组中元素的连续非空序列。&lt;/p></description></item><item><title>438.找到字符串中所有字母异位词</title><link>https://zzzicode.github.io/post/438.%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</link><pubDate>Thu, 14 Sep 2023 21:12:28 +0800</pubDate><guid>https://zzzicode.github.io/post/438.%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</guid><description>&lt;blockquote>
&lt;p>🗺 438.找到字符串中所有字母异位词&lt;/p>
&lt;/blockquote>
&lt;p>给定两个字符串 &lt;code>s&lt;/code> 和 &lt;code>p&lt;/code>，找到 &lt;code>s&lt;/code> 中所有 &lt;code>p&lt;/code> 的 &lt;strong>异位词&lt;/strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。&lt;/p>
&lt;p>&lt;strong>异位词&lt;/strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。&lt;/p></description></item><item><title>3.无重复字符的最长子串</title><link>https://zzzicode.github.io/post/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link><pubDate>Thu, 14 Sep 2023 20:53:10 +0800</pubDate><guid>https://zzzicode.github.io/post/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid><description>&lt;blockquote>
&lt;p>🌍 3.无重复字符的最长子串&lt;/p>
&lt;/blockquote>
&lt;p>给定一个字符串 &lt;code>s&lt;/code> ，请你找出其中不含有重复字符的 &lt;strong>最长子串&lt;/strong> 的长度。&lt;/p></description></item><item><title>11.盛最多水的容器</title><link>https://zzzicode.github.io/post/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link><pubDate>Tue, 12 Sep 2023 19:10:36 +0800</pubDate><guid>https://zzzicode.github.io/post/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid><description>&lt;blockquote>
&lt;p>🥣 11.盛最多水的容器&lt;/p>
&lt;/blockquote>
&lt;p>给定一个长度为 &lt;code>n&lt;/code> 的整数数组 &lt;code>height&lt;/code> 。有 &lt;code>n&lt;/code> 条垂线，第 &lt;code>i&lt;/code> 条线的两个端点是 &lt;code>(i, 0)&lt;/code> 和 &lt;code>(i, height[i])&lt;/code> 。&lt;/p>
&lt;p>找出其中的两条线，使得它们与 &lt;code>x&lt;/code> 轴共同构成的容器可以容纳最多的水。&lt;/p>
&lt;p>返回容器可以储存的最大水量。&lt;/p>
&lt;p>**说明：**你不能倾斜容器。&lt;/p></description></item><item><title>128.最长连续序列</title><link>https://zzzicode.github.io/post/128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 11 Sep 2023 21:11:09 +0800</pubDate><guid>https://zzzicode.github.io/post/128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</guid><description>&lt;blockquote>
&lt;p>📏 128.最长连续序列&lt;/p>
&lt;/blockquote>
&lt;p>给定一个未排序的整数数组 &lt;code>nums&lt;/code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;/p>
&lt;p>请你设计并实现时间复杂度为 &lt;code>O(n)&lt;/code> 的算法解决此问题。&lt;/p></description></item><item><title>49.字母异位词分组</title><link>https://zzzicode.github.io/post/49.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</link><pubDate>Mon, 11 Sep 2023 19:41:56 +0800</pubDate><guid>https://zzzicode.github.io/post/49.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</guid><description>&lt;blockquote>
&lt;p>🐹 49.字母异位词分组&lt;/p>
&lt;/blockquote></description></item><item><title>925.长按键入</title><link>https://zzzicode.github.io/post/925.%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/</link><pubDate>Tue, 29 Aug 2023 18:38:20 +0800</pubDate><guid>https://zzzicode.github.io/post/925.%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/</guid><description>&lt;blockquote>
&lt;p>🏔 925.长按键入&lt;/p>
&lt;/blockquote>
&lt;p>你的朋友正在使用键盘输入他的名字 &lt;code>name&lt;/code>。偶尔，在键入字符 &lt;code>c&lt;/code> 时，按键可能会被&lt;em>长按&lt;/em>，而字符可能被输入 1 次或多次。&lt;/p>
&lt;p>你将会检查键盘输入的字符 &lt;code>typed&lt;/code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 &lt;code>True&lt;/code>。&lt;/p></description></item><item><title>1002.查找共用元素</title><link>https://zzzicode.github.io/post/1002.%E6%9F%A5%E6%89%BE%E5%85%B1%E7%94%A8%E5%85%83%E7%B4%A0/</link><pubDate>Mon, 28 Aug 2023 21:07:18 +0800</pubDate><guid>https://zzzicode.github.io/post/1002.%E6%9F%A5%E6%89%BE%E5%85%B1%E7%94%A8%E5%85%83%E7%B4%A0/</guid><description>&lt;blockquote>
&lt;p>🏞 1002.查找共用元素&lt;/p>
&lt;/blockquote>
&lt;p>给你一个字符串数组 &lt;code>words&lt;/code> ，请你找出所有在 &lt;code>words&lt;/code> 的每个字符串中都出现的共用字符（ &lt;strong>包括重复字符&lt;/strong>），并以数组形式返回。你可以按 &lt;strong>任意顺序&lt;/strong> 返回答案。&lt;/p></description></item><item><title>1207.独一无二的出现次数</title><link>https://zzzicode.github.io/post/1207.%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</link><pubDate>Sun, 27 Aug 2023 19:12:33 +0800</pubDate><guid>https://zzzicode.github.io/post/1207.%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</guid><description>&lt;blockquote>
&lt;p>🎆 1207.独一无二的出现次数&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>arr&lt;/code>，请你帮忙统计数组中每个数的出现次数。&lt;/p>
&lt;p>如果每个数的出现次数都是独一无二的，就返回 &lt;code>true&lt;/code>；否则返回 &lt;code>false&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>注意是元素出现的次数独一无二，而不是元素独一无二&lt;/p>
&lt;/blockquote></description></item><item><title>337.打家劫舍III</title><link>https://zzzicode.github.io/post/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Diii/</link><pubDate>Sun, 20 Aug 2023 20:13:53 +0800</pubDate><guid>https://zzzicode.github.io/post/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Diii/</guid><description>&lt;blockquote>
&lt;p>🤡 337.打家劫舍III&lt;/p>
&lt;/blockquote>
&lt;p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 &lt;code>root&lt;/code> 。&lt;/p>
&lt;p>除了 &lt;code>root&lt;/code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵&lt;strong>二叉树&lt;/strong>”。 如果 &lt;strong>两个直接相连的房子在同一天晚上被打劫&lt;/strong> ，房屋将自动报警。&lt;/p>
&lt;p>给定二叉树的 &lt;code>root&lt;/code> 。返回 &lt;em>&lt;strong>在不触动警报的情况下&lt;/strong> ，小偷能够盗取的最高金额&lt;/em> 。&lt;/p>
&lt;blockquote>
&lt;p>能够偷盗的房屋形成了一个二叉树&lt;/p>
&lt;/blockquote></description></item><item><title>17.电话号码的字母组合</title><link>https://zzzicode.github.io/post/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link><pubDate>Sun, 13 Aug 2023 18:42:25 +0800</pubDate><guid>https://zzzicode.github.io/post/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid><description>&lt;blockquote>
&lt;p>☎ 17.电话号码的字母组合&lt;/p>
&lt;/blockquote>
&lt;p>给定一个仅包含数字 &lt;code>2-9&lt;/code> 的字符串，返回所有它能表示的字母组合。答案可以按 &lt;strong>任意顺序&lt;/strong> 返回。&lt;/p>
&lt;p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p>
&lt;p>&lt;img src="https://zzzicode.github.io/imgs/img-lazy-loading.gif" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img" />&lt;/p>
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>0 &amp;lt;= digits.length &amp;lt;= 4&lt;/code>&lt;/li>
&lt;li>&lt;code>digits[i]&lt;/code> 是范围 &lt;code>['2', '9']&lt;/code> 的一个数字。&lt;/li>
&lt;/ul></description></item><item><title>77.组合</title><link>https://zzzicode.github.io/post/77.%E7%BB%84%E5%90%88/</link><pubDate>Sun, 13 Aug 2023 18:07:55 +0800</pubDate><guid>https://zzzicode.github.io/post/77.%E7%BB%84%E5%90%88/</guid><description>&lt;blockquote>
&lt;p>🤏 77.组合&lt;/p>
&lt;/blockquote>
&lt;p>给定两个整数 &lt;code>n&lt;/code> 和 &lt;code>k&lt;/code>，返回范围 &lt;code>[1, n]&lt;/code> 中所有可能的 &lt;code>k&lt;/code> 个数的组合。&lt;/p>
&lt;p>你可以按 &lt;strong>任何顺序&lt;/strong> 返回答案。&lt;/p></description></item><item><title>236.二叉树的公共祖先</title><link>https://zzzicode.github.io/post/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Sat, 12 Aug 2023 19:39:59 +0800</pubDate><guid>https://zzzicode.github.io/post/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>&lt;blockquote>
&lt;p>🦧 236.二叉树的公共祖先&lt;/p>
&lt;/blockquote>
&lt;p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p>
&lt;p>
&lt;a href="https://baike.baidu.com/item/%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88/8918834?fr=aladdin" title="百度百科" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
百度百科
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong>一个节点也可以是它自己的祖先&lt;/strong>）。”&lt;/p></description></item><item><title>501.二叉搜索树中的众数</title><link>https://zzzicode.github.io/post/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</link><pubDate>Sat, 12 Aug 2023 17:57:25 +0800</pubDate><guid>https://zzzicode.github.io/post/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</guid><description>&lt;blockquote>
&lt;p>🍌 501.二叉搜索树中的众数&lt;/p>
&lt;/blockquote>
&lt;p>给你一个含重复值的二叉搜索树（BST）的根节点 &lt;code>root&lt;/code> ，找出并返回 BST 中的所有
&lt;a href="https://baike.baidu.com/item/%e4%bc%97%e6%95%b0/44796" title="众数" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
众数
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>（即，出现频率最高的元素）。&lt;/p>
&lt;p>如果树中有不止一个众数，可以按 &lt;strong>任意顺序&lt;/strong> 返回。&lt;/p>
&lt;p>假定 BST 满足如下定义：&lt;/p>
&lt;ul>
&lt;li>结点左子树中所含节点的值 &lt;strong>小于等于&lt;/strong> 当前节点的值&lt;/li>
&lt;li>结点右子树中所含节点的值 &lt;strong>大于等于&lt;/strong> 当前节点的值&lt;/li>
&lt;li>左子树和右子树都是二叉搜索树&lt;/li>
&lt;/ul></description></item><item><title>347.前k个高频元素</title><link>https://zzzicode.github.io/post/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</link><pubDate>Wed, 09 Aug 2023 20:24:26 +0800</pubDate><guid>https://zzzicode.github.io/post/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</guid><description>&lt;blockquote>
&lt;p>🦝 347.前k个高频元素&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，请你返回其中出现频率前 &lt;code>k&lt;/code> 高的元素。你可以按 &lt;strong>任意顺序&lt;/strong> 返回答案。&lt;/p></description></item><item><title>151.反转字符串中的单词</title><link>https://zzzicode.github.io/post/151.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</link><pubDate>Sat, 29 Jul 2023 19:18:52 +0800</pubDate><guid>https://zzzicode.github.io/post/151.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</guid><description>&lt;blockquote>
&lt;p>🔡 151.反转字符串中的单词&lt;/p>
&lt;/blockquote>
&lt;p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。&lt;/p>
&lt;p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。&lt;/p>
&lt;p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。&lt;/p>
&lt;p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。&lt;/p></description></item><item><title>541.反转字符串II</title><link>https://zzzicode.github.io/post/541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2ii/</link><pubDate>Fri, 28 Jul 2023 20:56:59 +0800</pubDate><guid>https://zzzicode.github.io/post/541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2ii/</guid><description>&lt;blockquote>
&lt;p>🤸 541.反转字符串II&lt;/p>
&lt;/blockquote>
&lt;p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果剩余字符少于 k 个，则将剩余字符全部反转。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>18.四数之和</title><link>https://zzzicode.github.io/post/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</link><pubDate>Thu, 27 Jul 2023 21:19:39 +0800</pubDate><guid>https://zzzicode.github.io/post/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>18.四数之和&lt;/p>
&lt;/blockquote>
&lt;p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：&lt;/p>
&lt;p>0 &amp;lt;= a, b, c, d &amp;lt; n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。&lt;/p></description></item><item><title>15.三数之和</title><link>https://zzzicode.github.io/post/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link><pubDate>Thu, 27 Jul 2023 20:36:40 +0800</pubDate><guid>https://zzzicode.github.io/post/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>➕︎ 15.三数之和&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 &lt;code>i != j、i != k，j != k&lt;/code> ，同时还满足 &lt;code>nums[i] + nums[j] + nums[k] == 0&lt;/code> 。请&lt;/p>
&lt;p>你返回所有和为 0 且不重复的三元组。&lt;/p>
&lt;p>注意：答案中不可以包含&lt;strong>重复&lt;/strong>的三元组。&lt;/p></description></item><item><title>454.四数相加</title><link>https://zzzicode.github.io/post/454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0/</link><pubDate>Thu, 27 Jul 2023 19:59:44 +0800</pubDate><guid>https://zzzicode.github.io/post/454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid><description>&lt;blockquote>
&lt;p>➕︎ 454.四数相加&lt;/p>
&lt;/blockquote>
&lt;p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：&lt;/p>
&lt;p>&lt;code>0 &amp;lt;= i, j, k, l &amp;lt; n&lt;/code>
&lt;code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0&lt;/code>&lt;/p></description></item><item><title>202.快乐数</title><link>https://zzzicode.github.io/post/202.%E5%BF%AB%E4%B9%90%E6%95%B0/</link><pubDate>Wed, 26 Jul 2023 22:00:02 +0800</pubDate><guid>https://zzzicode.github.io/post/202.%E5%BF%AB%E4%B9%90%E6%95%B0/</guid><description>&lt;blockquote>
&lt;p>😹 202.快乐数&lt;/p>
&lt;/blockquote>
&lt;p>编写一个算法来判断一个数 n 是不是快乐数。&lt;/p>
&lt;p>「快乐数」 定义为：&lt;/p>
&lt;p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。&lt;/p></description></item><item><title>142.环形链表II</title><link>https://zzzicode.github.io/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link><pubDate>Tue, 25 Jul 2023 19:08:49 +0800</pubDate><guid>https://zzzicode.github.io/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid><description>&lt;blockquote>
&lt;p>➰ 142.环形链表II&lt;/p>
&lt;/blockquote>
&lt;p>给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p>
&lt;p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。&lt;/p>
&lt;p>不允许修改 链表。&lt;/p></description></item><item><title>19.删除链表的倒数第N个结点</title><link>https://zzzicode.github.io/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</link><pubDate>Sun, 23 Jul 2023 20:45:15 +0800</pubDate><guid>https://zzzicode.github.io/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</guid><description>&lt;blockquote>
&lt;p>👋 19.删除链表的倒数第N个结点&lt;/p>
&lt;/blockquote>
&lt;p>给你一个链表，删除链表的倒数第 &lt;code>n&lt;/code> 个结点，并且返回链表的头结点。&lt;/p></description></item><item><title>59.螺旋矩阵II</title><link>https://zzzicode.github.io/post/59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</link><pubDate>Fri, 21 Jul 2023 20:18:31 +0800</pubDate><guid>https://zzzicode.github.io/post/59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</guid><description>&lt;blockquote>
&lt;p>😵 59.螺旋矩阵II&lt;/p>
&lt;/blockquote>
&lt;p>给你一个正整数 &lt;code>n&lt;/code> ，生成一个包含 &lt;code>1&lt;/code> 到 &lt;code>n2&lt;/code> 所有元素，且元素按顺时针顺序螺旋排列的 &lt;code>n x n&lt;/code> 正方形矩阵 &lt;code>matrix&lt;/code> 。&lt;/p></description></item><item><title>209.长度最小的数组</title><link>https://zzzicode.github.io/post/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84/</link><pubDate>Fri, 21 Jul 2023 19:51:08 +0800</pubDate><guid>https://zzzicode.github.io/post/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84/</guid><description>&lt;blockquote>
&lt;p>🔢 209.长度最小的数组&lt;/p>
&lt;/blockquote>
&lt;p>给定一个含有 n 个正整数的数组和一个正整数 target 。&lt;/p>
&lt;p>找出该数组中满足其和 ≥ target 的长度最小的 &lt;strong>连续&lt;/strong>子数组 [numsl, numsl+1, &amp;hellip;, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。&lt;/p></description></item><item><title>27.移除元素</title><link>https://zzzicode.github.io/post/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 21 Jul 2023 18:43:33 +0800</pubDate><guid>https://zzzicode.github.io/post/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid><description>&lt;blockquote>
&lt;p>🐵 27.移除元素&lt;/p>
&lt;/blockquote>
&lt;p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;/p>
&lt;p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。&lt;/p>
&lt;p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p></description></item><item><title>841.钥匙和房间</title><link>https://zzzicode.github.io/post/841.%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/</link><pubDate>Wed, 19 Jul 2023 19:38:57 +0800</pubDate><guid>https://zzzicode.github.io/post/841.%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/</guid><description>&lt;blockquote>
&lt;p>🗝️ 841.钥匙和房间&lt;/p>
&lt;/blockquote>
&lt;p>有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。&lt;/p>
&lt;p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。&lt;/p>
&lt;p>给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。&lt;/p></description></item><item><title>673.最长递增子序列的个数</title><link>https://zzzicode.github.io/post/673.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/</link><pubDate>Tue, 18 Jul 2023 19:14:49 +0800</pubDate><guid>https://zzzicode.github.io/post/673.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/</guid><description>&lt;blockquote>
&lt;p>📈 673.最长递增子序列的&lt;strong>个数&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>给定一个未排序的整数数组 &lt;code>nums&lt;/code> ， &lt;em>返回最长递增子序列的个数&lt;/em> 。&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong> 这个数列必须是 &lt;strong>严格&lt;/strong> 递增的。&lt;/p></description></item><item><title>131.分割回文串</title><link>https://zzzicode.github.io/post/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</link><pubDate>Tue, 18 Jul 2023 18:48:47 +0800</pubDate><guid>https://zzzicode.github.io/post/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</guid><description>&lt;blockquote>
&lt;p>🖇 131.分割回文串&lt;/p>
&lt;/blockquote>
&lt;p>给你一个字符串 &lt;code>s&lt;/code>，请你将 &lt;code>s&lt;/code> 分割成一些子串，使每个子串都是 &lt;strong>回文串&lt;/strong> 。返回 &lt;code>s&lt;/code> 所有可能的分割方案。&lt;/p>
&lt;p>&lt;strong>回文串&lt;/strong> 是正着读和反着读都一样的字符串。&lt;/p></description></item><item><title>5.最长回文子串</title><link>https://zzzicode.github.io/post/5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link><pubDate>Mon, 17 Jul 2023 19:43:08 +0800</pubDate><guid>https://zzzicode.github.io/post/5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid><description>&lt;blockquote>
&lt;p>5.最长回文子串“&lt;/p>
&lt;/blockquote>
&lt;p>给你一个字符串 &lt;code>s&lt;/code>，找到 &lt;code>s&lt;/code> 中&lt;strong>最长&lt;/strong>的回文子串。&lt;/p>
&lt;p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。&lt;/p></description></item><item><title>52.N皇后II</title><link>https://zzzicode.github.io/post/52.n%E7%9A%87%E5%90%8Eii/</link><pubDate>Mon, 17 Jul 2023 18:47:04 +0800</pubDate><guid>https://zzzicode.github.io/post/52.n%E7%9A%87%E5%90%8Eii/</guid><description>&lt;blockquote>
&lt;p>👑 52.N皇后II&lt;/p>
&lt;/blockquote>
&lt;p>n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p>
&lt;p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。&lt;/p></description></item><item><title>100.相同的树</title><link>https://zzzicode.github.io/post/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link><pubDate>Sun, 16 Jul 2023 20:14:10 +0800</pubDate><guid>https://zzzicode.github.io/post/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid><description>&lt;blockquote>
&lt;p>🌳 100.相同的树&lt;/p>
&lt;/blockquote>
&lt;p>给你两棵二叉树的根节点 &lt;code>p&lt;/code> 和 &lt;code>q&lt;/code> ，编写一个函数来检验这两棵树是否相同。&lt;/p>
&lt;p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p></description></item><item><title>1382.将二叉搜索树变平衡</title><link>https://zzzicode.github.io/post/1382.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/</link><pubDate>Sun, 16 Jul 2023 19:56:38 +0800</pubDate><guid>https://zzzicode.github.io/post/1382.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/</guid><description>&lt;blockquote>
&lt;p>🎋 1382.将二叉搜索树变平衡&lt;/p>
&lt;/blockquote>
&lt;p>给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。&lt;/p>
&lt;p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的&lt;/p></description></item><item><title>129.求根节点到叶节点数字之和</title><link>https://zzzicode.github.io/post/129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</link><pubDate>Fri, 14 Jul 2023 10:00:04 +0800</pubDate><guid>https://zzzicode.github.io/post/129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>🌴 129.求根节点到叶节点数字之和&lt;/p>
&lt;/blockquote>
&lt;p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：&lt;/p>
&lt;p>例如，从根节点到叶节点的路径 1 -&amp;gt; 2 -&amp;gt; 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。&lt;/p>
&lt;p>叶节点 是指没有子节点的节点。&lt;/p></description></item><item><title>205.同构字符串</title><link>https://zzzicode.github.io/post/205.%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 10 Jul 2023 18:48:14 +0800</pubDate><guid>https://zzzicode.github.io/post/205.%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>&lt;blockquote>
&lt;p>🔡 205.同构字符串&lt;/p>
&lt;/blockquote>
&lt;p>给定两个字符串 s 和 t ，判断它们是否是同构的。&lt;/p>
&lt;p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。&lt;/p>
&lt;p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。&lt;strong>不同字符不能映射到同一个字符上&lt;/strong>，相同字符只能映射到同一个字符上，字符可以映射到自己本身。&lt;/p></description></item><item><title>141.环形链表</title><link>https://zzzicode.github.io/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link><pubDate>Sun, 09 Jul 2023 18:47:58 +0800</pubDate><guid>https://zzzicode.github.io/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid><description>&lt;blockquote>
&lt;p>🍩 141.环形链表&lt;/p>
&lt;/blockquote>
&lt;p>给你一个链表的头节点 head ，判断链表中是否有环。&lt;/p>
&lt;p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。&lt;/p>
&lt;p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。&lt;/p>
&lt;img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:50%;" /></description></item><item><title>143.重排链表</title><link>https://zzzicode.github.io/post/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</link><pubDate>Sun, 09 Jul 2023 18:30:09 +0800</pubDate><guid>https://zzzicode.github.io/post/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</guid><description>&lt;blockquote>
&lt;p>⛓︎ 143.重排链表&lt;/p>
&lt;/blockquote>
&lt;p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：&lt;/p>
&lt;p>&lt;code>L0 → L1 → … → Ln - 1 → Ln&lt;/code>
请将其重新排列后变为：&lt;/p>
&lt;p>&lt;code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …&lt;/code>
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p></description></item><item><title>24.两两交换链表中的节点</title><link>https://zzzicode.github.io/post/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link><pubDate>Sun, 09 Jul 2023 17:14:05 +0800</pubDate><guid>https://zzzicode.github.io/post/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid><description>&lt;blockquote>
&lt;p>🔀 24.两两交换链表中的节点&lt;/p>
&lt;/blockquote>
&lt;p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。&lt;/p></description></item><item><title>922.按奇偶排序数组II</title><link>https://zzzicode.github.io/post/922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</link><pubDate>Sat, 08 Jul 2023 20:17:37 +0800</pubDate><guid>https://zzzicode.github.io/post/922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</guid><description>&lt;blockquote>
&lt;p>#️ 922.按奇偶排序数组II&lt;/p>
&lt;/blockquote>
&lt;p>给定一个非负整数数组 nums， nums 中一半整数是 奇数 ，一半整数是 偶数 。&lt;/p>
&lt;p>对数组进行排序，以便当 nums[i] 为奇数时，i 也是 奇数 ；当 nums[i] 为偶数时， i 也是 偶数 。&lt;/p>
&lt;p>你可以返回 任何满足上述条件的数组作为答案 。&lt;/p></description></item><item><title>34.在排序数组中查找元素的第一个和最后一个位置</title><link>https://zzzicode.github.io/post/34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</link><pubDate>Sat, 08 Jul 2023 19:14:13 +0800</pubDate><guid>https://zzzicode.github.io/post/34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</guid><description>&lt;blockquote>
&lt;p>🔢 34.在排序数组中查找元素的第一个和最后一个位置&lt;/p>
&lt;/blockquote>
&lt;p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。&lt;/p>
&lt;p>如果数组中不存在目标值 target，返回 [-1, -1]。&lt;/p>
&lt;p>你必须设计并实现时间复杂度为 &lt;code>O(log n)&lt;/code> 的算法解决此问题。&lt;/p></description></item><item><title>724.寻找数组的中心下标</title><link>https://zzzicode.github.io/post/724.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/</link><pubDate>Sat, 08 Jul 2023 18:48:21 +0800</pubDate><guid>https://zzzicode.github.io/post/724.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/</guid><description>&lt;blockquote>
&lt;p>❤‍🔥 724.寻找数组的中心下标&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 nums ，请计算数组的 中心下标 。&lt;/p>
&lt;p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。&lt;/p>
&lt;p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。&lt;/p>
&lt;p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。&lt;/p></description></item><item><title>189.轮转数组</title><link>https://zzzicode.github.io/post/189.%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</link><pubDate>Fri, 07 Jul 2023 20:37:15 +0800</pubDate><guid>https://zzzicode.github.io/post/189.%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</guid><description>&lt;blockquote>
&lt;p>🔄 189.轮转数组&lt;/p>
&lt;/blockquote>
&lt;p>给定一个整数数组 &lt;code>nums&lt;/code>，将数组中的元素向右轮转 &lt;code>k&lt;/code> 个位置，其中 &lt;code>k&lt;/code> 是非负数。&lt;/p>
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= nums.length &amp;lt;= 105&lt;/code>&lt;/li>
&lt;li>&lt;code>-231 &amp;lt;= nums[i] &amp;lt;= 231 - 1&lt;/code>&lt;/li>
&lt;li>&lt;code>0 &amp;lt;= k &amp;lt;= 105&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>941.有效的山脉数组</title><link>https://zzzicode.github.io/post/941.%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</link><pubDate>Wed, 05 Jul 2023 20:34:22 +0800</pubDate><guid>https://zzzicode.github.io/post/941.%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</guid><description>&lt;blockquote>
&lt;p>⛰ 941.有效的山脉数组&lt;/p>
&lt;/blockquote>
&lt;p>给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。&lt;/p>
&lt;p>让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组：&lt;/p>
&lt;ul>
&lt;li>&lt;code>arr.length &amp;gt;= 3&lt;/code>&lt;/li>
&lt;li>在 &lt;code>0 &amp;lt; i &amp;lt; arr.length - 1&lt;/code> 条件下，存在 i 使得：
&lt;ul>
&lt;li>&lt;code>arr[0] &amp;lt; arr[1] &amp;lt; ... arr[i-1] &amp;lt; arr[i]&lt;/code>&lt;/li>
&lt;li>&lt;code>arr[i] &amp;gt; arr[i+1] &amp;gt; ... &amp;gt; arr[arr.length - 1]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>1365.有多少小于当前数字的数字</title><link>https://zzzicode.github.io/post/1365.%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</link><pubDate>Tue, 04 Jul 2023 21:52:08 +0800</pubDate><guid>https://zzzicode.github.io/post/1365.%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</guid><description>&lt;blockquote>
&lt;p>󠀼󠀼👌1365.有多少小于当前数字的数字&lt;/p>
&lt;/blockquote>
&lt;p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。&lt;/p>
&lt;p>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &amp;lt; nums[i]&lt;/p>
&lt;p>以数组形式返回答案。&lt;/p></description></item><item><title>2196.根据描述创建二叉树</title><link>https://zzzicode.github.io/post/2196.%E6%A0%B9%E6%8D%AE%E6%8F%8F%E8%BF%B0%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Sun, 18 Jun 2023 17:47:49 +0800</pubDate><guid>https://zzzicode.github.io/post/2196.%E6%A0%B9%E6%8D%AE%E6%8F%8F%E8%BF%B0%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>&lt;blockquote>
&lt;p>🌳2196.根据描述创建二叉树&lt;/p>
&lt;/blockquote>
&lt;p>给你一个二维整数数组 descriptions ，其中 descriptions[i] = [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外：&lt;/p>
&lt;p>如果 &lt;code>isLefti == 1&lt;/code> ，那么 childi 就是 parenti 的&lt;strong>左&lt;/strong>子节点。
如果 &lt;code>isLefti == 0&lt;/code> ，那么 childi 就是 parenti 的&lt;strong>右&lt;/strong>子节点。
请你根据 descriptions 的描述来构造二叉树并返回其 根节点 。&lt;/p>
&lt;p>测试用例会保证可以构造出 有效 的二叉树。&lt;/p></description></item></channel></rss>