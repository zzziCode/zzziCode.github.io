<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>贪心算法 on zzzi的小站</title><link>https://zzzicode.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link><description>Recent content in 贪心算法 on zzzi的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 30 Jun 2023 19:59:51 +0800</lastBuildDate><atom:link href="https://zzzicode.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/rss.xml" rel="self" type="application/rss+xml"/><item><title>53.最大子数组和</title><link>https://zzzicode.github.io/post/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</link><pubDate>Fri, 30 Jun 2023 19:59:51 +0800</pubDate><guid>https://zzzicode.github.io/post/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>😄53.最大子数组和&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p>
&lt;p>&lt;strong>子数组&lt;/strong> 是数组中的一个&lt;strong>连续&lt;/strong>部分。&lt;/p></description></item><item><title>968.监控二叉树</title><link>https://zzzicode.github.io/post/968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Fri, 09 Jun 2023 17:53:37 +0800</pubDate><guid>https://zzzicode.github.io/post/968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>&lt;blockquote>
&lt;p>🌲968.监控二叉树&lt;/p>
&lt;/blockquote>
&lt;p>给定一个二叉树，我们在树的节点上安装摄像头。&lt;/p>
&lt;p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。&lt;/p>
&lt;p>计算监控树的所有节点所需的最小摄像头数量。&lt;/p></description></item><item><title>738.单调递增的数字</title><link>https://zzzicode.github.io/post/738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</link><pubDate>Thu, 08 Jun 2023 18:49:14 +0800</pubDate><guid>https://zzzicode.github.io/post/738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</guid><description>&lt;blockquote>
&lt;p>🔺738.单调递增的数字&lt;/p>
&lt;/blockquote>
&lt;p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;ul>
&lt;li>输入: N = 1234&lt;/li>
&lt;li>输出: 1234&lt;/li>
&lt;/ul>
&lt;p>示例 2:&lt;/p>
&lt;ul>
&lt;li>输入: N = 332&lt;/li>
&lt;li>输出: 299&lt;/li>
&lt;/ul></description></item><item><title>56.合并区间</title><link>https://zzzicode.github.io/post/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</link><pubDate>Thu, 08 Jun 2023 18:25:35 +0800</pubDate><guid>https://zzzicode.github.io/post/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</guid><description>&lt;blockquote>
&lt;p>😄56.合并区间&lt;/p>
&lt;/blockquote>
&lt;p>给出一个区间的集合，请合并所有重叠的区间。&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;ul>
&lt;li>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]&lt;/li>
&lt;li>输出: [[1,6],[8,10],[15,18]]&lt;/li>
&lt;li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].&lt;/li>
&lt;/ul>
&lt;p>示例 2:&lt;/p>
&lt;ul>
&lt;li>输入: intervals = [[1,4],[4,5]]&lt;/li>
&lt;li>输出: [[1,5]]&lt;/li>
&lt;li>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。&lt;/li>
&lt;li>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。&lt;/li>
&lt;/ul></description></item><item><title>763.划分字母区间</title><link>https://zzzicode.github.io/post/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</link><pubDate>Wed, 07 Jun 2023 19:02:45 +0800</pubDate><guid>https://zzzicode.github.io/post/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</guid><description>&lt;blockquote>
&lt;p>🆎763.划分字母区间&lt;/p>
&lt;/blockquote>
&lt;p>字符串 S 由小写字母组成。我们要把这个字符串划分为&lt;strong>尽可能多&lt;/strong>的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。&lt;/p>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>输入：S = &amp;ldquo;ababcbacadefegdehijhklij&amp;rdquo;&lt;/li>
&lt;li>输出：[9,7,8] 解释： 划分结果为 &amp;ldquo;ababcbaca&amp;rdquo;, &amp;ldquo;defegde&amp;rdquo;, &amp;ldquo;hijhklij&amp;rdquo;。 每个字母最多出现在一个片段中。 像 &amp;ldquo;ababcbacadefegde&amp;rdquo;, &amp;ldquo;hijhklij&amp;rdquo; 的划分是错误的，因为划分的片段数较少&lt;/li>
&lt;/ul></description></item><item><title>435.无重叠区间</title><link>https://zzzicode.github.io/post/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</link><pubDate>Wed, 07 Jun 2023 18:31:23 +0800</pubDate><guid>https://zzzicode.github.io/post/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</guid><description>&lt;blockquote>
&lt;p>😄435.无重叠区间&lt;/p>
&lt;/blockquote>
&lt;p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。&lt;/p>
&lt;p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。&lt;/p></description></item><item><title>452.用最少数量的箭引爆气球</title><link>https://zzzicode.github.io/post/452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</link><pubDate>Tue, 06 Jun 2023 16:22:09 +0800</pubDate><guid>https://zzzicode.github.io/post/452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</guid><description>&lt;blockquote>
&lt;p>💣452.用最少数量的箭引爆气球&lt;/p>
&lt;/blockquote>
&lt;p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。&lt;/p>
&lt;p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 &lt;code>xstart ≤ x ≤ xend&lt;/code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。&lt;/p>
&lt;p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。&lt;/p></description></item><item><title>406.根据身高重建队列</title><link>https://zzzicode.github.io/post/406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</link><pubDate>Mon, 05 Jun 2023 18:05:19 +0800</pubDate><guid>https://zzzicode.github.io/post/406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</guid><description>&lt;blockquote>
&lt;p>📏406.根据身高重建队列&lt;/p>
&lt;/blockquote>
&lt;p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。&lt;/p>
&lt;p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。&lt;/p>
&lt;blockquote>
&lt;p>将给定的二维数组重新排列,使其符合 [hi, ki]的要求&lt;/p>
&lt;/blockquote></description></item><item><title>860.柠檬水找零</title><link>https://zzzicode.github.io/post/860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</link><pubDate>Sun, 04 Jun 2023 16:11:37 +0800</pubDate><guid>https://zzzicode.github.io/post/860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</guid><description>&lt;blockquote>
&lt;p>🍋860.柠檬水找零&lt;/p>
&lt;/blockquote>
&lt;p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。&lt;/p>
&lt;p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。&lt;/p>
&lt;p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。&lt;/p>
&lt;p>注意，一开始你手头没有任何零钱。&lt;/p>
&lt;p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。&lt;/p></description></item><item><title>135.分发糖果</title><link>https://zzzicode.github.io/post/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</link><pubDate>Sun, 04 Jun 2023 15:03:43 +0800</pubDate><guid>https://zzzicode.github.io/post/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</guid><description>&lt;blockquote>
&lt;p>🍬135.分发糖果&lt;/p>
&lt;/blockquote>
&lt;p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。&lt;/p>
&lt;p>你需要按照以下要求，帮助老师给这些孩子分发糖果：&lt;/p>
&lt;ul>
&lt;li>每个孩子至少分配到 1 个糖果。&lt;/li>
&lt;li>相邻的孩子中，评分高的孩子必须获得更多的糖果。&lt;/li>
&lt;li>相邻孩子评分相同是可以分配相同的糖果&lt;/li>
&lt;/ul>
&lt;p>那么这样下来，老师至少需要准备多少颗糖果呢？&lt;/p></description></item><item><title>134.加油站</title><link>https://zzzicode.github.io/post/134.%E5%8A%A0%E6%B2%B9%E7%AB%99/</link><pubDate>Sat, 03 Jun 2023 19:06:25 +0800</pubDate><guid>https://zzzicode.github.io/post/134.%E5%8A%A0%E6%B2%B9%E7%AB%99/</guid><description>&lt;blockquote>
&lt;p>⛽134.加油站&lt;/p>
&lt;/blockquote>
&lt;p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 &lt;code>gas[i]&lt;/code> 升。&lt;/p>
&lt;p>你有一辆油箱容量无限的的汽车，从第 &lt;code>i&lt;/code> 个加油站开往第 &lt;code>i+1&lt;/code> 个加油站需要消耗汽油 &lt;code>cost[i]&lt;/code> 升。你从其中的一个加油站出发，开始时油箱为空。&lt;/p>
&lt;p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p>
&lt;blockquote>
&lt;p>要保证油箱中的油大于需要消耗的汽油&lt;/p>
&lt;p>基本思想就是最开始要积累足够多的剩余汽油，才够后面消耗&lt;/p>
&lt;/blockquote></description></item><item><title>1005.K次取反后最大化的数组和</title><link>https://zzzicode.github.io/post/1005.k%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/</link><pubDate>Fri, 02 Jun 2023 19:02:54 +0800</pubDate><guid>https://zzzicode.github.io/post/1005.k%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>😉1005.K次取反后最大化的数组和&lt;/p>
&lt;/blockquote>
&lt;p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）&lt;/p>
&lt;p>以这种方式修改数组后，返回数组可能的最大和。&lt;/p></description></item><item><title>45.跳跃游戏II</title><link>https://zzzicode.github.io/post/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/</link><pubDate>Thu, 01 Jun 2023 19:26:43 +0800</pubDate><guid>https://zzzicode.github.io/post/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/</guid><description>&lt;blockquote>
&lt;p>🚶‍♂️45.跳跃游戏II&lt;/p>
&lt;/blockquote>
&lt;p>给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p>
&lt;p>数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p>
&lt;p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。&lt;/p>
&lt;p>示例:&lt;/p>
&lt;ul>
&lt;li>输入: [2,3,1,1,4]&lt;/li>
&lt;li>输出: 2&lt;/li>
&lt;li>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。&lt;/li>
&lt;/ul>
&lt;p>说明: 假设你总是可以到达数组的最后一个位置&lt;/p></description></item><item><title>55.跳跃游戏</title><link>https://zzzicode.github.io/post/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</link><pubDate>Thu, 01 Jun 2023 18:52:01 +0800</pubDate><guid>https://zzzicode.github.io/post/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</guid><description>&lt;blockquote>
&lt;p>🏃‍♂️55.跳跃游戏&lt;/p>
&lt;/blockquote>
&lt;p>给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p>
&lt;p>数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p>
&lt;p>判断你是否能够到达最后一个位置。&lt;/p></description></item><item><title>121.买卖股票的最佳时机</title><link>https://zzzicode.github.io/post/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link><pubDate>Wed, 31 May 2023 18:30:03 +0800</pubDate><guid>https://zzzicode.github.io/post/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid><description>&lt;blockquote>
&lt;p>💰121.买卖股票的最佳时机&lt;/p>
&lt;/blockquote>
&lt;p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。&lt;/p>
&lt;p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。&lt;/p>
&lt;p>尽可能地在最低点买入，然后在之后的最高点卖出，只买卖一次&lt;/p>
&lt;p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。&lt;/p></description></item><item><title>122.买卖股票的最佳时机II</title><link>https://zzzicode.github.io/post/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</link><pubDate>Wed, 31 May 2023 18:20:37 +0800</pubDate><guid>https://zzzicode.github.io/post/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</guid><description>&lt;blockquote>
&lt;p>💰122.买卖股票的最佳时机II&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。&lt;/p>
&lt;p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候&lt;strong>最多&lt;/strong>只能持有 一股 股票。你也可以先购买，然后在同一天出售。&lt;/p>
&lt;p>多次买卖，且买卖时间不能重合，但是卖和买可以在同一天，所以需要将多次买卖的利润求和&lt;/p>
&lt;p>返回 你能获得的&lt;strong>最大&lt;/strong>利润 。&lt;/p></description></item><item><title>53.最大子序和</title><link>https://zzzicode.github.io/post/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</link><pubDate>Tue, 30 May 2023 15:59:20 +0800</pubDate><guid>https://zzzicode.github.io/post/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</guid><description>&lt;blockquote>
&lt;p>💫53.最大子序和&lt;/p>
&lt;/blockquote>
&lt;p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p>
&lt;p>示例:&lt;/p>
&lt;ul>
&lt;li>输入: [-2,1,-3,4,-1,2,1,-5,4]&lt;/li>
&lt;li>输出: 6&lt;/li>
&lt;li>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6&lt;/li>
&lt;/ul></description></item><item><title>455.分发饼干</title><link>https://zzzicode.github.io/post/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</link><pubDate>Mon, 29 May 2023 19:52:01 +0800</pubDate><guid>https://zzzicode.github.io/post/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</guid><description>&lt;blockquote>
&lt;p>👶455.分发饼干&lt;/p>
&lt;/blockquote>
&lt;p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。&lt;/p>
&lt;p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &amp;gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p></description></item></channel></rss>