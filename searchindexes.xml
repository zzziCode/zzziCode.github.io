<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>开始</title><url>/post/external-link/</url><categories><category>开始</category></categories><tags><tag>开始</tag></tags><content type="html"> 🚀🚀🚀 盛年不重来，一日难再晨。及时当勉励，岁月不待人。</content></entry><entry><title>二分查找</title><url>/post/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url><categories><category>学习笔记</category></categories><tags><tag>二分查找</tag></tags><content type="html"><![CDATA[   🕧 二分查找
根据灵神的二分查找题单以及视频教程总结的二分查找模版，主要针对闭区间，左闭右开区间，开区间三种形式去找大于等于target的元素位置做了总结，并针对&amp;gt;，&amp;gt;=，&amp;lt;，&amp;lt;=四种关系做了转换，核心点在于找到循环不变量，可以理解为找到target，之后确定上下界就可以完美利用二分模版解决问题
模版二分查找的模板适合用在查找与某一个给定元素存在一定关系的元素位置，并且给定的元素是有序的，或者元素排序不影响结果，此时可以考虑用二分查找，核心点需要确定循环不变量以及上下界，当某一个边界无法确定时，可以使用开区间，都可以确定时，使用闭区间
闭区间（推荐）初始化：left和right需要初始化为0和len-1 循环条件：区间内没有元素的情况是left&amp;gt;right，所以循环条件为left&amp;lt;=right 结果位置：结束循环时，left和right的位置为：[right,left]，所以结果位置为left或者right+1 模板如下：
1 2 3 4 5 6 7 8 9 10 11 12 // 找到大于等于target的第一个位置 private int lower_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left &amp;lt;= right) {//left等于right时区间有一个元素 int mid = left + (right - left) / 2; if (nums[mid] &amp;lt; target) left = mid + 1; else//在这里可以找到 right = mid - 1; } return left;//返回left或者right+1 } 左闭右开区间初始化：left和right需要初始化为0和len 循环条件：区间内没有元素的情况是left=right，所以循环条件为left&amp;lt;right 结果位置：结束循环时，left和right的位置为left+1=right，所以二者都可以当成结果 结果位置：结束循环时，left和right的位置为：left=right，所以结果位置为left或者right都可以 模板如下：
1 2 3 4 5 6 7 8 9 10 11 12 //  …  ]]></content></entry><entry><title>滑动窗口</title><url>/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url><categories><category>学习笔记</category></categories><tags><tag>滑动窗口</tag></tags><content type="html"><![CDATA[   🚍 滑动窗口
根据灵神的滑动窗口题单总结的滑动窗口模版，主要分为两个大类，重点在于变长滑动窗口时如何减小时间复杂度
定长滑动窗口定长滑动窗口的精髓是固定k
所谓的定长，指的是窗口的长度不变，题目中一般会给出长度为K的限制，此时只需要一个单指针right就可以固定住窗口大小，窗口滑动时，左边窗口的位置可以用right-k来计算，不符合要求的元素扔掉即可，模版为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { //一般题目会给定数组或者字符串，以及窗口的固定大小 public void staticWindow(int[] arr, int k) { int right=0; while(right&amp;lt;arr.length){ //在这里累加或者统计窗口中符合条件元素的个数 if(arr[right++] 满足条件) //统计 //形成了k大小的窗口 if(right&amp;gt;=k){ //针对当前窗口做业务 //窗口滑动，删除左边的元素 sum-=arr[right-k]; } } //返回结果 } } 变长滑动窗口求最大最小求最大和最小在不同的地方更新，最小在内部，最大在外部
变长滑动窗口的精髓是找到边界条件
变长滑动窗口只有两个操作，并且需要两个指针，因为此时窗口大小是变化的：
变长，只要没触发边界条件就一直变长 缩短：一旦触发边界条件，就开始缩短 根据这种分析，得到一个滑动窗口的模版：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int dynamicWidow(int[] nums) { //变长窗口必须两个指针 int right = 0, left = 0; while (right &amp;lt; nums.length) { //不断滑动，有可能是累加窗口中的元素值，也有可能是统计元素出现次数 while(left&amp;lt;=right&amp;amp;&amp;amp;false){//这里的left&amp;lt;=right看情况添加 //求最小值在这里尝试更新结果 ++left; } //求最大值在这里尝试更新结果 //滑动 ++right; } // 最后一个窗口别漏掉 res …  ]]></content></entry><entry><title>Java面经</title><url>/post/java%E9%9D%A2%E7%BB%8F/</url><categories><category>面试</category></categories><tags><tag>面经</tag><tag>java</tag></tags><content type="html"> java面经
什么是JVM
是java虚拟机，有了它java才有了跨平台的特性，他屏蔽了底层具体平台的差异，使得java可以跨平台 java编译成统一的.class文件，然后交给不同平台的虚拟机，解释成不同平台的机器指令完成跨平台 任何可以通过java编译的语言都可以放到jvm上解释执行，例如Groovy，Kotlin JDK，JRE，JVM的关系
JDK是java的开发包，内部包含JRE运行时环境 JRE是java的运行时环境，内部包含JVM JVM编译java语言的字节码文件，屏蔽平台的差异性，使得java语言可以跨平台 JVM的结构
类加载器：主要负责将.class文件加载到内存中，主要有四种： 启动类加载器：用来加载java核心类库，无法被java程序直接引用 扩展类加载器：加载java的扩展库，主要是从jvm提供的扩展库中加载java类 系统类加载器：通过系统类路径加载本地化的文件，java应用的类都是由这个加载器加载的 用户自定义类加载器：继承一个类实现自定义的类加载器 运行时数据区：执行java代码时，需要在内存中处理各种类型的数据，这些内存区域主要分为： 方法区 堆 栈 程序计数器 本地方法栈 执行引擎：包含一个虚拟处理器，即时编译器（JIT），垃圾回收器（GC），用来执行字节码文件 类加载器ClassLoader的工作过程
加载：通过类的全限定名获取类的class文件的二进制字节流，为其创建一个class对象 链接： 验证：确保被加载的类的正确性，比如语法，语义等 准备：给类中的静态变量分配内存并加上默认值 解析：将类的符号引用转换成直接引用</content></entry><entry><title>873.最长的斐波那契子序列的长度</title><url>/post/873.%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🍉 873.最长的斐波那契子序列的长度
如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：
n &amp;amp;gt;= 3 对于所有 i + 2 &amp;amp;lt;= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。
（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）
思路
基本思想
​ 看到这种求子序列的题目，第一想法是按照滑动窗口进行处理，但是题目描述序列中可以删除一些元素，也就是不是连续序列，所以此时滑动窗口这种求连续序列的方法就无法使用，进而使用动态规划来做；
​ 动态规划最重要的就是确定dp数组的含义，本题中为了找到一个最长的斐波那契数列，需要不断进行累加，也就是不断在原有斐波那契数列末尾arr[k]的基础上增加两个元素arr[i]和arr[j]，使得这三者符合斐波那契数列的特点，所以dp[i][j]的含义就是以arr[i]和arr[j]结尾的最长斐波那契数列的长度；
​ 当前元素为arr[i]，此时arr[j]是从i开始向后任意找一个元素，然后arr[k]代表从0~i-1中任意找一个元素，符合arr[k]+arr[i]=arr[j]即可，相当于一个三层循环，每次针对不同的arr[i]和arr[j]组合都要重新寻找arr[k]，观察到题目中描述元素严格递增，说明没有重复元素，所以我们可以保存元素及其下标的对应关系
​ 一旦有了arr[i]和arr[j]的组合，使用arr[j]-arr[j]就可以得到我们要找的arr[k]，再判断这个元素的下标是不是在0~i-1中即可
执行流程
初始化dp数组，所有的元素值都为2，因为一旦找到一个最小的斐波那契数列，这个长度为3 针对不同位置的arr[i]，arr[j]元素的下标从i+1开始 使用arr[j]-arr[j]得到要找的arr[k]，判断其下标是否符合要求 不停地向后更新dp 返回结果 代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 …</content></entry><entry><title>372.超级次方</title><url>/post/372.%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🍈 372.超级次方
你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。
思路
基本思想
题目的意思很好理解，就是计算两个数的幂，但是不管是底数还是指数都有可能很大，如果直接计算的话，必定会超过数据范围从而溢出，所以需要将数字进行拆分，然后在每一步都余上题目所说的1337
以7^1569次方举例，化简成公式为： $$ 7^{1569}=7^{1000}*7^{500}*7^{60}*7^{9} $$ 根据题目中给出的要求，质数按照数组给出，所以我们每次取数组最末尾的元素计算快速幂，每次这样每次指数的大小会被控制到10以内，底数在计算过程中余上1337也不会很大，所以就不会越界
当计算完7^9之后，剩下的7^1560可以分为： $$ 7^{1560}=(7^{10})^{156} $$ 也就是去掉1560后面的0，将变大即可，底数变大的过程中也需要余上1337，这样指数和底数都会慢慢的分解，不会一下变得很大，从而不会超过数据范围
执行流程
从尾部遍历b，每次取出一个最低位的指数计算快速幂 计算完快速幂之后，将底数变大，计算底数的10次幂，目的是为了将1560形式的指数分解为156 针对156这样的指数继续选择一个最低位的计算快速幂，不停地将快速幂的答案加到结果中 剩下的150继续拆分成15*10，将底数变大 计算每一个快速幂的过程中都要余上1337防止越界 代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int superPow(int a, int[] b) { // 针对每一个数位 int res = 1; int x = a % 1337; for (int i = b.length - 1; i &amp;gt;= 0; --i) { res = (res * myPow(x, b[i])) % 1337; //将指数1560变成156，然后继续取低位 x = myPow(x, 10) % 1337;//底数变大 } return res; } //快速幂的计算方式 public int myPow(int x, int pow) { int res = 1; while (pow != 0) { if (pow % 2 != 0) { res = (res * x) % 1337; } x *= x; x %= 1337; pow /= 2; } return res; } } 总结
主要是要学会将很大的指数慢慢变小，一边变小的同时也不会超出数据范围，核心店就是将1569拆成1000+500+60+9，之后拆出9之后，剩下的1560将底数计算10次幂，指数变成156之后继续拆成100+50+6，以此类推，不直接利用很大的指数计算幂</content></entry><entry><title>埃氏筛和线性筛</title><url>/post/%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E7%BA%BF%E6%80%A7%E7%AD%9B/</url><categories><category>学习笔记</category></categories><tags><tag>质数</tag><tag>埃氏筛</tag><tag>线性筛</tag></tags><content type="html"><![CDATA[   🍇埃氏筛和线性筛
本文中介绍两种快速求出给定范围内所有质数的快速办法，不用再逐个判断，大大缩短了质数的求解时间，可以用来解决很多算法问题
埃氏筛埃氏筛的 核心就是从小开始，遇到一个质数就向后去掉所有当前质数的倍数，走到当前数字时，如果当前数字没有被去掉，说明比当前数字小的数中不存在当前数的因子，也就是当前数是质数
为了判断某一个数是否被去掉，可以使用一个辅助数组flag来记录，当前数X是质数时需要划掉他的倍数，我们可以从x^2开始遍历，每次都X步，因为x到x^2之间的数如果其不是质数，那么一定会被小于x的质数划掉，这里优化一小部分，得到的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void isPrime(int right) { boolean[] flag = new boolean[right + 1]; List&lt;Integer&gt; prime = new ArrayList&lt;&gt;(); Arrays.fill(flag, true); for (int i = 2; i &lt;= right; ++i) { //当前数没有被划掉，说明当前数是质数 if (flag[i]) { prime.add(i); //去掉当前质数的所有倍数 for (int j = i * i; j &lt;= right; j += i) { flag[j] = false; } } } } 从2开始，直到达到给定的范围，此时一定可以求出所有的质数
如果给定的范围right过大，那么就将去除倍数的起点变成i+i，防止平方数过大越界
线性筛（欧拉筛）​	线性筛的思想是为了改进埃氏筛中一个数被划掉多次的情况，为了划掉所有不是质数的数，我们在每个数的基础上乘以小于这个数，并且不是这个数的因子的质数，这样划掉的数可以保证是被它的最小质因子划掉
​	例如当前数为4，比当前数小的质数由2和3，由于2是4的因子，所以只能划掉2*4=8，不能划掉3*4=12，因为这个12会被6划掉，不能划掉多次
​	相当于我们在划掉所有不符合要求的数时，要保证当前数只能被自己的最小质因子划掉，也就是12不能被3划掉，只能被2划掉，为了找到这个最小质因子，就要保证当前数的因子出现后，就不能进行划分，最后得到的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static void isPrime(int right) { boolean[] flag = new boolean[right + 1]; List&lt;Integer&gt; prime = new ArrayList&lt;&gt;(); Arrays.fill(flag, true); for (int i = 2; i &lt;= right; ++i) { //当前数没有被划掉，说明当前数是质数 if (flag[i]) { prime.add(i); } //针对当前数来说，只划掉能划掉的数 for (int j = 0; j &lt; prime.size(); ++j) { if (i * prime.get(j) &gt; right) break; //划掉当前数的倍数 flag[i * prime.get(j)] = false; //出现了最小质因子 if (i % prime.get(j) == 0) break; } } } 如果无法理解线性筛，埃氏筛也能解决大部分问题，因为埃氏筛的思想就是一旦出现一个质数，就将当前范围内质数的所有倍数全部划掉，线性筛只是埃氏筛的优化版，基本原理还是划掉不是质数的数
  ]]></content></entry><entry><title>2385.感染二叉树需要的总时间</title><url>/post/2385.%E6%84%9F%E6%9F%93%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9C%80%E8%A6%81%E7%9A%84%E6%80%BB%E6%97%B6%E9%97%B4/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   ☣ 2385.感染二叉树需要的总时间
给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。
每分钟，如果节点满足以下全部条件，就会被感染：
节点此前还没有感染。 节点与一个已感染节点相邻。 返回感染整棵树需要的分钟数*。*
思路基本思想​	因为被感染的节点都是当前节点的邻居节点，所以第一步就是要求出所有节点的邻居节点，又因为题目中说，所有的节点互不相同，所以可以用一个map存储所有节点的邻居节点
​	节点的邻居节点无非就是父节点和两个孩子节点，所以可以直接用一次遍历，然后记录当前节点的父节点，遍历结束就可以形成所有节点的邻居节点，代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //找到每一个节点的相邻节点 public void help(TreeNode root,TreeNode pre){ if(root==null) return; List&amp;lt;Integer&amp;gt; neighbor=map.getOrDefault(root.val,new ArrayList&amp;lt;&amp;gt;()); //将当前节点的邻居全部记录下来 if(pre!=null) neighbor.add(pre.val); if(root.left!=null) neighbor.add(root.left.val); if(root.right!=null) neighbor.add(root.right.val); //将当前节点的所有邻居加入 map.put(root.val,neighbor); set.add(root.val); help(root.left,root); help(root.right,root); } ​	有了邻居节点之后，需要从一个start节点开始感染，每次感染的都是自己的邻居节点，相当于一层一层的扩散，这种层式的扩散可以使用层次遍历来模拟，每一层遍历的都是当前这一分钟被感染的节点，下一分钟将要被感染的节点就是当前这些节点的未被感染邻居节点
​	为了判断哪些节点没有被感染，需要使用一个set来记录，正好在遍历的过程中就可以保存所有的节点，这样依赖就形成了完成的流程
执行流程利用前序遍历 …  ]]></content></entry><entry><title>1509.三次操作后的最大值与最小值</title><url>/post/1509.%E4%B8%89%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%80%BC/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🧀 1509.三次操作后的最大值与最小值
给你一个数组 nums 。
每次操作你可以选择 nums 中的任意一个元素并将它改成 任意值 。
在 执行最多三次移动后 ，返回 nums 中最大值与最小值的最小差值。
思路基本思想只能修改三个，必须找到一个目标值修改，修改之后要求最值之间的差最小，第一想法就是排序，然后要么将最大值改小，要么把最小值改大，这样可以使得最值之间的差变小
修改时，需要注意要把尽可能小和尽可能大的数进行修改，所以有以下四种情况：
修改3小0大 修改2小1大 修改1小2大 修改0小3大 修改之后分别对应的最值为：
1 2 3 4 5 //nums已经拍过序 int res1=nums[nums.length-1]-nums[3]; int res2=nums[nums.length-2]-nums[2]; int res3=nums[nums.length-3]-nums[1]; int res4=nums[nums.length-4]-nums[0]; 如果看不明白，可以把修改看成删除，因为修改之后的元素变成某一个目标元素，此时最值变到了新的位置，例如删除1小2大之后，最小值变到了nums[1]的位置，最大值变到了nums[nums.length-3]的位置，此时直接计算二者的差即可，最后返回四种情况的最小值
执行流程将数组排序 计算四种情况的结果 返回四种结果中的最小值 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { //要么大变小，要么小变大（考虑的不全面） //变化其实可以理解为删除，所以： //要么删除3小0大 //要么删除2小1大 //要么删除1小2大 //要么删除0小3大 public int minDifference(int[] nums) { //少于5个数时，三步之内一定可以变成全相同的数 if(nums.length&lt;5) return 0; //要么大变小，要么小变大，这种思路很暴力 Arrays.sort(nums); int res1=nums[nums.length-1]-nums[3]; int res2=nums[nums.length-2]-nums[2]; int res3=nums[nums.length-3]-nums[1]; int res4=nums[nums.length-4]-nums[0]; //返回四种情况的最小值 int res=Integer.MAX_VALUE; res=res&gt;res1?res1:res; res=res&gt;res2?res2:res; res=res&gt;res3?res3:res; res=res&gt;res4?res4:res; return res; } } 总结主要是要有贪心的思想，修改的只能是最值，不然差距不可能变小，因为最终的结果是由当前的最值计算得到的
  ]]></content></entry><entry><title>系统面经</title><url>/post/%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F/</url><categories><category>面试</category></categories><tags><tag>面经</tag><tag>操作系统</tag></tags><content type="html"> 🥽 系统面经
本文中主要介绍一些操作系统相关的面试题，资料来源于
小林coding
，文章长期更新，先介绍了CPU和内存的相关知识，在这个基础上引入了运行在cpu和内存中的进程的相关知识，之后针对页面，进程，磁盘的调度算法做了研究，最后就是一些文件系统，输入输出设备的相关知识，相当于围绕了一个计算机来介绍内部的相关知识
冯诺依曼模型
运算器，控制器，存储器，输入输出设备
内存
基本存储单位为字节，1字节等于8位 内存地址从0开始编号，类似于数组，读写任何一个数据速度一样 中央处理器CPU
32位cpu一次最多可以处理四个字节（32位），能计算的最大整数就是2^32=4,294,967,296-1，算上0 64位cpu一次最多可以处理8个字节（64位），因为每个字节8位， 一个地址单元就有8bit，所以64位一次只能处理一个地址单元，32位两次才能处理一个 32位cpu能表示的最大值为2^32，也就是超过4GB的数据就无法表示了，64位机器只用了48位来表示虚拟内存的大小，也就是258T cpu内部的控制单元：负责控制cpu工作 逻辑运算单元负责运算 寄存器分为几种： 通用寄存器：存放需要运算的数据 程序计数器：存储下一条指令的地址 指令寄存器：保存正在执行的指令 总线
用于CPU和其他设备之间的通信
地址总线：指定CPU要操作的内存地址 数据总线：读写内存中的数据 控制总线：发送和接受各种信号，cpu收到信号之后进行响应，例如中断，设备复位 系统总线：CPU向内存中读数据时，地址先放到系统中线上 存储总线：I/O Bridge将系统总线上的数据放到存储总线上，便于向内存中读数据 线路位宽和CPU位宽
一个地址单元大小为8bit，也就是1Byte
电压高表示1，电压低表示0，所以可以通过操作电压传输数据
线路位宽表示地址总线能访问的内存地址范围大小，1条总线能表示0,1，两条总线能表示00,01,10,11个地址,32条总线能标识2^32=4G大小范围，一个地址单元大小为8bit（1字节），也就是能访问4GB数据
这里只是说能访问的范围是4GB，但是32位机器每次只能处理4B四字节，64位机器每次只能处理8B八字节
CPU位宽表示能处理的数据范围大小，CPU位宽最好不要小于线路位宽，否则读取到了这么大的数据cpu也无法一次处理，并且32位CPU只能处理4GB范围内的 …</content></entry><entry><title>生成特殊数字的最少操作</title><url>/post/%E7%94%9F%E6%88%90%E7%89%B9%E6%AE%8A%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   😃 2844.生成特殊数字的最少操作
给你一个下标从 0 开始的字符串 num ，表示一个非负整数。
在一次操作中，您可以选择 num 的任意一位数字并将其删除。请注意，如果你删除 num 中的所有数字，则 num 变为 0。
返回最少需要多少次操作可以使 num 变成特殊数字。
如果整数 x 能被 25 整除，则该整数 x 被认为是特殊数字。
思路基本思想看到题目第一想法就是将当前数变成至少有两个5的因子相乘的数，这样才能使得被25整除，或者说要有25的因子才可以，满足要求的数有以下五种情况：
结尾为00 结尾为25 结尾为50 结尾为75 本身是0 对于第五种很好理解，第一种是该数有100这个因子，而100又是25的倍数，故以00结尾的数是25的倍数，其余三种举例来说，例如9925可拆成9900+25，而9900有100的因子，转换成情况1，而25本身就是25的倍数
问题转换成如何将数转换成以上5种情况步数最少，现在有两种解法：
解法一1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { int ans; public int minimumOperations(String num) { ans=num.length(); if(num.contains(&amp;#34;0&amp;#34;)) ans=ans-1; index(num,&amp;#34;25&amp;#34;); index(num,&amp;#34;50&amp;#34;); index(num,&amp;#34;75&amp;#34;); index(num,&amp;#34;00&amp;#34;); return ans; } //找到指定尾部元素的位置 public void index(String num,String tail){ int i=num.lastIndexOf(tail.charAt(1)); if(i&amp;lt;0) return; i=num.lastIndexOf(tail.charAt(0),i-1); if(i&amp;lt;0) return; ans=Math.min(ans,num.length()-i-2); } } 这种解法就是排除为0之后，硬求要达到结尾是以上四种情况的步数，取最小的，先求出最后一位在哪，有了最后一位再求倒 …  ]]></content></entry><entry><title>异步通信MQ</title><url>/post/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1mq/</url><categories><category>学习笔记</category></categories><tags><tag>微服务</tag><tag>RabbitMQ</tag></tags><content type="html"> 异步通信MQ
本节中我们学习异步通信的剩下知识，并且介绍RabbitMQ的一些更高级的特性，也就是解决利用RabbitMQ来进行收发消息的时候，如何解决遇到的一些问题
消息队列在使用过程中，面临着很多实际问题需要思考：
针对消息可靠性，MQ有多种解决办法，在第一节中介绍四种，针对延迟消息问题，在第二节中介绍一个死信交换机来实现延迟消息。针对消息堆积问题，第三节中提出了惰性队列，最后就是使用MQ集群来实现高可用
1.消息可靠性
消息从发送，到消费者接收，会经理多个过程：
其中的每一步都可能导致消息丢失，常见的丢失原因包括：
发送时丢失： 生产者发送的消息未送达exchange 消息到达exchange后未到达queue MQ宕机，queue将消息丢失 consumer接收到消息后未消费就宕机 上面这些问题都导致了消息的不可靠
针对这些问题，RabbitMQ分别给出了解决方案：
生产者确认机制 mq持久化 消费者确认机制 失败重试机制 下面我们就通过案例来演示每一个步骤。
1.1.生产者消息确认
确保消息到达MQ
RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。
返回结果有两种方式：
publisher-confirm，发送者确认，确认消息是否到交换机
消息成功投递到交换机，返回ack 消息未投递到交换机，返回nack 到这里就是成功了一半，还没有到队列，不算真正的成功
publisher-return，发送者回执，确认消息是否到队列
消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。 注意：
相当于生产者确认有三种状态：
成功到达交换机：publish-confirm ack 不成功到达交换机：publish-confirm nack 成功到达交换机但是不成功到达队列：publish-return ack 1.1.1.修改配置
首先，修改publisher服务中的application.yml文件，添加下面的内容：
1 2 3 4 5 6 spring: rabbitmq: publisher-confirm-type: correlated # 生产者确认类型 publisher-returns: …</content></entry><entry><title>多级缓存</title><url>/post/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</url><categories><category>学习笔记</category></categories><tags><tag>微服务</tag><tag>多级缓存</tag></tags><content type="html"> 🙌 多级缓存
本节中介绍一种亿级流量的缓存方案，也就是多级缓存，将请求分为多种类型，然后一步一步的进行缓存，经过多级缓存都没找到数据最终才会到达数据库中
1.什么是多级缓存
传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：
存在下面的问题：
• 请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈
• Redis缓存失效时，会对数据库产生冲击
多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：
浏览器访问静态资源时，优先读取浏览器本地缓存（第一级缓存），因为这些资源不会变化，所以可以缓存在浏览器减小请求时间 访问非静态资源（ajax查询数据）时，访问服务端 请求到达Nginx后，优先读取Nginx本地缓存（第二级缓存） 如果Nginx本地缓存未命中，则去直接查询Redis（第三级缓存，不经过Tomcat） 如果Redis查询未命中，则查询Tomcat 请求进入Tomcat后，优先查询JVM进程缓存（第四级缓存） 如果JVM进程缓存未命中，则查询数据库 在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个反向代理服务器，而是一个编写业务的Web服务器了。
因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图，Nginx集群中只关注将请求交给哪个缓存：
另外，我们的Tomcat服务将来也会部署为集群模式：
可见，多级缓存的关键有两个：
一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询
另一个就是在Tomcat中实现JVM进程缓存
其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。
2.JVM进程缓存
2.1.初识Caffeine
缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：
分布式缓存，例如Redis： 优点：存储容量更大、可靠性更好、可以在集群间共享 缺点：访问缓存有网络开销 场景：缓存数据量较大、可靠性要求较高、需要在集群间共享 进程本地缓存，例如HashMap、GuavaCache： 优点： …</content></entry><entry><title>分布式缓存Redis</title><url>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98redis/</url><categories><category>学习笔记</category></categories><tags><tag>微服务</tag><tag>Redis</tag></tags><content type="html"> 🤘 分布式缓存Redis
本节中主要介绍分布式缓存的相关知识，以Redis的相关知识为主进行介绍，主要包括redis持久化的两种方式，redis主从集群的数据同步，哨兵模式的作用以及分片集群的相关知识
1.Redis持久化
单机的Redis存在四大问题：
Redis有两种持久化方案：
RDB持久化 AOF持久化 1.1.RDB持久化
RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。
1.1.1.执行时机
RDB持久化在四种情况下会执行：
执行save命令 执行bgsave命令 Redis停机时 触发RDB条件时 1）save命令
执行下面的命令，可以立即执行一次RDB：
save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。
2）bgsave命令
下面的命令可以异步执行RDB：
命令执行后会开启独立进程在后台完成RDB，主进程可以持续处理用户请求，不受影响。
3）停机时
Redis停机时会自动执行一次save命令，实现RDB持久化。
4）触发RDB条件
Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：
1 2 3 4 # 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &amp;amp;#34;&amp;amp;#34; 则表示禁用RDB save 900 1 save 300 10 save 60 10000 RDB的其它配置也可以在redis.conf文件中设置：
1 2 3 4 5 6 7 8 # 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径目录 dir ./ 1.1.2.RDB原理
bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。
fork采用的是copy-on-write技术：
当主进程执行读操作时，访问共享内存； 当主进程执行写操作时，则会拷贝一份数据，执 …</content></entry><entry><title>网络面经</title><url>/post/%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</url><categories><category>面试</category></categories><tags><tag>面经</tag><tag>网络</tag></tags><content type="html"> 🕸 网络面经
本文中介绍了一些计算机网络中常见的面试题，也可以当做平时的学习笔记来使用，知识点参考小林coding的
图解系列
，文章长期更新
核心就是HTTP，TCP，UDP，IP四大协议
TCP/IP的层数
这是对OSI七层网络协议的简化，现在变成了四层，常用的也是四层
应用层：应用软件在这一层实现，不同应用需要通信时，就把数据交给下一层传输层
传输层：有两个协议TCP,UDP，加上端口号等信息，端口号负责区分消息到达另一台设备时，交给哪个端口对应的应用，可能进行分段，之后交给下一层
网络层：将从上层接收到的报文加上IP等信息，ip负责表示将消息交给哪一台主机，可能进行分片，交给下一层，ip地址分为网络号（找子网）和主机号（找子网中的主机）
网络接口层：在数据的ip头部加上MAC头部，封装成数据帧，这样就可以通过mac地址区分网络上的设备
输入网址到页面显示的过程
解析url：确定要访问哪个服务器和服务器中哪个文件
根据上述信息生成http请求（请求行，请求头。。）
根据要访问的服务器名在DNS服务器中查询其ip地址，这里涉及到域名解析
找到通信的目标ip之后，浏览器通过调用socket库来委托协议栈进行通信
由于http基于tcp进行通信，此时需要三次握手建立连接
建立连接也需要按照这个流程传输数据，是为了确保双方确实可以收发数据
建立连接之后将数据进行封装，加上TCP头部（端口和确认号），进一步交给ip层
ip层将数据封装成网络包，加上IP头部（源IP和目标IP），可能进行分片
之后对数据包加上MAC头部，主要加上MAC地址信息，包括发送方和接收方，此时需要用到ARP协议，填入MAC地址就知道数据先发送给哪个设备（从交换机哪个端口出去）
mac地址是用于两点传输的，在传输的过程中需要不断变化，不断获取
当客户端和服务器不在同一个子网中时，得到的MAC地址就是发送端所在子网的路由器MAC地址，在同一个子网时，此时MAC地址就是接收方的MAC地址，反正是直连设备的mac地址
数据封装好之后，经由发送方的网卡发送出去
发送方网卡发送的消息**先到达交换机**，判断该消息从交换机哪个端口转发出去，这根据交换机中缓存的mac地址与端口的映射表
找不到端口的映射，就发送给所有的端口（除了来时的端口）
从端口出来到达路由器，路由器判断这个包自己需不需要转发（MAC地址是 …</content></entry><entry><title>分布式事务Seata</title><url>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1seata/</url><categories><category>学习笔记</category></categories><tags><tag>微服务</tag><tag>分布式事务</tag><tag>Seata</tag></tags><content type="html"> 😝 分布式事务Seata
本节中我们介绍分布式事务的相关知识，并且引入Seata框架简单介绍其使用方法
1.分布式事务问题
1.1.本地事务
本地事务，也就是传统的单机事务。在传统数据库事务中，必须要满足四个原则：
1.2.分布式事务
分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：
跨数据源的分布式事务 跨服务的分布式事务 综合情况 在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。例如电商行业中比较常见的下单付款案例，包括下面几个行为：
创建新订单 扣减商品库存 从用户账户余额扣除金额 完成上面的操作需要访问三个不同的微服务和三个不同的数据库。
订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。
但是当我们把三件事情看做一个&amp;amp;quot;业务&amp;amp;quot;，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。
此时ACID难以满足，因为各个微服务之间需要进行调用，同步调用太影响效率，异步调用又会影响事务的ACID，这是分布式事务要解决的问题
2.理论基础
解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导。
2.1.CAP定理
1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。
Consistency（一致性） Availability（可用性） Partition tolerance （分区容错性） 它们的第一个字母分别是 C、A、P。
Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。
2.1.1.一致性
Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。
比如现在包含两个节点，其中的初始数据是一致的：
当我们修改其中一个节点的数据时，两者的数据产生了差异：
要想保住一致性，就必须实现node01 到 node02的数据 同步：
2.1.2.可用性
Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。
如图，有三个节点的集群，访问任何一个都可以及时得到响应：
当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用： …</content></entry><entry><title>微服务保护之Sentinel</title><url>/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4sentinel/</url><categories><category>学习笔记</category></categories><tags><tag>微服务</tag><tag>Sentinel</tag></tags><content type="html"> 😏 微服务保护之Sentinel
本节中介绍一种微服务保护的中间件技术Sentinel，他可以控制访问微服务的请求，包括流量控制，熔断降级以及请求授权等主要内容
1.初识Sentinel
1.1.雪崩问题及解决方案
1.1.1.雪崩问题
微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。
如图，如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响。
但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：
服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。
那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，就和多米诺骨牌一样，失败请求逐渐累积，集群中的大量微服务都会失效，此时雪崩就发生了：
1.1.2.超时处理
解决雪崩问题的常见方式有四种：
•超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待
但是这种模式必须等待超时之后才能知道某个服务不可访问
1.1.3.仓壁模式
方案2：仓壁模式
仓壁模式来源于船舱的设计：
船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。
于此类似，我们可以限定每个业务能使用的线程数，避免访问某一个业务导致耗尽整个tomcat的资源，因此也叫线程隔离。
这种方式的缺点就是还是会有部分线程被占用，并且服务A的工作效率取决于线程如何隔离，如果某个微服务请求量高但是分配的线程数少就会造成阻塞，另外一个微服务请求量低但是分配的线程数多就会造成资源浪费
1.1.4.断路器
断路器模式：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。
断路器会统计访问某个服务的请求数量，异常比例：
当发现访问服务D的请求异常比例过高时，认为服务D有导致雪崩的风险，会拦截访问服务D的一切请求，形成熔断：
1.1.5.限流
流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。
这种方式属于一种预防的机制，一个受到保护的服务接收到的请求有限，此时就不会因为流量激 …</content></entry><entry><title>Elasticsearch学习笔记3</title><url>/post/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url><categories><category>学习笔记</category></categories><tags><tag>微服务</tag><tag>elasticsearch</tag></tags><content type="html"><![CDATA[   🖐️ elasticsearch学习笔记3
本节中主要是延续前两节笔记中的内容继续介绍elasticsearch中的剩余内容，主要包含数据聚合，elasticsearch搜索时自动补全，elasticsearch集群之间的数据同步等知识
1.数据聚合**聚合（aggregations）**可以让我们极其方便的实现对数据的统计、分析、运算。例如计数、求和、平均值、最小值、最大值、分组等，并且可以适用于下面几种情况：
什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。
1.1.聚合的种类聚合常见的有三类：
**桶（Bucket）**聚合：用来对文档做分组
TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组 Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组 **度量（Metric）**聚合：用以计算一些值，比如：最大值、最小值、平均值等
Avg：求平均值 Max：求最大值 Min：求最小值 Stats：同时求max、min、avg、sum等 **管道（pipeline）**聚合：其它聚合的结果为基础做聚合
**注意：**参加聚合的字段必须是keyword、日期、数值、布尔类型
1.2.DSL实现聚合现在，我们要统计所有数据中每个酒店品牌旗下有多少酒店，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。
1.2.1.Bucket聚合语法语法如下：
1 2 3 4 5 6 7 8 9 10 11 12 GET /hotel/_search { &amp;#34;size&amp;#34;: 0, // 设置size为0，结果中不包含文档，只包含聚合结果 &amp;#34;aggs&amp;#34;: { // 定义聚合 &amp;#34;brandAgg&amp;#34;: { //给聚合起个名字 &amp;#34;terms&amp;#34;: { // 聚合的类型，按照品牌值聚合，所以选择term &amp;#34;field&amp;#34;: &amp;#34;brand&amp;#34;, // 参与聚合的字段 &amp;#34;size&amp;#34;: 20 // 希望获取的聚合结果数量 } } } } 结果如图： …  ]]></content></entry><entry><title>2537.统计好子数组的数目</title><url>/post/2537.%E7%BB%9F%E8%AE%A1%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 💫 2537.统计好子数组的数目
给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。
一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i &amp;amp;lt; j 且 arr[i] == arr[j] ，那么称它是一个 好 子数组。
子数组 是原数组中一段连续 非空 的元素序列。
思路
基本思想
统计符合条件的子数组，第一个想法就是使用滑动窗口，每一个滑动窗口都是一个子数组，然后统计滑动窗口中元素的出现次数，当前元素有n个，则可以形成n*(n-1)/2对，滑动窗口不断累加，一旦超过k就得到了一个好数组，此时就开始缩小滑动窗口
缩小时有一定的讲究，每删除一个左边的元素，该元素形成的对数可能就会减小，举例来说，当前元素原本有7个，可以形成21对，减小之后变成6个，只能形成15对，删除一个元素后元素的对数减小了6对，也就是当前元素减小之后，使用pairs-=count更新对数即可：
1 2 3 4 5 6 7 while(pairs&amp;amp;gt;=k){ ++res; //减小当前窗户左边元素的出现次数，并且减小其对数 count=map.get(nums[left]); map.put(nums[left++],--count); pairs-=count; } 需要注意的是，一旦当前滑动窗口中的对数小于k就停止缩小，此时滑动窗口左边有left个元素，不管滑动窗口是否符合条件，加上这left个元素一定是符合要求的好子数组，因为处于left-1位置的元素是最后一个被删除的元素（临界点），加上他就满足了要求，这是临界点
举例来说，当前需要k=2对，原始数组为[3,1,4,3,2,2,4,5]。窗口中的元素为[3,2,2,4]，被删除的元素为[3,1,4]，则left=3，不管后面怎么变化只要向左带上被删除的元素4就可以形成一个好子数组，而有三种可以带上4的情况:[4],[1,4],[3,1,4]，所以每次都需要+left
执行流程
开始滑动窗口，每次统计元素出现次数以及当前窗口形成的元素对数 滑动窗口一变化，带上左边的元素就可以形成好子数组，所以每次都要+left 当前滑动窗口元素对数大于k就开始缩小窗口 缩小时需要减小元素的出现次数和当前元素形成的对数 滑动完毕返回答案 代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 …</content></entry><entry><title>2063.所有子字符串中的元音</title><url>/post/2063.%E6%89%80%E6%9C%89%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🏁 2063.所有子字符串中的元音
给你一个字符串 word ，返回 word 的所有子字符串中 元音的总数 ，元音是指 &#39;a&#39;、&#39;e&#39;、&#39;i&#39;、&#39;o&#39; 和 &#39;u&#39; 。
子字符串 是字符串中一个连续（非空）的字符序列。
**注意：**由于对 word 长度的限制比较宽松，答案可能超过有符号 32 位整数的范围。计算时需当心。
思路基本思想本题有四种解题思路：
暴力：依次从word的每一个位置向后出发，然后统计每一个字符串中的元音个数累加，这种方式从word的每一个位置向后出发时有很多重复统计工作造成超时：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { //不停地从新的位置向后扩张，直到走到最后 //每获得一个子字符串就计算元音个数，然后累加到结果中 long res=0; public long countVowels(String word) { Set&amp;lt;Character&amp;gt; set=new HashSet&amp;lt;&amp;gt;(); set.add(&amp;#39;a&amp;#39;); set.add(&amp;#39;e&amp;#39;); set.add(&amp;#39;i&amp;#39;); set.add(&amp;#39;o&amp;#39;); set.add(&amp;#39;u&amp;#39;); char[] ch=word.toCharArray(); for(int i=0;i&amp;lt;ch.length;++i){ int num=0; for(int j=i;j&amp;lt;ch.length;++j){ //当前子字符串出现元音就开始统计 if(set.contains(ch[j])){ ++num; } //每个子字符串中的元音个数都需要累加到res中 res+=num; } } return res; } } 递归：依次从word的每一个位置向后递归，每递归到一个位置就统计当前位置形成的子字符串的元音个数，也会超时：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { //不停地从新的位置向后扩张，直到走到最后 //每获得一个子字符串就计 …  ]]></content></entry><entry><title>2976.转换字符串的最小成本I</title><url>/post/2976.%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%ACi/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🎠 2976.转换字符串的最小成本I
给你两个下标从 0 开始的字符串 source 和 target ，它们的长度均为 n 并且由 小写 英文字母组成。
另给你两个下标从 0 开始的字符数组 original 和 changed ，以及一个整数数组 cost ，其中 cost[i] 代表将字符 original[i] 更改为字符 changed[i] 的成本。
你从字符串 source 开始。在一次操作中，如果 存在 任意 下标 j 满足 cost[j] == z 、original[j] == x 以及 changed[j] == y 。你就可以选择字符串中的一个字符 x 并以 z 的成本将其更改为字符 y 。
返回将字符串 source 转换为字符串 target 所需的 最小 成本。如果不可能完成转换，则返回 -1
思路基本思想题目中说会给出一部分的字符之间的转换成本，根据这些字符的转换成本得到将source转换成target的最小成本，针对source和target的每个对应位置上的字符来说，都是求这两个字符之间的最小距离，因为字符之间转换的关系可以用一个图表示出来，图中的边就是转换成本，针对每一个要从source转换到target的字符，求出其最短路径即可，这就是图的最短路径问题
首先要建立一个邻接矩阵，并更新出当前字符的一步转换成本，也就是：
1 2 3 4 5 6 7 8 9 10 11 int[][] dist=new int[26][26]; for(int i=0;i&amp;lt;26;++i){ Arrays.fill(dist[i],Integer.MAX_VALUE/2); dist[i][i]=0; } //统计一步变化距离 for(int i=0;i&amp;lt;original.length;++i){ int begin=original[i]-&amp;#39;a&amp;#39;; int end=changed[i]-&amp;#39;a&amp;#39;; dist[begin][end]=Math.min(dist[begin][end],cost[i]); } 然后利用弗洛伊德算法求出任意两点之间的最短距离，之后遍历source和target的对应位置，需要转换就从更新完毕的邻接矩阵dist中找到最短距离即可
弗洛伊德更新代码为：
1 2 3 4 5 6 …  ]]></content></entry><entry><title>Redis面经</title><url>/post/redis%E9%9D%A2%E7%BB%8F/</url><categories><category>面试</category></categories><tags><tag>redis</tag><tag>面经</tag></tags><content type="html"> 🛅 redis面经
本文主要介绍一些redis的常见面试题，文章长期更新，面试答案参考小林coding的
图解系列
，第一章面试篇就是整体的面试题，后面几章是对面试篇中一些重点问题的补充
主要分为数据类型及实现原理，持久化，集群，缓存三大问题
redis定义
redis是一种基于内存的数据库，数据读写都在内存中完成，因此读写速度很快，常用于缓存，消息队列，分布式锁等场景
redis和Memcached的区别
都是基于内存的数据库，常用来作缓存 都有过期策略，性能都很高 区别
redis支持的数据类型更丰富，Memcached只支持key-value redis支持数据持久化，可以将内存中的数据同步到磁盘中 redis数据过期策略更加高级 redis功能更强大，生态系统更加完善 为什么使用redis做mysql的缓存
redis具备高性能：数据经过redis缓存在内存中，访问速度会大大加快 redis具备高并发：针对请求量来说，redis每秒能够处理的请求量是mysql的十倍以上 缓存之后可以缓解mysql的大部分压力 所以我们使用redis作缓存，这样mysql中的一部分数据缓存在了redis中，可以减小数据访问的时间，提高系统的运行效率
redis的数据类型
这里指的主要是redis中key-value中value的数据类型，key的数据类型始终是string
String：可存储字符串，整数，浮点数，常用来缓存对象（json，按字段分别缓存），计数（因为可存储整数），和一些共享信息（分布式锁） Hash：键值对形式的散列表，常用来缓存对象，一个哈希表就是一个对象的所有字段 List：链表，每个节点都是一个字符串，常用来做消息队列，要自己实现全局唯一消息id，判断消息是否被处理过，后期出现的stream专门用来做消息队列 Set：字符串的无序集合：常用来做集合之间的聚合计算（交并差） Zset：字符串的不允许重复的集合，每个元素带一个分数，常用来进行排序 随着版本更新，后面又新增了一些数据类型
BitMap：二进制状态的场景，签到，判断是否登录，底层使用String，布隆过滤器 HyperLoglog：统计基数（不重复元素的个数），但是不太精确，因为是基于概率的 GEO：存储地理位置信息，滴滴叫车 Stream：为消息队列而生，相比于List实现的消息队 …</content></entry><entry><title>Elasticsearch学习笔记2</title><url>/post/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url><categories><category>学习笔记</category></categories><tags><tag>微服务</tag><tag>elasticsearch</tag></tags><content type="html"><![CDATA[   🔍 elasticsearch学习笔记2
本节中主要介绍elasticsearch中的文档搜索功能，这也是它最重要的一个知识点
1.DSL查询文档elasticsearch的查询依然是基于JSON风格的DSL来实现的。
1.1.DSL查询分类Elasticsearch提供了基于JSON的DSL（Domain Specific Language）来定义查询。常见的查询类型包括：
查询所有：查询出所有数据，一般测试用。例如：match_all
全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：
match_query multi_match_query 精确查询：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：
ids range term 地理（geo）查询：根据经纬度查询。例如：
geo_distance geo_bounding_box 复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：
bool function_score 查询的语法基本一致：
1 2 3 4 5 6 7 8 GET /indexName/_search { &amp;#34;query&amp;#34;: { &amp;#34;查询类型&amp;#34;: { &amp;#34;查询条件&amp;#34;: &amp;#34;条件值&amp;#34; } } } 我们以查询所有为例，其中：
查询类型为match_all 没有查询条件，所以match_all中的花括号没有值 1 2 3 4 5 6 7 8 // 查询所有 GET /indexName/_search { &amp;#34;query&amp;#34;: { &amp;#34;match_all&amp;#34;: { } } } 其它查询无非就是查询类型、查询条件的变化。
1.2.全文检索查询1.2.1.使用场景全文检索查询的基本流程如下：
对用户搜索的内容做分词，得到词条 根据词条去倒排索引库中匹配，得到文档id 根据文档id找到文档，返回给用户 相当于用户输入一个内容，elasticsearch将其进行分词，然后根据词条去查询匹配，根据所有查询匹配到的id找到文档返回给用户
比较常用的场景包括：
商城的输入框搜索 百度输入框搜索 例如京东：
因为是拿着词条去匹配，因此参与搜 …  ]]></content></entry><entry><title>875.爱吃香蕉的珂珂</title><url>/post/875.%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🍌 875.爱吃香蕉的珂珂
珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。
珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。
珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。
思路
基本思想
开始第一想法是从速度1开始，每次求出按照这个速度吃掉香蕉需要多少时间，当事件刚好小于等于警卫回来的时间h时就可以得到最终的结果，相当于是一个暴力算法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { //将h均匀分给piles中的每个数，然后再确定一个k public int minEatingSpeed(int[] piles, int h) { int k=1; while(true){ //针对每一个k，看花费多少个小时能吃完 //当花费的时间小于h时就可以返回 long time=0; for(int i=0;i&amp;amp;lt;piles.length;++i){ time+=(piles[i]+k-1)/k; } if(time&amp;amp;lt;=h) break; ++k; } return k; } } 这种操作方式大部分情况是可行的，但是一旦香蕉数过多，就会导致超时，主要是因为k的求解是逐步进行的，需要从最小的1逐步增长，这导致了时间过长，于是想到了二分查找的方式
二分查找需要找到k的上界和下界，下界就是吃香蕉的最小速度，也就是1，上界就是一小时最多能吃多少香蕉，由于规定一次只能吃一堆，所以最大速度就看哪一堆香蕉最多，这就是最大速度
找到边界之后，就看是二分查找，计算出按照当前时间需要耗费多少时间能吃完香蕉，当耗费的时间大于警卫回来的时间时，此时说明吃慢了，需要提高速度，也就是目标速度在[mid+1,fast]中，当耗费时间小于等于警卫回来的时间时，说明此时的速度就吃的不慢，目标速度在[slow,mid]中
为什么不是[slow,mid-1]呢，这是因为我们要找到一个刚好吃完的速度，因为这个mid的速度此时吃的不慢，说明可能符合要 …</content></entry><entry><title>Elasticsearch学习笔记1</title><url>/post/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url><categories><category>学习笔记</category></categories><tags><tag>elasticsearch</tag><tag>微服务</tag></tags><content type="html"> 🔍 elasticsearch学习笔记1
本节中主要介绍了elasticsearch中的一些基本概念，并于mysql中的一些概念进行了对比，分析了elasticsearch与mysql适用的场景。并且介绍了elasticsearch中索引库和文档的DSL语句的操作语法，主要是索引库的增删改查以及文档的增删改，关于文档如何进行查询，在下一节中介绍。之后还使用了java封装的RestAPI来使用java代码操作索引库和文档
1.初识elasticsearch
1.1.了解ES
1.1.1.elasticsearch的作用
elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容
例如：
在GitHub搜索代码
在电商网站搜索商品
在百度搜索答案
在打车软件搜索附近的车
1.1.2.ELK技术栈
elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：
而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。
1.1.3.elasticsearch和lucene
elasticsearch底层是基于lucene来实现的。
Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：https://lucene.apache.org/ 。
elasticsearch的发展历史：
2004年Shay Banon基于Lucene开发了Compass 2010年Shay Banon 重写了Compass，取名为Elasticsearch。 1.1.4.为什么不是其他搜索技术？
目前比较知名的搜索引擎技术排名：
虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头：
1.1.5.总结
什么是elasticsearch？
一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能 什么是elastic stack（ELK）？
是以elasticsearch为核心的技术栈，包 …</content></entry><entry><title>Mysql面经</title><url>/post/mysql%E9%9D%A2%E7%BB%8F/</url><categories><category>面试</category></categories><tags><tag>mysql</tag><tag>面经</tag></tags><content type="html"> 📈 mysql面经
本文中主要介绍一些mysql的面试笔记，文章持续更新，面试答案参小林coding的
图解系列
，主要围绕一条SQL的执行过程穿插了很多面试题，并且按照章节进行介绍
主要分为索引，锁，事务，三大日志四个核心部分
sql语句执行的流程
连接器：建立连接（TCP），之后所有的查询操作都会先判断当前用户的权限，长时间（28800）不用的连接会被释放，并且连接数不能超过151
查询缓存：select会查询缓存，看是否曾经执行过，对于更新频繁的表，缓存基本无用
解析SQL：主要是词法分析和语法分析，分析成功就会得到一个SQL语法树
执行SQL：
预处理SQL：替换*，判断字段和表是否存在
优化SQL：使得SQL执行的效率变高，例如存在主键索引（id）和普通索引（其余字段加索引）时，会判断使用哪个索引的效率更高，需要的列就是id，此时利用二级索引更快，因为二级索引的叶子结点保存的就是id
执行SQL：与存储引擎交互查询数据
主键索引查询：直接利用主键索引查询
全表扫描：全表扫描一遍
索引下推：将索引的判断工作交给存储引擎端，减少回表操作，这里涉及到一个联合索引的操作，由于存在最左匹配原则，当出现范围查询时，联合索引的范围查询可以使用索引，但是剩下的字段无法使用索引（因为局部无序），所以剩下的字段需要进行回表，将存储引擎查询到的数据在服务端再进行筛选，索引下推可以使得这个筛选工作在存储引擎端完成，从而减小回表操作，提高效率，举例：
select * from t_table where a &amp;amp;gt; 1 and b = 2，联合索引（a, b）
此时联合索引会先按照a排序，然后存储引擎找到所有a&amp;amp;gt;1的数据的id，在这些数据里，b没有进行排序，所以联合索引失效，这些数据需要进行回表进一步筛选，索引下推可以将筛选的工作交给存储引擎端，减小数据传输的时间
mysql一行记录如何存储
数据存储由行，页，区，段组成，每一行数据分为额外信息和真实数据，额外信息包含变长字段的长度以及NULL值列表（二者可能不存在），真实数据包含三个隐藏字段（隐藏自增id，事务id，上一个版本指针）以及真实值
一旦建立数据库中的一张表，那么就会在/var/lib/mysql/ 中建立一个对应的数据库，内部新增三个文件：
1 2 3 db.opt 表名.frm 表名.ibd …</content></entry><entry><title>Spring面经</title><url>/post/spring%E9%9D%A2%E7%BB%8F/</url><categories><category>面试</category></categories><tags><tag>spring</tag><tag>面经</tag></tags><content type="html"> 🌸 spring面经
本文总结一些常见的spring面试题并自己做出总结，文章持续更新
spring是什么
spring通常指的是spring framework，是一个IOC和AOP的容器框架，从广义来说指的是一个生态，可以构建java应用所需要的基础框架
spring的优缺点
spring有许多功能，每个功能都带来了一些优点
IOC：对程序进行解耦，将对象交给spring进行控制管理 AOP：程序扩展（不修改原代码）起来更加方便，减少重复代码 事务：支持声明式事务管理，不用进行繁杂的事务配置 在框架中封装了各种直接使用的功能，JDBCTemplate，RestTemplate等 由于有上面这些丰富的功能，导致spring入门比较困难，并且想深入挖掘很困难
IOC容器是什么
IOC既控制反转，可以将对象的控制权集中交给IOC容器来管理，将程序进行解耦，被管理的对象称为bean，整个bean的生命周期都由这个容器来管理，包括bean的创建，bean的依赖注入等
ioc的实现机制
工厂设计模式（getBean获取bean对象时）+反射（bean的实例化时利用传递的类名实例化）
IOC和DI的区别
IOC是控制反转，控制了对象的创建和使用，这是一种设计思想。DI是依赖注入，当我们需要一个bean对象时，必须要spring注入才能使用，或者说将一个对象所依赖的的其他对象自动注入到这个对象中，也就是DI是IOC的一种实现方式，二者并不能等同
依赖注入的方式
属性注入，也就是使用@AutoWired或者@Resource直接注入属性对象， 前者先byType后byName，一个类型存在多个bean就需要使用@quelifier或者@primary指定先注入谁，并且autowired还可以作用在构造方法上用来推断构造函数 后者先byName再byType，指定name之后只按照name注入 setter注入，给每个属性编写对应的setter方法，符合单一职责，但是在setter方法中可以随时修改，因为setter可能被调用多次 构造器注入，只可能被修改一次，可以注入final修饰的对象，在不支持ioc的框架中也可以使用 spring中如何推断构造函数
只有一个就只能用这个，根据形参列表区IOC容器中找到对应的bean，有一个包含两种情况：
只有一个默认的无参 有一个有参构造函 …</content></entry><entry><title>1887.使数组元素相等的减少操作次数</title><url>/post/1887.%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E5%87%8F%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   😃 1887.使数组元素相等的减少操作次数
给你一个整数数组 nums ，你的目标是令 nums 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：
找出 nums 中的 最大 值。记这个值为 largest 并取其下标 i （下标从 0 开始计数）。如果有多个元素都是最大值，则取最小的 i 。 找出 nums 中的 下一个最大 值，这个值 严格小于 largest ，记为 nextLargest 。 将 nums[i] 减少到 nextLargest 。 返回使 nums 中的所有元素相等的操作次数。
思路基本思想读完题目之后，发现数组的变化过程是一个分阶梯一步一步累加得到的，对于数组整体而言，是从最大值变为倒数第二的最大值，然后从倒数第二变成倒数第三，当所有的数都变成最小的数时就可以得到最终的答案，在这个变化过程中，有的数经历了几个阶梯的变化，但是这是有规律的
最大值变为最小值取决于数组中有多少类型的数字，如果有五种不同类型的数字，那么最大值变为最小值需要经历四次变化，对于倒数第二大的元素来说，需要经历三次变化，按照这种规律，我们只需要统计出每种元素的个数，然后将这些元素进行排序，此时就知道每种元素变为最小的元素需要经历几步，然后乘以当前元素的个数即可
核心就是对元素分类并排序，然后就可以知道每种元素需要多少次才能变化到最小值，将这些变化次数累加即可
执行流程使用哈希表统计每种元素的个数 将所有的元素进行排序，从而知道每种元素变为最小值需要经历几步 统计变化到最小值的变化次数结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { //统计有几种阶层，每个阶层有几个元素，直接用公式计算 public int reductionOperations(int[] nums) { Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); //统计每种元素出现的次数 for(int i=0;i&lt;nums.length;++i){ int count=map.getOrDefault(nums[i],0); map.put(nums[i],count+1); } //根据元素大小对级别进行排序 Integer[] arr=map.keySet().toArray(new Integer[0]); Arrays.sort(arr); int res=0; for(int i=arr.length-1;i&gt;0;--i){ res+=map.get(arr[i])*i; } return res; } } 总结总的来说就是要总结解题过程中的规律，发现变化过程分阶梯，然后利用哈希表统计并计算每种元素变化到最小值需要几步，累加所有的变化步数即可
  ]]></content></entry><entry><title>2750.将数组划分成若干好子数组的方式</title><url>/post/2750.%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%E6%88%90%E8%8B%A5%E5%B9%B2%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🧑‍🧒 2750.将数组划分成若干好子数组的方式
给你一个二元数组 nums 。
如果数组中的某个子数组 恰好 只存在 一 个值为 1 的元素，则认为该子数组是一个 好子数组 。
请你统计将数组 nums 划分成若干 好子数组 的方法数，并以整数形式返回。由于数字可能很大，返回其对 109 + 7 取余 之后的结果。
子数组是数组中的一个连续 非空 元素序列。
思路基本思想看到本题的第一思路就是类似于字符串的分割一样，使用回溯法进行分割，只有当前子数组只有一个1时才能继续向下分割，就这样一直向下，然后分割完成就可以形成一个结果，统计所有的合法划分结果即可，代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { //要将当前数组划分成很多段 //考虑使用回溯法，当前子数组符合要求才继续划分 int res=0; public int numberOfGoodSubarraySplits(int[] nums) { backtrack(nums,0); return res; } private void backtrack(int[] nums,int index){ if(index==nums.length){ res=(res+1)%1000000007; } //开始划分，当前子数组没有1就继续，只存在一个1就向下，多余一个1就break int count=0;//统计当前层中1的个数 for(int i=index;i&lt;nums.length;++i){ if(nums[i]==1){ ++count; } //break if(count&gt;1){ break; } //向下 if(count==1){ backtrack(nums,i+1); } } } } 但是这样会造成超时，因为数组的长度过长，所以想到用数学的办法解决
当前一个数组可以划分的前提是划分的两部分各存在一个0，此时划分方案数取决于两个1之间有多少个0，从不同的0划分就可以形成不同的划分方案，这里的1就是划分边界，不同的边界与下一个边界之间的组合使用乘法法则来统计出所有的方案数，所以核心就是：找到所有的1，每两个1之间有多少0就有多少方案数，将这些方案数相乘即可
执行流程从头到尾找到没两个1之间的0的个数，可以得到当前的划分方案数 将所有的划分方案数相乘即可得到所有的划分方案数 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numberOfGoodSubarraySplits(int[] nums) { int res=1; //这个记录上一个1存在的位置 int index=-1; for(int i=0;i&lt;nums.length;++i){ if(nums[i]==0) continue; //到这里就是找到了1，并且这个1并不是开头第一个1 if(index&gt;=0) res=(res*(i-index))%1000000007; //记录当前1的位置 index=i; } return res; } } 总结核心就是从回溯法转换到数学求解，每个片段可以有多少种划分方案取决于当前两个1之间的0的个数
  ]]></content></entry><entry><title>1252.奇数值单元格的数目</title><url>/post/1252.%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 😀 1252.奇数值单元格的数目
给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。
另有一个二维索引数组 indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。
对 indices[i] 所指向的每个位置，应同时执行下述增量操作：
ri 行上的所有单元格，加 1 。 ci 列上的所有单元格，加 1 。 给你 m、n 和 indices 。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 奇数值单元格 的数目。
思路
基本思想
看到题的第一想法就是直接模拟更新过程，更新完毕之后统计所有的奇数单元格即可，但是这种方法过于暴力，自己观察之后发现，一个位置要出现奇数值，综合来看，只能是当前位置所处的行列被更新的次数不相等，如果当前位置行列更新次数相等，相加起来一定是偶数，就不符合条件
所以我们可以统计所有的indices，如果当前的indices[i]让当前的行列更新次数变成偶数，那么奇数行和奇数列的数量就减小，如果当前的indices[i]让当前的行列更新次数变成奇数，那么奇数行和奇数列的数量就增大，遍历完所有的indices之后，就得到了奇数行和奇数列的个数
针对一个奇数行来说，当前列存在多少偶数列，就可以得到多少个奇数单元格，针对一个偶数行来说，当前列存在多少奇数列，就可以得到多少个奇数单元格，也就是奇数单元格的数量为： $$ res=(奇数行)(偶数列)+(偶数行)(奇数列) $$
核心就是当前位置要出现奇数单元格，需要行列更新次数不一样
执行流程
定义两个数组，记录当前行列是不是更新了奇数次，便于统计奇数个数 当前indices[i]更新过后，当前行列是不是更新了奇数次，直接在原有技术上取反即可 如果当前是更新了奇数次，那么奇数个数+1,否则奇数个数-1 统计完成之后按照上述公式得到结果 代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { //暴力法：先执行，再统计 // 能否边更新边统计:当前位置是奇数（行列累加数不相等即可） public int oddCells(int m, int n, int[][] indices) { //定义两个数组存储当前行被累加奇数次还是偶数次 //初始状态下全都是flase boolean[] r=new boolean[m],c=new boolean[n]; int oddRow=0,oddColumn=0; for(int i=0;i&amp;lt;indices.length;++i){ //变成true说明当前行(列)被累加奇数次 //在原有基础上进行取反 oddRow+=(r[indices[i][0]]=!r[indices[i][0]])?1:-1; oddColumn+=(c[indices[i][1]]=!c[indices[i][1]])?1:-1; } //奇数行*偶数列+奇数列*偶数行 return oddRow*(n-oddColumn)+oddColumn*(m-oddRow); } } 总结
核心就是知道当前位置要出现奇数需要符合行列更新次数不一样的规律，更像是一个找规律的题目</content></entry><entry><title>780.到达终点</title><url>/post/780.%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🏁 780.到达终点
给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。
从点 (x, y) 可以转换到 (x, x+y) 或者 (x+y, y)。
思路基本思想看到题的第一想法就是像遍历二叉树一样遍历每一步所形成的新的坐标，从新的坐标出发，每次可以形成两个下一步的坐标，这就像是二叉树的遍历，只要遍历途中遇到了(tx,ty)那么就一路向上返回true，当某个坐标的x或者y大于tx或者ty时，这一个分支不再向下，这种思路是正确的，但是会超时，因为二叉树太过庞大，所形成的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { //模仿二叉树的遍历，但是会超时 public boolean reachingPoints(int sx, int sy, int tx, int ty) { return help(sx,sy,tx,ty); } private boolean help(int left,int right,int tx,int ty){ if(left==tx&amp;amp;&amp;amp;right==ty){ return true; } else if(left&amp;gt;tx||right&amp;gt;ty) return false; else{ int sum=left+right; return help(sum,right,tx,ty)||help(left,sum,tx,ty); } } } 超时之后使用了逆向思维，既然从(sx,sy)到(tx,ty)会超时，那么我们就从(tx,ty)到(sx,sy)，由于(tx,ty)的上一步要么是(sx+sy,sy)，要么是(sx,sx+sy)，相当于要么是x的位置加了一个sy，要么是y的位置加了一个sx，于是我们每次向前返回一步，不再盲目的进行搜索，每次计算出上一步到底是什么，计算的代码为：
1 2 3 4 5 if(tx&amp;gt;ty){ tx-=Math.max((tx-sx)/ty,1)*ty; }else{ ty-=Math.max((ty-sy)/tx,1)*tx; } 由于要找到上一步，所以需要回退，回退时需要注意，从上一 …  ]]></content></entry><entry><title>RabbitMQ学习笔记</title><url>/post/rabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url><categories><category>学习笔记</category></categories><tags><tag>RabbitMQ</tag><tag>微服务</tag></tags><content type="html"> 🐇RabbitMQ学习笔记
本文主要介绍一个异步通信的消息队列技术：RabbitMQ，在项目中使用这项技术可以使得微服务之间进行异步通信，提高项目的消息处理效率，在spring项目中还对这项技术进行了集成，从而可以更加方便的使用RabbitMQTemplate调用接口从而快速地收发消息
1.初识MQ
1.1.同步和异步通讯
微服务间通讯有同步和异步两种方式：
同步通讯：就像打电话，需要实时响应。
异步通讯：就像发邮件，不需要马上回复。
两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。项目中采用何种通信方式取决于业务的特性
1.1.1.同步通讯
我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：
总结：
同步调用的优点：
时效性较强，可以立即得到结果 同步调用的问题：
耦合度高 性能和吞吐能力下降 有额外的资源消耗 有级联失败问题 但是项目中大部分业务都是使用同步调用，因为这种方式时效性强并且更加简单，微服务之间交互直接同步调用就能直接获得结果
1.1.2.异步通讯
异步调用则可以避免上述问题：
我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。
在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。
订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。如果后期还有会员积分服务或者短信发送服务，这些都成为事件订阅者，订阅了支付服务，这有些类似于spring中的事件机制
为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。
Broker 是一个像数据总线一样的东西，或者说其是一个容器，暂时保存了所有的消息，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。
好处：
吞吐量提升：无需等待订阅者处理完成，响应更快速
故障隔离：服务没有直接调用，不存在级联失败问题
调用间没有阻塞，不会 …</content></entry><entry><title>526.优美的排列</title><url>/post/526.%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🏐 526.优美的排列
假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：
perm[i] 能够被 i 整除 i 能够被 perm[i] 整除 给你一个整数 n ，返回可以构造的 优美排列 的 数量 。
思路基本思想看到题目之后，第一想法就是按照回溯法求出所有的全排列，然后再判断每个全排列是否符合要求，也就是对于当前全排列来说，每个位置是否符合（下标从1开始）：
perm[i] 能够被 i 整除 i 能够被 perm[i] 整除 按照这种思路编写代码之后，会超时，超时的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { //使用回溯法找到所有的排列，然后再判断是否合法 //针对一个排列的所有数，依次判断是否符合任意一个条件即可 //解法可行，但是超时 List&amp;lt;Integer&amp;gt; path=new ArrayList&amp;lt;&amp;gt;(); int res=0; boolean[] visited; public int countArrangement(int n) { visited=new boolean[n]; help(n); return res; } //回溯法求排列 private void help(int n){ //形成了一个全排列，并且每个元素都符合条件 if(path.size()==n&amp;amp;&amp;amp;isValid(path)){ ++res; } //对于当前全排列来说，1-n的所有元素都会尝试一遍，这是超时的主要问题 //对于当前位置来说，只有部分元素符合条件，我们可以在回溯之前进行处理 for(int i=1;i&amp;lt;=n;++i){ //当前元素没访问，加入全排列中 if(!visited[i-1]){ visited[i-1]=true; path.add(i); help(n); //回溯 visited[i-1]=false; path.remove(path.size()-1); } } } …  ]]></content></entry><entry><title>1771.由子序列构造的最长回文串的长度</title><url>/post/1771.%E7%94%B1%E5%AD%90%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   📎 1771.由子序列构造的最长回文串的长度
给你两个字符串 word1 和 word2 ，请你按下述方法构造一个字符串：
从 word1 中选出某个 非空 子序列 subsequence1 。 从 word2 中选出某个 非空 子序列 subsequence2 。 连接两个子序列 subsequence1 + subsequence2 ，得到字符串。 返回可按上述方法构造的最长 回文串 的 长度 。如果无法构造回文串，返回 0 。
字符串 s 的一个 子序列 是通过从 s 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。
回文串 是正着读和反着读结果一致的字符串。
思路基本思想本题看完之后第一思想是将两个字符串拼接在一起形成一个字符串，这样就可以利用516.最长回文子序列的解法直接进行求解，但是按照这种方式求解之后，发现只能解决一部分问题，例如word1=”bcb“,word2=&amp;quot;a&amp;quot;时，最终求出来的结果是”bcb“而返回3，而不是返回0，因为word2中没有提供任何字符串。并且如果出现word1 = &amp;quot;aa&amp;quot;, word2 = &amp;quot;bb&amp;quot;时，会返回1并不会返回0，这是因为516.最长回文子序列的解法认为一个字符也是一个回文串，但是本题中不会
知道这两个题的差异之后，我们就要想办法在516.最长回文子序列的解法基础上剔除这些不符合条件的回文串，然后在剩下的回文串中找到一个最长的回文子序列，先给出516.最长回文子序列的解法的代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int longestPalindromeSubseq(String s) { char[] arr=s.toCharArray(); //初始化dp数组 int[][] dp=new int[s.length()][s.length()]; int res=1; //开始进行动态规划 for(int i=arr.length-1;i&amp;gt;=0;--i){ for(int j=i;j&amp;lt;arr.length;++j){ // …  ]]></content></entry><entry><title>Docker学习笔记</title><url>/post/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url><categories><category>学习笔记</category></categories><tags><tag>docker</tag><tag>微服务</tag></tags><content type="html"> 🐳 docker学习笔记
本节介绍微服务中关于docker的一些知识，主要包括docker的基本操作，然后就是如何使用DockerFile来自定义镜像，使用Docker-Compose来部署容器，最后构造自己的镜像仓库
1.初识Docker
1.1.什么是Docker
微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。
分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.1.应用部署的环境
大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：
依赖关系复杂，容易出现兼容性问题
开发、测试、生产环境有差异
例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。此时不知道到底要使用哪种依赖才能使得容器所有容器正常运行，给部署带来了极大的困难。
1.1.2.Docker解决依赖兼容问题
而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？
Docker为了解决依赖的兼容问题的，采用了两个手段：
将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包，容器运行时只依赖操作系统底层的内核，这样就可以做到容器之间运行隔离
将每个应用放到一个隔离容器去运行，避免互相干扰，但是互相之间可以通信
这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需在操作系统上安装这些，只依赖底层共有的操作系统内核，自然就不存在不同应用之间的兼容问题了。相当于将共性抽离，特性隔离，这样就可以做到应用之间互不影响，正常运行
虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？
1.1.3.Docker解决操作系统环境差异
要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：
结构包括：
计算机硬件：例如CPU、内存、磁盘等 系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。 系统应用：操作系统本身提供的应用、函数库。这些函数库是对 …</content></entry><entry><title>Springcloud学习笔记</title><url>/post/springcloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url><categories><category>学习笔记</category></categories><tags><tag>springcloud</tag><tag>微服务</tag></tags><content type="html"> 🦓 springcloud学习笔记
主要介绍springcloud集成的一些关于微服务的技术，例如eureka，ribbon，nacos，feign，gateway㩐技术，并初步介绍这些技术的使用方式
微服务
微服务的架构特征：
单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责 自治：团队独立、技术独立、数据独立，独立部署和交付 面向服务：服务提供统一标准的接口，与语言和技术无关 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题 微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。
因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 ，可以将项目中的服务进行拆分。
但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。
其中在Java领域最引人注目的就是SpringCloud提供的方案了。
SpringCloud
SpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。
SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。
其中常见的组件包括：
另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：
针对springcloud有以下几点总结
单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统
分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝
微服务：一种良好的分布式架构方案
①优点：拆分粒度更小、服务更独立、耦合度更低
②缺点：架构非常复杂，运维、监控、部署难度提高
SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件
服务拆分和远程调用
任何分布式架构都离不开服务的拆分，微服务也是一样，上面介绍了为什么引入微服务，这一节介绍引入微服务之后，服务是如何拆分的，以及拆分之后服务与服务之间通信怎么办的问题。
2.1.服务拆分原则
这里我总结了微服务拆分时的几个原则：
不同微服务，不要重复开发相同业务 微服务数据独立，不要访问其它微服务 …</content></entry><entry><title>1711.大餐计数</title><url>/post/1711.%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🍽 1711.大餐计数
大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。
你可以搭配 任意 两道餐品做一顿大餐。
给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 10000000007 取余。
注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。
思路基本思想按照读题之后的第一想法，首先就是求出所有的组合情况，然后依次判断每一个组合的和是不是2的幂并且最终的结果对 10000000007 取余即可，求出所有的组合数可以使用回溯法，判断和是不是2的幂可以使用位运算，所以最终的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { //找到所有的组合，然后判断其和是不是2的幂 //如何判断和是2的幂:二进制只有一位为1 int res=0; public int countPairs(int[] deliciousness) { help(deliciousness,0,0,-1); return res; } private void help(int[] deliciousness,int sum,int level,int index){ //已经得到一个组合，判断其是不是2的幂 if(level==2&amp;amp;&amp;amp;(sum&amp;amp;(sum-1))==0){ ++res; return; } //得到每一个组合 for(int i=index+1;i&amp;lt;deliciousness.length;++i){ sum+=deliciousness[i]; help(deliciousness,sum,level+1,i); sum-=deliciousness[i]; } } } 但是这种代码只能解决一部分案例，数字过多时会超时，主要体现在如果出现[1,3,3,3,3]这种情况时，每一个3都会与1进行配对从而逐步计算出结果，这是耗时的地方，所以需要改进计算组合的情况
为了计算出所有与当前数相加的和是2的幂的所有数，我们需要一个容器记录所有出现的数字，并且为了记录所有数字出现的次 …  ]]></content></entry><entry><title>802.找到最终的安全状态</title><url>/post/802.%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🦺 802.找到最终的安全状态
有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph表示， graph[i]是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i]中的每个节点都有一条边。
如果一个节点没有连出的有向边，则该节点是 终端节点 。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。
返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。
思路基本思想按照题目描述，要找到所有的安全节点，而终端节点一定是安全节点，然后从终端节点向前推，从某个节点出发，只能到达终端节点，这种的节点称为安全节点
然后在这个基础上继续向前推，从某个节点出发，只能够到达上面提到的安全节点（包括安全节点和终端节点）,这种节点一定是安全节点
按照上面的分析过程，一个节点出发的所有路径上遍历的所有节点，一定要都是安全节点，那么这个节点才算是安全节点，所以可以看成是一个从终端节点回退的过程，知道了终端节点，才知道一步到达终端节点的所有安全节点node1，之后才知道一步到达node1，再一步到达终端节点的所有node2。这样一步一步的回退，最终能够找到所有的安全节点
上面的分析过程，如果反过来，我们将所有的终端节点当起点，node1的上一步节点全是终端节点，node2的上一步节点全是node1。而终端节点的入度为0，删除所有的终端节点后，node1节点的入度又为0。按照这样的思想，也就是从终端节点出发，不断地进行拓扑排序，找到所有入度为0的节点，然后减小所有邻接节点的入度，再找到所有入度为零的节点。。。以此类推就能找到所有安全节点
前提是需要根据题目中给的图将其进行逆转，A-&amp;gt;B变成B-&amp;gt;A，并且需要统计所有节点的入度，便于进行拓扑排序
核心就是明白，反向之后，安全节点的上一步节点一定是安全节点，最终递推到终端节点，其入度为零，利用拓扑排序就可以找到所有的安全节点
执行流程图的反向，需要先建立一个List&amp;lt;List&amp;gt;，并且需要初始化n个List放到图中，因为后期需要按照索引获取并构造节点列表，代码为：
1 2 3 4 5 //由于节点出现的随机性，所以要先将内部的List构造好后期直接取 // …  ]]></content></entry><entry><title>迷路的机器人</title><url>/post/%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🤖 迷路的机器人
设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。
网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。
思路基本思想从起点到终点，如果是统计路径数或者最短的路径长度，可以使用动态规划，但是这里是找到一个合法的路径，而不是求数量或者长度，所以需要使用回溯，站在一个点上只能向右或者向下，所以在回溯时可以在回溯模板的基础上增加一些筛选条件，只要得到一个合法的路径就可以返回，所以回溯法的返回值需要做一个标记
按照上面描述形成的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { //使用回溯来做，每次到达当前位置，有两个位置可以走，一旦走到了最后的位置，就可以返回结果 //还是一旦有一个结果就直接返回 List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; path=new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res=new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; pathWithObstacles(int[][] obstacleGrid) { //起点有障碍物直接返回空数组 if(obstacleGrid[0][0]==1) return res; List&amp;lt;Integer&amp;gt; temp=new ArrayList&amp;lt;&amp;gt;(); temp.add(0); temp.add(0); path.add(temp); backtrack(obstacleGrid,0,0); //如果没有到达终点，res不会赋值，就是空数组 return res; } //回溯法统计所有的结果 private …  ]]></content></entry><entry><title>165.解密数字</title><url>/post/165.%E8%A7%A3%E5%AF%86%E6%95%B0%E5%AD%97/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🔓 165.解密数字
现有一串神秘的密文 ciphertext，经调查，密文的特点和规则如下：
密文由非负整数组成 数字 0-25 分别对应字母 a-z 请根据上述规则将密文 ciphertext 解密为字母，并返回共有多少种解密结果。
示例1 2 3 输入: ciphertext = 216612 输出: 6 解释: 216612 解密后有 6 种不同的形式，分别是 &amp;#34;cbggbc&amp;#34;，&amp;#34;vggbc&amp;#34;，&amp;#34;vggm&amp;#34;，&amp;#34;cbggm&amp;#34;，&amp;#34;cqggbc&amp;#34; 和 &amp;#34;cqggm&amp;#34; 思路基本思想按照示例给出的情况，可以理解为给出一个ciphertext，将其划分成不同的数字，只要当前这种划分方案符合划分中的每个数字都大于等于0且小于26，并且没有00,07这种类似的情况出现即可。第一想法就是将当前数字转换成字符串，然后使用字符串的划分方法
字符串的划分可以使用回溯法，这样就可以找到字符串的所有划分方案，在回溯进行向下递归时，增加一些判断条件就可以对划分方案进行筛选，基本的字符串划分方案是：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 //其中path是记录当前划分方案的，list是记录所有的分割方案的 public void backtrack(String str, int index) { if (index == str.length()) { list.add(new ArrayList&amp;lt;&amp;gt;(path)); return; } for (int i = index; i &amp;lt; str.length(); ++i) { String subStr = str.substring(index, i + 1); path.add(subStr); //在回溯向下递归时，可以增加一些筛选条件，从而使得划分方案变少 backtrack(str, i + 1, path, list); path.remove(subStr); } } 有了这种字符串的通用划分方案，在这个基础上进行筛选，只有每个数字都大于等于0且小于26，并且没有00,07这种类似的情况出现的方案才满足要求，所以每次划分之前需要先进行判断
执行流程进行字符串的划分，划分的过程 …  ]]></content></entry><entry><title>1144.递减元素使数组呈锯齿状</title><url>/post/1144.%E9%80%92%E5%87%8F%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%91%88%E9%94%AF%E9%BD%BF%E7%8A%B6/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🪑 1144.递减元素使数组呈锯齿状
给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。
如果符合下列情况之一，则数组 A 就是 锯齿数组：
每个偶数索引对应的元素都大于相邻的元素，即 A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ... 或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ... 返回将数组 nums 转换为锯齿数组所需的最小操作次数。
思路基本思想看完上面的要求，核心要求就是要么偶数索引当波峰，要么奇数索引当波峰。当偶数索引当波峰时，奇数索引的位置上的元素都应该小于相邻偶数索引位置上的元素，如果大的话，就需要一步一步的递减，为了求出最小操作次数，递减到只比相邻的偶数位置上的元素小一即可。如果奇数索引当波峰，那么还是类似的处理逻辑，此时让偶数索引上的元素都小于相邻的元素，并且刚好小一
执行流程假设奇数索引位置上的元素为波峰，此时遍历每个偶数索引位置上的元素，判断其是否小于相邻的元素，不小于时减小到刚好小于，统计遍历过程中减小了多少步 同理，假设偶数索引位置上的元素为波峰，此时遍历每个奇数索引位置上的元素，判断其是否小于相邻的元素，不小于时减小到刚好小于，统计遍历过程中减小了多少步 对比两趟相比下来哪个步数更少，返回结果 代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { //分别计算奇数位置为波峰或者偶数位置为波峰谁的步数小即可 //也就是要统计两遍，然后比较 public int movesToMakeZigzag(int[] nums) { int[] temp=Arrays.copyOf(nums,nums.length); int odd=0,even=0;//分别代表奇数和偶数为波峰的情况下需要变化多少步 //奇数为波峰 for(int i=0;i&lt;temp.length;i+=2){ if(i-1&gt;=0&amp;&amp;temp[i]&gt;=temp[i-1]){//左边 odd+=(temp[i]-temp[i-1]+1); temp[i]=temp[i-1]-1; } if(i+1&lt;temp.length&amp;&amp;temp[i]&gt;=temp[i+1]){//右边 odd+=(temp[i]-temp[i+1]+1); temp[i]=temp[i+1]-1; } } //偶数为波峰 for(int i=1;i&lt;nums.length;i+=2){ if(i-1&gt;=0&amp;&amp;nums[i]&gt;=nums[i-1]){//左边 even+=(nums[i]-nums[i-1]+1); nums[i]=nums[i-1]-1; } if(i+1&lt;nums.length&amp;&amp;nums[i]&gt;=nums[i+1]){//右边 even+=(nums[i]-nums[i+1]+1); nums[i]=nums[i+1]-1; } } return Math.min(odd,even); } } 总结要从问题中抓住核心，这道问题的核心就是谁当波峰，一旦有元素当波峰，那么相邻的元素必须不能比波峰高，相等都不行，为了求出最小的步数，不符合要求的元素在递减时递减到刚好小于即可
  ]]></content></entry><entry><title>120.三角形最小路径和</title><url>/post/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🔽 120.三角形最小路径和
给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
思路基本思想为了求出从第一行到最后一行的最小路径和，最简单的办法就是利用回溯求出所有符合要求的路径，然后从中找出最小的，当前行递归到下一行时，需要带上当前行的行标，下一行中只有行标相等或者行标只大于一个的数才能参与当前路径的构建，最终得到的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { //回溯法就能找到最终的结果 int res=Integer.MAX_VALUE; public int minimumTotal(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; triangle) { int[] dp=new int[triangle.size()]; backtrack(triangle,0,0,0); return res; } private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; triangle,int index,int sum,int pos){ //到达最后一层就可以尝试更新结果 if(index==triangle.size()){ res=Math.min(res,sum); return; } //没有到达最后一层，那么就从当前层开始回溯找到每一种组合 for(int i=0;i&amp;lt;triangle.get(index).size();++i){ //下一层的节点与上层节点相邻才能统计 if(i==pos||i==pos+1){ int num=triangle.get(index).get(i); backtrack(triangle,index+1,sum+num,i); } } } } 这种方法超时！！！
最开始理解的是每一行都选择一个最小的数，最后就可以得到最终的结果，但是事实上并不是这样，例如对 …  ]]></content></entry><entry><title>Spring相关知识</title><url>/post/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url><categories><category>面试</category></categories><tags><tag>spring</tag></tags><content type="html"> 🤔 spring相关知识
本文总结了spring框架中的一些核心知识，由于是一个不连续的学习过程，笔记中的内容也不是连续的，但是每一个知识点都值得分析，后期会对新的知识点进行补充
初始化前后的相关知识！！！
依赖注入的相关知识，Resource是先byName在byType，Autowired是先byType再byName，如果存在多个相同类型的bean，需要配合Qualifier一起使用
AOP的相关知识，对于代理对象本身，其属性都为空，但是内部的target，也就是真正被代理的对象本身的属性不为空。AOP要么是继承，要么是实现接口，代理对象内部都会有一个target属性保存了真正被代理的对象，然后有相同的方法，从而执行AOP的逻辑，不管是继承还是实现接口，目的都是为了得到被代理对象的结构，有了结构之后，可以在相同的结构中对被代理对象进行增强，外部无感知
代理对象本身的属性全部为空，但是代理对象内部的target保存了被代理对象，这个对象中的属性不为空
事务的执行流 程</content></entry><entry><title>事务相关知识</title><url>/post/%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url><categories><category>面试</category></categories><tags><tag>事务</tag></tags><content type="html"><![CDATA[   🤑 事务相关知识
本文中记录了spring中事务的相关知识点，可能总结的不够全面，后去如果遇到新的知识点会对文章进行补充，主要围绕事务的实现来展开讲解事务中的知识点
事务事务是逻辑上的一组操作，这些操作要么都执行，要么都不执行
实现事务需要基于数据库的回滚日志，事务在运行的过程中会记录日志，一旦出现异常回滚就会按照日志的操作恢复数据，有两种类型的事务：
编程式事务：需要自己手动编程控制事务的提交或者回滚 声明式事务：直接使用注解编程，由框架负责事务的控制，spring中提供一个待实现的接口，各个数据库的厂商自己实现自己的事务控制器 事务实现的原理就是使用了AOP，一旦使用了事务，那么就会给当前类创建一个代理对象，在方法执行前开启事务，如果正常结束就提交事务，没有正常结束就会回滚，期间需要注意事务管理器决定当前事务的传播行为，之后从数据库连接池中获取一个数据库的连接，执行完SQL之后，决定事务是否提交或者回滚，最终将数据库的连接归还给数据库连接池
事务的特性（ACID）原子性：事务就是最小的执行单位，要么全部完成，要么全部不完成 一致性：事务执行前后，数据保持一致，例如转账的总金额保持一致，出多少入多少 隔离性：事务之间的执行是隔离的 持久性：事务的操作被提交之后，影响是永久的 &amp;lt;img src=&amp;ldquo;https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202312111423205.png&#34;alt=&amp;ldquo;AID- style=&amp;ldquo;zoom: 33%;&amp;rdquo; &amp;gt;C&amp;rdquo; /&amp;gt;
事务的传播行为当事务方法被另一个事务方法调用时，必须指定事务应该如何传播
传播行为 说明 PROPAGATION_REQUIRED 当前不存在事务，那么就新建一个事务，否则就加入当前的事务，这是默认使用的事务传播行为。如果方法 A（PROPAGATION_REQUIRED）调用了方法 B（PROPAGATION_REQUIRED），方法 B 将加入到方法 A 的事务中。如果方法 B 抛出异常，则方法 A 和 B 都会回滚。 PROPAGATION_REQUIRES_NEW 当前存在事务，会将当前事务挂起，然后执行自己的事务，相当于事务之间互不影响，挂起当前事 …  ]]></content></entry><entry><title>373.查找和最小的k对数字</title><url>/post/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> ✨ 373.查找和最小的k对数字
给定两个以 非递减顺序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。
定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。
请找到和最小的 k 个数对 (u1,v1), (u2,v2) &amp;amp;hellip; (uk,vk) 。
思路
基本思想
为了求出所有符合要求的数对，最简单的办法就是先将所有的数对先求出来，然后再利用堆排序求出前k个数对，但是这样时间复杂度太高，主要的问题就是出在要将所有的数对都求出来，出现了很多的冗余，其实完全可以只求出部分数对，这里有一个前提，最小的数对的索引一定是[0,0]，最大的数对的索引一定是[nums1.length,nums2.length]，而当选择了第n个数对之后，下一个数对的索引是在当前数对的索引基础上递增得来的。假设当前数对的索引为[x,y]，那么下一个数对的候选索引一定是[x+1,y]和[x,y+1]。
有了索引递增的概念之后，为了求出前k个和最小的数对，我们直接将索引加入优先级队列中，比较规则是当前的索引对应的数对和小的元素在前面，大的元素在后面，这样每次取出来的都是当前最小的数对。在取出一个数对元素之后，需要加入下一个候选的数对，此时需要注意，不能直接加入，否则会出现重复元素
例如当前选择的索引为[1,2]，那么加入的候选数对为[1,3]和[2,2]，如果后面某一步选择了[2,1]，那么就会重复加入[2,2]这个数对，这是因为数对的索引是同步变化的，没有固定住其中一个，为了去掉重复索引，我们选择将其中一个索引固定住，也就是先将部分元素加入优先级队列
1 2 3 for(int i=0;i&amp;amp;lt;Math.min(nums1.length,k);++i){ queue.add(new int[]{i,0}); } 加入之后，第一个位置的索引固定为最大值，这样就不会同步变化，也就不会出现重复的索引了
核心就是利用优先级队列可以对元素排序的思想，每次从中取出当前和最小的数对，并将下一步的候选下标加入
类似的题目还有
786. 第 K 个最小的素数分数
执行流程
设计一个优先级队列，排序规则根据下标对应的数对和的大小升序排列 先将部分下标加入优先级队列中，目的是为了固定一个下标不变，防止两个下标同时变化导致出现重复元素 每次从优先级队列中 …</content></entry><entry><title>快速排序和堆排序</title><url>/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url><categories><category>学习笔记</category></categories><tags><tag>排序算法</tag></tags><content type="html"><![CDATA[   🍖 快速排序和堆排序
本文主要介绍数组中的快速排序和堆排序的执行流程，介绍这两个算法的原理，针对快速排序来说，就是每一趟确定一个元素的位置，针对堆排序来说，就是每一次调整都找到一个最值元素
快速排序原理快速排序的核心就是在于每一次的排序都要找到一个合适的位置，将当前元素插入这个位置之后，左边的元素不大于当前元素，右边的元素不小于当前元素，然后当前元素的位置固定了，左右两边的元素位置还需要继续划分，直到所有的元素都找到了自己的为止就完成了排序，由于每一次排序都是一半元素，所以时间复杂度为O(nlogn)
每一趟快速排序都找到一个元素的最终位置，类似于不停地填坑，小的元素往前放，大的元素向后放，然后填完了最后一个坑就放置标志元素，然后两边的元素继续应用快速排序的算法，直到序列无法划分，针对升序还是降序的问题，主要是看大于标志位的元素往前放还是往后放，大于标志位的元素往前放就是降序，往后放就是升序
核心就是每一趟找到一个标志元素的最终位置，大的往后放，小的往前放，并且序列长度大于1才能进行划分
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public static void quickSort(int[] nums, int left, int right) { int temp = nums[right]; int i = left, j = right; //当序列长度大于1才能划分 if (left &amp;lt; right) { while (i &amp;lt; j) { //从前面找一个大于temp的数放到后面 while (i &amp;lt; j &amp;amp;&amp;amp; nums[i] &amp;lt;= temp) ++i; if (i &amp;lt; j) //将当前这个大于temp的元素向后放，并且j移动 nums[j--] = nums[i]; while (i &amp;lt; j &amp;amp;&amp;amp; nums[j] &amp;gt; temp) --j; if (i &amp;lt; j) //将当前这个小于temp的元素向前方，并且i移动 nums[i++] = nums[j]; } //找到了当前标志元素的最终位置 nums[i] = temp; quickSort(nums, left, i - 1); …  ]]></content></entry><entry><title>918.环形子数组的最大和</title><url>/post/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   ➰️ 918.环形子数组的最大和
给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。
环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。
子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % n == k2 % n 。
思路基本思想环形数组的最大子数组和就是可以在数组到了末尾时回到开头继续进行累加，只要被累加的元素没有被重复使用即可，由此可以看出，环形数组的最大子数组和有两种情况：
正常的找到了最大子数组和，此时可以利用53.最大子数组和的解法求出最终的结果
最大子数组和在尾部和头部各有一部分，此时使用逆向思维，求出最小子数组和，这个最小子数组和也可以利用53.最大子数组和的思想求出来，然后用数组的整体和减去这一个最小子数组和即可
针对53.最大子数组和来说，利用的是滑动窗口求出最终的答案，对比加上当前元素以及当前元素本身谁大，如果加上当前元素之后结果变小，说明前缀是小于零的数，此时结果变成当前元素，如果加上当前元素之后结果变大，说明前缀是大于零的数，此时可以进行累加，核心的判断逻辑就是：
1 2 maxPre=Math.max(maxPre+nums[i],nums[i]); maxRes=Math.max(maxRes,maxPre); 在遍历的过程中不断更新最大值，利用这种思想，最小子数组和的求法就是将max换成min即可，最终需要注意的是，如果数组所有元素都是负数，那么求出的最大子数组和就是一个负数，此时最终返回的结果就是0和这个为负的最大子数组和，需要返回这个为负的最大子数组和
执行流程初始化最大辅助元素和最小辅助元素 从头开始遍历，更新最大元素和最小元素 遍历完成之后判断最大子数组和是否是负数，是的话代表数组中的元素全都是负数，此时直接返回 如果不是全都是负数，那么就返回情况一和情况二中的最大值 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { //分为两种情况： //1. 正常取值得到最大子数组和：直接计算即可 //2. 两端取值得到最大子数组和：计算最小子数组和，用总和减去最小子数组和 public int maxSubarraySumCircular(int[] nums) { int maxRes=nums[0],minRes=nums[0]; int maxPre=nums[0],minPre=nums[0]; int sum=nums[0]; for(int i=1;i&lt;nums.length;++i){ //加了大一些还是不加大一些 maxPre=Math.max(maxPre+nums[i],nums[i]); maxRes=Math.max(maxRes,maxPre); //加了小一些还是不加小一些 minPre=Math.min(minPre+nums[i],nums[i]); minRes=Math.min(minRes,minPre); sum+=nums[i]; } if(maxRes&lt;0) return maxRes; else{ return Math.max(maxRes,sum-minRes); } } } 总结主要将问题分成两种情况，然后针对第二种情况利用逆向思维求解，最大子数组和不好求，可以转而求最小子数组的和，只要出现了情况二，那么最小子数组和一定遍历一次就可以得到
  ]]></content></entry><entry><title>443.最小基因变化</title><url>/post/443.%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🧬 443.最小基因变化
基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 &#39;A&#39;、&#39;C&#39;、&#39;G&#39; 和 &#39;T&#39; 之一。
假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。
例如，&amp;quot;AACCGGTT&amp;quot; --&amp;gt; &amp;quot;AACCGGTA&amp;quot; 就是一次基因变化。 另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）
给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。
注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。
思路基本思想题目的要求需要从起始基因变化到终止基因，并且每一步变化的基因需要出现在基因库中，相当于从起点到终点，每一步都需要在一个集合中找一步走，并且下一步与当前步的基因序列只能查一个字符，这可以抽象成一个图的遍历问题，求起点到终点的最短路径问题，而求最短路径问题可以使用广度优先遍历，每次走一步，一旦找到终点就说明找到了最短路径
问题是如何进行遍历，针对基因的变化来说，从起点基因出发，变化不同的位置以及相同位置变化成不同元素都会形成下一步可能基因变化，也就是说一个基因变化一步之后，会形成多个基因，在所有的下一步基因中，针对每一个基因又会变化出很多下下一步的基因，这样一步一步的变化，当某一步变化之后变成了最终的基因，那么到达这一步的步长就是变化次数
转换成广度优先遍历就是先从起点出发，然后借鉴层次遍历的思想，每一层中都是同一步变化得到的基因，下一层是当前层变化一次所得到的所有基因，为了防止基因的重复并且防止基因变化过程中出现循环的问题，使用一个遍历数组记录已变化过的基因，这样就可以实现每次变化的都是新基因，只要结果基因在基因库中，就一定能变化得到
执行流程初始化队列，将起点加入队列中 针对每一层的的每一个基因，将其取出，代表进入下一层的变化，此时步长+1 从基因库中找到所有未遍历并且只与当前基因相差一个位置的基因序列 判断找到的基因序列是不是结果序列，不是的话就将其加入队列中，并且标记 …  ]]></content></entry><entry><title>909.蛇梯棋</title><url>/post/909.%E8%9B%87%E6%A2%AF%E6%A3%8B/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🐍 909.蛇梯棋
给你一个大小为 n x n 的整数矩阵 board ，方格按从 1 到 n2 编号，编号遵循 转行交替方式
，从左下角开始 （即，从 board[n - 1][0] 开始）每一行交替方向。
玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。
每一回合，玩家需要从当前方格 curr 开始出发，按下述要求前进：
选定目标方格next，目标方格的编号符合范围[curr + 1, min(curr + 6, n2)] 该选择模拟了掷 六面体骰子 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。 传送玩家：如果目标方格 next 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 next 。 当玩家到达编号 n2 的方格时，游戏结束。 r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。编号为 1 和 n2 的方格上没有蛇或梯子。
注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 不能 继续移动。
举个例子，假设棋盘是 [[-1,4],[-1,3]] ，第一次移动，玩家的目标方格是 2 。那么这个玩家将会顺着梯子到达方格 3 ，但 不能 顺着方格 3 上的梯子前往方格 4 。 返回达到编号为 n2 的方格所需的最少移动次数，如果不可能，则返回 -1。
示例
输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]] 输出：4 解释： 首先，从方格 1 [第 5 行，第 0 列] 开始。 先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。 然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。 接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 最后决定移动到方格 36 , 游戏结束。 可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。
思路
基本思想
蛇梯棋就是计算从1出发，最终 …</content></entry><entry><title>Small_spring17</title><url>/post/small_spring17/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🥩 small_spring17
在之前的章节中我们彻底完成了spring的核心功能，将整个bean声明周期中涉及到的核心方法都进行了完善，使得bean的创建可以更加灵活，在本节中我们进一步扩充现有spring的功能，将jdbc的功能整合到现有的spring项目中，使其具有查询数据库的功能，相关的代码我放到了
仓库
中
原因
​ 在之前的章节中，我们实现了bean生命周期中的核心功能，包括bean的定义和注册，属性填充，类型转换，加载配置文件，实现应用上下文，添加修改、初始化和销毁模块，aware回调注入容器资源，事件机制，AOP创建代理对象并给代理对象进行属性填充，bean的自动扫描注册，注解配置bean，解决循环依赖等核心模块。经历这些模块的扩充，现有的spring框架已经初具规模，在本节中我们进一步引入jdbc的模块，使得spring框架中可以实现sql语句的查询，但是这种引入并不是从头开始，而是利用一些现有的工具类，控制sql语句的执行以及结果的封装从而模拟jdbc中sql语句的执行
思路
为了实现在现有的spring项目中加入jdbc的功能，添加了22个类，下面先对对这22个类进行分类，然后再分析类与类之间的关系：
对查询结果的封装一共包含五个类：
其中上面部分的RowMapper的两个实现类分别实现了对单列数据的封装处理以及对多列数据的封装处理，SingleColumnRowMapper内部在一行数据中拿到想要的一列数据之后进行类型转换返回。ColumnMapRowMapper内部将查询到的多列数据进行封装，每一列都封装成一个Map的键值对，最终将一行数据形成的Map返回
下面部分的ResultSetExtractor提供一个待实现的方法extractData，在实现类RowMapperResultSetExtractor中对其进行实现，主要是调用上面模块中的对于单行数据的处理方法，对结果集中的每一行都进行处理，最终封装成一个List返回
对数据库连接的处理一共有四个类：
ConnectionHolder类中保存SimpleConnectionHandler对象，内部保存数据库连接，而DataSourceUtils内部对数据库连接进行管理，包括获取，释放，关闭等操作。
创建PreparedStatement以及SQL语句的执行模块，一共包含三个类：
其 …</content></entry><entry><title>Small_spring16</title><url>/post/small_spring16/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍖 small_spring16
在之前的章节中，我们实现了spring中最重要的IOC和AOP的相关核心功能，并且利用三级缓存解决了循环依赖的问题，但是在属性填充的过程中，一直都是直接将字符串传递给bean中对应的属性，这会导致一些类型转换的问题，并且并不是所有属性都是string的类型，所以本节中我们将会解决bean属性填充中类型转换的问题，以applyPropertyValues方法为入口，相关代码我放到了
仓库
中
原因
​ 在给bean进行属性填充时，之前的操作都是填充字符串，而这不符合真实情况，真正的bean内部的属性多种多样，而配置时一般都配置的是String类型的变量，这就需要将String类型的属性值转换成目标类型的属性值，于是提出了类型转换模块，并在现有的模块中引入类型转换的内容，实现属性值的转换
思路
为了引入类型转换服务，一共经历了下面几步：
首先需要在xml文件中配置类型转化服务的相关模块，便于项目中能够感知到并且调用这些服务
在refresh方法中执行完所有的方法，对所有的bean进行实例化的时候，此时先判断当前项目中是否配置了类型转换的服务，这里是按照名称判断，代表后面的项目在使用类型转换服务时，对应的类型转换服务的beanName都是统一的名称
如果存在类型转换服务，那么就调用getBean方法创建并拿到这个类型转换服务的bean对象，如果这个bean对象内部还需要一些其他的属性，在创建过程中会一并填充
类型转换服务的属性填充完毕之后，触发了这个bean的初始化方法afterPropertiesSet，内部创建了一个DefaultConversionService类型转换服务的对象，并且将xml配置文件中配置的类型转换器保存到这个类型转换服务的converts容器中便于后期使用
之后将这个拿到的类型转换服务的对象保存到AbstractBeanFactory类中的conversionService中，后期属性填充时直接拿到这个类型转换服务中的类型转换器来进行类型转换，也就是拿到着之前保存到DefaultConversionService的converts中的类型转换器
执行其余的正常bean的创建过程，重点在属性填充的过程中，下面以husband的创建为例介绍如何进行类型的转换：
属性填充时拿到当前bean的所有需要填充的属性，如果当 …</content></entry><entry><title>15.三级缓存解决循环依赖</title><url>/post/15.%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🥬 15.三级缓存解决循环依赖
经过之前的编码，spring最核心的IOC和AOP的内容已经基本搭建完成，IOC章节中实现了bean的定义和注册，属性填充，读取配置文件，应用上下文，修改，初始化，销毁，aware感知，FactoryBean，事件监听。AOP章节中实现了对普通bean进行增强，自动扫描bean的注册，代理对象注入属性的内容。但是到目前为止，一个关键的问题还没有解决，那就是循环依赖，本节中就来解决这个问题，相关的代码我放到了
仓库
中
原因
​ 在bean的创建过程中，需要依赖一些属性，将这些属性填充完整才能完成bean的创建，而这些属性不只是普通属性，有可能在bean的创建过程中，还会依赖一些其他的bean，一旦这些被依赖的bean在创建过程中也依赖当前的bean，就会产生循环依赖的问题，如下图所示一共有三种循环依赖的情况：
但是三种循环依赖的本质上是一样的，都是在创建过程中依赖一个正在创建的bean，这样相互依赖导致bean无法创建成功，本节中来解决这些问题
思路
​ 为了解决循环依赖的问题，spring引入了三级缓存的概念，其中每一级缓存都各司其职从而解决了循环依赖的问题，下面就以第二种A和B创建过程中互相依赖的情况来描述三级缓存如何解决循环依赖：
创建A，此时会先创建一个空bean，然后将这个空bean保存到三级缓存中，不管后面是否能用到，之后进行属性填充 在属性填充的过程中，需要填充B，此时就会去一级缓存中找对应的B，发现B不存在，再去二级缓存中找，也没找到，再去三级缓存中找，还是没找到，此时新建B 创建B的时候也会先创建一个空bean，然后也将这个空bean保存到三级缓存中，之后进行属性填充 在属性填充的过程中，需要填充A的属性，此时就会去一级缓存中找对应的A，发现A不存在，再去二级缓存中找，也没找到，再去三级缓存中找，找到之前注册的空A，然后就判断这个A是否需要AOP，需要的话就创建一个代理对象，不需要的话就是普通对象，然后将这个对象放到二级缓存中并填充给B中A属性 B执行其他的属性填充，其他的工作，然后完成B的创建，此时B中的A还是一个空壳子 完成创建之后，将这个B保存到一级缓存中，然后将其从三级缓存中删除 之后继续A属性的填充，此时由于三级缓存中提前保存了未实例化完成的A，于是B可以创建完成，A也就可以用这个B进行属性填充，从而完成 …</content></entry><entry><title>14.给代理对象的属性设置值</title><url>/post/14.%E7%BB%99%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%80%BC/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍟 14.给代理对象的属性设置值
​ 上一节中使用注解的形式进行属性填充，但是填充的是普通的bean，也就是说代理对象的属性还都是null，这一节中我们就来解决这个问题，改变代理对象的创建时机，使得创建的bean代理对象内部的被代理对象的属性也不为空，但是并不是直接让代理对象本身的属性不为空，而是增加一个target，target的内部属性不为空，相关的代码我放到了
仓库
中
就是将代理对象的创建延后，然后最终被代理对象中的属性就可以填充完毕，这样代理对象执行时被自己的方法拦截器拦截之后，内部target就是属性填充过后的对象，代理对象自身的属性为空，但是target并不为空
原因
​ 上一节中我们实现了通过注解注入属性的功能，这一节中我们解决之前遗留的问题，主要是代理对象的创建还在bean的生命周期之外，并且创建的代理对象内部并没有填充过的属性。为了解决这个问题，我们将代理对象的创建时机移动到属性填充完毕之后且初始化之后的postProcessAfterInitialization方法中，核心类还是DefaultAdvisorAutoProxyCreator，只是创建代理对象的方法变成了postProcessAfterInitialization，经过这样的操作，代理对象的创建会在被代理对象属性填充之后，此时我们将代理对象中的target赋值为属性填充之后的被代理对象，这样就解决了代理对象中的属性没有值的问题，新的模块关系图如下：
思路
​ 将代理对象的创建延后之后，内部target保存了属性填充之后的被代理对象，在代理对象执行方法时，最终会到达JDK中的invoke方法或者Cglib中的intercept方法中，在这两个方法中执行方法匹配之后，如果匹配成功则会执行方法拦截器的invoke方法来执行通知方法进行增强，内部最终会调用target的原始方法执行，由于之前的target是填充的时候新建的一个空对象，所以出现了代理对象内部的属性为空的情况： 在本节中AOP的引入时机延后了，target填充的是已经参数填充过后的被代理有参对象，所以解决了之前的问题：
​ 总结来说核心步骤就是更改了方法拦截器中的target，使其存储属性填充过后的bean，为了实现这个目的就将创建代理对象的步骤延后，等待原始bean属性填充之后再创建，这样在代理对象的方法执行被拦截时，触 …</content></entry><entry><title>13.通过注解注入属性信息</title><url>/post/13.%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🌶️ 13.通过注解注入属性信息
​ 上一节中我们新增了一种bean的注册方式：包扫描+@Component注解。这种方式实现了只用指定扫描哪些包，程序自动将这些包下使用了@Component注解的bean注册到注册表中，同时bean还可以使用占位符的形式从属性文件中读取属性值来填充，但是这两部分是分开的，所以本节中在bean自动注册过程中引入了注解进行属性注入的模块，可以使用@Value注解可以注入普通属性，使用@Autowired和@Qualifier注解注入bean对象，相关的代码我放到了
仓库
中，并且注解属性注入的过程和包扫描的过程都加入了bean的生命周期
原因
​ 上节中实现了bean的自动扫描注册以及占位符形式注入bean的属性，但是这两部分是分开处理的，也就是说，bean的自动扫描注册的过程中没有引入任何属性，注册表存储的BeanDefinition中的属性列表PropertyValues部分没有在xml文件中配置的属性为空，所以本节中在bean的自动扫描注册的过程中引入了属性填充的功能，可以使用注解来进行属性填充，加入的模块关系如下图：
主要是在refresh函数中进行属性占位符的替换，然后在空bean创建之后，属性填充之前将属性列表构造好直接填充，然后在属性填充时只需要填充xml文件中配置的bean属性
思路
​ 为了在自动扫描注册之后引入注解属性填充的功能，肯定需要在bean的生命周期中进行改造，本节中为了引入注解属性填充的功能，需要在空bean创建之后，属性填充之前执行注解属性填充的功能，从而加载通过注解配置的属性来进行填充，之后再进行正常的xml配置文件中的属性填充。在xml文件读取的过程中，一旦配置了包扫描路径，此时就会执行bean的自动扫描注册，注册表中bean的BeanDefinition中的PropertyValues为空，之后再读取xml配置文件，如果此时还配置了bean，就会读取一份新的PropertyValues，将其存入注册表中时会更新注册表，从而此时的bean的BeanDefinition存储了两部分数据，第一部分是xml直接配置的属性，不为空，第二部分是使用注解配置的属性，为空。
​ 下面的步骤就是将执行占位符替换，如果xml配置属性的过程中存在占位符，就在这一步进行替换，然后就是空bean的创建，下一步就是注解属性 …</content></entry><entry><title>12.包扫描和属性占位符</title><url>/post/12.%E5%8C%85%E6%89%AB%E6%8F%8F%E5%92%8C%E5%B1%9E%E6%80%A7%E5%8D%A0%E4%BD%8D%E7%AC%A6/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🥒 12.包扫描和属性占位符
​ 本节实现了另外一种bean的配置方式，并且对于bean的属性来说，配置的时候还可以使用占位符的形式从属性文件中读取，做到一次配置，多次使用的目的，文章中涉及到的代码放到了
仓库
中，主要分为自动扫描bean的注册以及修改bean属性的配置方式。
原因
​ 经过之前的设计，spring中的IOC和AOP已经大致有了雏形，但其更像是一个初级的spring，因为bean的配置获取还处于最原始的编写xml配置文件的方式，并不能通过使用注解从而自动扫描，并且bean的属性配置如果需要变化，必须修改xml配置文件，所以针对这两点的不足，本节中做出了改进：
使用注解和包扫描的方式实现bean的自动注册，省去配置xml文件的繁琐步骤，包路径下所有使用了@Component注解的类都会被注册成功Bean，并且可以配置多个包扫描路径，路径之间使用“,”分割，之后就是扫描到所有的beanDefinition，然后将其放入beanDefinitionMap中，相当于不同的beanDefinition获取方式，不管是什么形式得到的beanDefinition都放入了beanDefinitionMap中，但是本节中只是引入了component-scan得到使用了@Component注解的bean的功能，还没有引入使用注解注入属性的功能，这个功能在下一节实现 使用占位符的方式将bean的属性配置更改到属性文件中，做到一次配置，多次使用，属性注入时直接从属性文件中读取需要的属性值，其实本质上在配置文件解析的过程中，是不管有没有占位符的，之后 思路
​ 在实现上面的两个目标之前，首先需要明确这些模块都是加入到了bean的生命周期中，从而可以增强spring中对于bean的管理。对于第一个目标来说，首先需要实现包扫描的功能，然后将包扫描到的bean都注册到注册表中，就替代了xml文件中一个一个配置的步骤，后面的依据注册表创建bean的步骤与原来一致，而包扫描的机制在xml配置文件读取的过程中。 一旦有包扫描路径的配置就会触发包扫描的机制从而完成自动注册，关于自动注册的流程如下：
对于红框来说，会针对每一个包扫描路径做一次，对于绿框来说，会针对每一个BeanDefinition做一次，最后将所有包扫描路径下的所有BeanDefinition都保存到注册表中，而自动注册 …</content></entry><entry><title>11.在bean的生命周期中加入AOP</title><url>/post/11.%E5%9C%A8bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%8A%A0%E5%85%A5aop/</url><categories><category>学习笔记</category></categories><tags><tag>源码</tag><tag>spring</tag></tags><content type="html"> 🥔 11.在bean的生命周期中加入AOP
​ 在上一节中我们将IOC的部分彻底补充完整，现在的简易spring框架已经有了bean定义，注册，属性填充依赖注入，xml文件解析，应用上下文，修改，初始化和销毁，感知注入容器资源，多种方式多种类型创建bean以及事件机制，本节中在原有项目的基础上增加了AOP的功能，将从AOP的实现到将AOP融入现有spring框架中进行介绍，相关的代码我放到了
仓库
中
原因
​ 当bean对象已经创建完成想要进行修改，或者想要在一些方法执行前后统一执行一些操作，同时又不想每一处都进行修改，想要在不破坏源代码的情况下进行增强，此时就可以用到动态代理的知识，依据一些匹配规则，将指定的代码进行增强，这就是AOP的设计思想
​ 本节中就引入了AOP的设计思想，根据匹配规则对方法的调用进行分类，符合匹配规则的方法会被增强，实现想要改变谁就可以改变谁的效果，具体的调用关系图如下：
思路
​ 为了实现动态代理，这里分为两部分介绍，第一部分介绍AOP的实现思路，第二部分将已经实现的AOP引入现有的spring框架中，增强现有的spring框架
第一部分
​ 实现AOP的核心思想就是对执行的bean对象的所有方法进行匹配，当方法匹配成功之后，就说明这个bean需要一个代理类，并且这个类中被匹配成功的方法就需要执行增强的逻辑，然后再执行原始方法，根据这个描述可以发现几个关键的地方：如何匹配，如何创建代理对象，如何执行增强的逻辑。下面依次对这几个关键点进行描述：
如何匹配：为了增强目标代码，AOP中提出了一个切入点表达式的知识，根据这个切入点表达式就可以判断当前bean是否会被增强，核心的功能被封装到了AspectJExpressionPointcut类中，主要是根据传递进来的类或者方法，根据切入点表达式判断当前类是否匹配以及当前方法是否匹配，根据是否匹配返回一个boolean值，根据这个boolean值决定是否增强 如何创建代理对象：根据上面的匹配结果决定是否创建代理对象，为了创建代理对象，有两种动态代理的技术，分别是JDK的动态代理和Cglib的动态代理，两种的主要区别是JDK是实现接口从而实现动态代理，最后会调用invoke方法执行增强，Cglib是继承从而实现动态代理，最后会调用intercept方法执行增强，两个方法内部都将当前方法与切入点表 …</content></entry><entry><title>76.最小覆盖子串</title><url>/post/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🏜️ 76.最小覆盖子串
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &amp;amp;quot;&amp;amp;quot; 。
思路
基本思想
题目的要求是从s中找到一个子串，子串中的字符可以涵盖s中的字符即可，这样的子串有可能有多个，前提是s的长度要大于等于t的长度，当子串有多个时，就找最小的
利用滑动窗口的思想，经过三步:
不停地扩大滑动窗口的大小（增加右边），直到滑动窗口中的字符子串可以包含t就先停下 不停地缩小滑动窗口的大小（增加左边），直到滑动窗口中的字符子串不能包含t就停下 在第二步的临界点时，也就是下一步就无法包含t时截取一个子串，这个子串就是当前窗口中的最小子串 继续扩大滑动窗口的大小找到下一个合法的窗口，在窗口中找到最小的合法子串 ​ 以上步骤中最核心的就是判断当前窗口中的字符子串是否包含t，这里我们预设一个need容器，初始化时key是t中的字符，value是t中每个字符出现的次数，need容器的含义是：当前还需要多少字符才能包含，当当前窗口中的字符子串包含t时，说明不再需要字符，也就是说每一个字符的值都是小于等于0的，在扩大窗口的过程中，每遍历到一个新字符，其需要的字符就会减小一个，字符出现的字数为负代表当前字符是多余的
​ 一旦当前窗口中的字符子串包含t，就需要缩小窗口找到最小的子串，这个临界点就是需要的字符总数为0，所以在遍历的过程中，遇到t中真正出现的字符并且不多于时（当前字符出现的次数大于0），此时这个字符被认为起到良性作用，需要的字符总数可以减一：
1 2 3 4 5 6 char c = s.charAt(index++); Integer count = need.get(c); count = count == null ? 0 : count; if (count &amp;amp;gt; 0) { needCount -= 1; } 例如，当前窗口中的字符为[A,O,D,C],t=“ABC”,那么对于C字符来说，就起到了良性作用，而对于O字符来说，起不到良性作用，get出来的字符出现次数永远小于等于0
当需要的字符总数等于0时，就可以缩小滑动窗口了，需要注意，扩大滑动窗口和缩小滑动窗口的操作不是互斥的，也就是说上一步扩大滑动窗口包含t之后，下一步可以紧接着缩小窗口
执行 …</content></entry><entry><title>10.引入事件机制</title><url>/post/10.%E5%BC%95%E5%85%A5%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍆 10.引入事件机制
​ 在上一节中，我们实现了多种类型多种方式创建bean多种类型的bean对象，本节中在此基础上，添加了事件功能，也就是当某些事件发生时，程序能够立马做出一些反应，就好像是一直在等着某些事件的发生。例如用户注册完成时，系统会给当前注册用户发送一些新人优惠福利。用户上线将自动给好友推送其上线消息等。本节中涉及到的代码我放到了
仓库
中
原因
​ 在之前的基础上，我们实现了关于IOC的很多功能，包括bean的定义，注册，获取，属性填充，加载配置文件，应用上下文，修改，初始化和销毁，Aware注入容器资源，以不同的方式创建不同种类的的bean对象等。但是现在还缺一个核心功能：事件。
​ 当某些事件发生时，系统希望做出一些反映，例如当应用上下文刷新完成时，系统希望打印出刷新的时间，某些事件发生时，用户希望做出一些自定义的反映。这些都需要spring中的事件机制来解决，而一般的事件解决分为三个步骤：
事件类应该继承 ApplicationEvent 事件的发布者应该注入ApplicationEventPublisher 事件监听者应该实现ApplicationListener ​ 本节中为了实现事件机制，将其分成了几步：
定义事件时继承ApplicationContextEvent类，其终极父类是EventObject 事件监听器实现了ApplicationListener接口，其终极父类是EventListener 事件发布者最终都是调用ApplicationEventPublisher接口中的publishEvent发布事件，为了能够调用publishEvent方法，需要实现这个接口，相当于注入 为了事件发布之后对应的监听器能够被触发，所有的监听器被保存到了一个广播器的容器中，并且事件发布时调用的publishEvent方法内部调用的是广播器的multicastEvent方法，内部根据事件类型匹配到保存的监听器，从而进行触发，这个广播器可以说衔接了事件的发布和监听器的触发，是一个核心组件，事件通过广播器发布之后，广播器内部根据事件的类型找到监听此事件类型的事件监听器，从而依次触发这些监听器的监听逻辑，看起来就像是事件一发布监听器就执行了监听逻辑，好像一直在监听，其实上是广播器通知监听器执行的。 ​ 经历以上几步，现有的项目中就加入了事件机制，新的项 …</content></entry><entry><title>9.原型bean和FactoryBean</title><url>/post/9.%E5%8E%9F%E5%9E%8Bbean%E5%92%8Cfactorybean/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍑 9.原型bean和FactoryBean
​ 在上一节中，我们实现了向bean中注入容器资源的功能，注入时不用关心配置文件中，需要什么就实现什么资源接口即可，之后资源的注入统一在初始化时执行。这使得bean的功能更强大也更灵活。但是至今为止，我们还只是创建单例的bean，没有实现如何创建原型模式的bean，并且bean的创建只能从配置文件中获取，一旦bean涉及到的配置太多，xml文件的编写就会异常复杂，是否可以使用更方便的java代码编写bean的配置并控制bean的实例化呢？所以本节中有两个目标：
创建多种模式的bean（单例或者原型） 以多种方式创建bean对象（xml或者java代码） ​ 本节涉及到的代码我放到了
仓库
中
原因
​ 为了创建多种类型的bean对象，我们将createBean的代码进一步改进，增加bean的注册信息，使其包含当前bean的模式，如果当前bean是单例模式，那么我们将其创建出来并保存到容器中方便下次直接调用，保持bean的单例性，如果当前bean是原型模式，那么每次我们都新建并不保存这个bean，这样可以保证每次都是新的bean对象，从而保证bean的原型性质，总结起来，为了实现第一个目标，做了两点改变：
修改bean的注册类BeanDefinition，使其拥有模式这个状态，标识当前bean是单例还是原型：
修改创建方式createBean的代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Override protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException { Object bean = null; try { bean = createBeanInstance(beanDefinition, beanName, args); // 给 Bean 填充属性 applyPropertyValues(beanName, bean, beanDefinition); // 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法 bean = …</content></entry><entry><title>8.使用回调机制注入资源</title><url>/post/8.%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E6%B3%A8%E5%85%A5%E8%B5%84%E6%BA%90/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍍 8.使用回调机制注入资源
在上一节中，我们在原有项目的基础上增加了初始化和销毁模块，并且实现方式有两种，分别是xml配置和实现接口，在初始化和销毁时可以进行资源的管理。本节中我们进一步扩展bean的功能，使其可以获取到spring中的一些容器资源，为了获得这些容器资源，需要一些成员变量接收，然后在生命周期中增加这些变量的注入代码，最后bean对象就可以使用这些容器资源了，具体的代码我放到了
仓库
中
原因
​ 之前几节中已经将项目的功能一步步的扩充了，这些功能分别是bean的定义，注册，属性填充，xml文件配置，应用上下文，修改，初始化和销毁。这些功能使得现在的简易spring框架更加完善，但是这些功能并没有增强bean本身的能力。当bean想要使用spring的一些容器资源，例如bean内部想要使用类加载器，想要获得应用上下文，从而知道总共有哪些bean等操作、现有的spring框架还无能为力，所以本节中重点解决的就是如何让bean本身能够获得spring的容器资源
​ 对于每一个bean来说，其想要使用的spring容器资源是不同的，所以不能统一的将所有的容器资源给每一个bean，而是转换思维，利用之前的思路，spring提供一个接口，然后谁实现这个接口，谁就有了对应的功能。这里也是一样，想要使用什么容器资源，就实现什么接口，接口内部提供一个set方法，这样就可以在合适的地方调用bean内部的这个set方法完成set注入，例如：
​ spring提供这样一个接口，实现这个接口的bean对象必须实现setBeanName方法，从而在合适的地方既可以将BeanName注入给bean。这样的接口有很多，本项目中提供四种接口，分别是：ApplicationContextAware，BeanFactoryAware，BeanClassLoaderAware，BeanNameAware，不同的bean可以继承不同的接口实现各取所需的效果。
​ 扩充bean自身功能之后，项目的框架变为：
思路
​ 为了实现bean可以使用容器资源，项目做了如下设计：
定义一个统一的Aware接口作为一个标志，想要使用具体的资源，就先要实现这个接口
针对每一种资源提供一种接口，这个接口需要继承Aware接口，代表他是提供资源的接口，内部针对不同的资源提供不同的set方法
不同的bean想 …</content></entry><entry><title>6.N字形变换</title><url>/post/6.n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🎈 6.N字形变换
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：
1 2 3 P A H N A P L S I I G Y I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。
请你实现这个将字符串进行指定行数变换的函数：
1 string convert(string s, int numRows); 思路基本思想题目的意思就是将给定的字符串按照N字形排列，例如给定一个LEETCOD，最终排序之后变成下图所示：
所以说最重要的就是模拟这个N字形，这个N字形的高已经给定，就是指定的行数，可以发现元素在排序时，元素行下标的变化范围始终在[0,numRows]中变化，并且先变大后变小，也就是先加一步，到了转折点再减一步
知道上面的步骤之后，可以发现一到了转折点加就会变成减，而这个转折点要么在第一行，要么在最后一行，所以可以设置一个步长，要么加一步要么减一步，最终的代码为：
1 2 if(index==0||index==numRows-1) flag=-flag; 每次往一行中添加一个字符，遍历完整字符串之后，每一行的字符也就遍历得到了，最终将每一行拼接返回即可：
执行流程初始化一个numRows行的字符串数组 从头开始遍历字符串，一旦遇到转折点，步长就会变成相反数，也就是加一步变成减一步，减一步变成加一步 遍历完成之后，将每一行的字符串拼接起来返回即可 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String convert(String s, int numRows) { //只有一行，没必要转换，直接返回 if(numRows&lt;2) return s; String[] strs=new String[numRows]; Arrays.fill(strs,&#34;&#34;); int index=0,flag=-1; String res=&#34;&#34;; for(int i=0;i&lt;s.length();++i){ char c=s.charAt(i); strs[index]+=c; //到转折点开始变换方向 if(index==0||index==numRows-1) flag=-flag; index+=flag; } for(int i=0;i&lt;numRows;++i){ res+=strs[i]; } return res; } } 总结主要是清楚N字形成的过程中，相当于每次向一行中添加一个字符，每一行的行标变化有规律，要么加一步，要么减一步，变化的转折点在第一行和最后一行，所以以此建立一个下标，从而实现下标的来回变化
  ]]></content></entry><entry><title>7.引入初始化和销毁逻辑</title><url>/post/7.%E5%BC%95%E5%85%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E9%80%BB%E8%BE%91/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"><![CDATA[   🥭7.引入初始化和销毁逻辑
​	在上一节中，我们实现了应用上下文，并且在应用上下文中加入了修改模块，主要是在bean的生命周期的实例化之前和之后分别加入修改逻辑，本节中继续在这个项目的基础上增加一个模块：初始化和销毁模块，分别用于初始化bean内部所需要的一些信息，以及在bean使用完毕之后，销毁bean的实例化信息，使得项目向着标准的spring框架更进一步，本节中涉及到的代码放到了仓库中
原因​	在之前的章节中，UserDao类中有一个hashMap容器，但是初始化的操作一直放在了static代码块中，这种方式虽然可行，但是spring框架中有更好的解决办法。我们可以将这一部分操作放到spring的初始化操作中，执行时机是在bean的实例化的时候，属性填充完毕之后，就可以执行static代码块中的操作
1 2 3 4 5 6 7 8 9 10 11 public class UserDao { private static Map&amp;lt;String, String&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;(); static { hashMap.put(&amp;#34;1&amp;#34;, &amp;#34;张三&amp;#34;); hashMap.put(&amp;#34;2&amp;#34;, &amp;#34;李四&amp;#34;); hashMap.put(&amp;#34;3&amp;#34;, &amp;#34;王五&amp;#34;); } public String queryUserName(String uId) { return hashMap.get(uId); } } ​	同时，在bean容器使用完毕之后，没有任何销毁操作，如果bean中用到了一些必须释放的资源，在之前的设计中，是无法释放的。所以销毁方法就在这里提出来用来解决这些问题，销毁方法的执行时机是在虚拟机关闭时，调用一个钩子函数，来执行所有的销毁收尾工作。
​	对于初始化和销毁操作来说，有三种实现方式：
注解：在bean的类中使用@PostConstruct和@PreDestroy注解修饰方法，之后在bean的初始化时和销毁时就会调用，但是这种方式本文中没有实现
接口：在项目中定义接口，然后外部实现这个接口，自定义初始化和销毁方法。内部调用统一命名的方法，就可以调用到自定义的初始化和销毁方法，例如在上一节中的实例化前的修改逻辑： …  ]]></content></entry><entry><title>整数和罗马数字之间的转换</title><url>/post/%E6%95%B4%E6%95%B0%E5%92%8C%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> ⛑️ 整数和罗马数字之间的转换
罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。
思路
基本思想
为了实现整数向罗马数字的转换，肯定需要一个映射关系，也就是需要建立一个哈希表，然后逐渐将数字拆分，没拆分依次就需要对应找到一个罗马字符表示拆分出来的部分，需要注意的是，拆分过程中需要遵循先拆大元素，再拆小元素的流程
需要注意的是，有六种特殊情况需要处理，所以可以再为这六种特殊情况添加六个新的映射，一旦有匹配的先匹配特殊情况，遵循从大到小的原则即可
为了实现罗马数字向整数的转换，需要注意的是，当罗马符号大的一般在左边，也就是高位，但是也有特殊情况，当大的在右边，也就是低位的时候就是特殊情况，所以需要单独处理这种特殊情况
注意到，当大的数在低位时，我们可以做减法，也就是当左边的数字小于右边的数字时，此时就出现了特殊情况，此时就不再是累加，需要减去当前位的数字，例如，给定一个IV，左边的I小于右边的V，此时遍历到I时，累加得到的结果是5，但是由于I小于右边的V，所以此时做减法，得到的结果为4，如果左边的值大于右边的值，此时正常做累加
执行流程
罗马数字转整数
从后向前遍历给定的罗马字符序列 当当前字符的值小于前一个字符的值，需要在整体结果的基础上减去当前字符代表的值，例如IV，当遍历到I时，需要减去I 的值 遍历结束返回最终的结果 整数转罗马数字
建立哈希表，一共十三种情况，包括正常的七 …</content></entry><entry><title>6.引入ApplicationContext和后置处理器</title><url>/post/6.%E5%BC%95%E5%85%A5applicationcontext%E5%92%8C%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍏 6.引入ApplicationContext和后置处理器
​ 在上节中，我们实现了从配置文件中读取bean的配置信息，也就是说在实例化之前增加了一个配置文件的读取和利用的模块，但资源文件读取还是要手动调用loadBeanDefinitions方法，没有模拟出spring中真正的配置文件加载过程。所以，本节中我们继续完善spring框架，对外提供修改的接口，可以在bean 对象注册后但未实例化之前，对 Bean 的定义信息 BeanDefinition 执行修改操作。还可以在bean对象实例化之后进行修改。并且将bean对象的配置文件加载，注册，实例化，修改等操作都融合到一个上下文操作类中，本节中主要是将之前的一些操作都进行封装，对外只暴露这个上下文操作类，使其更加符合spring框架的特点。本节中涉及到的代码放在了
仓库
中
原因
​ 在上面几节中，我们已经实现了很多的功能，包括IOC容器实现bean的实例化，创建带参的bean对象，属性填充和bean实例化分离，加载配置文件。但是到现在我们还没有提到应用上下文的概念，其实正常使用spring框架时，标准入口都是不同的“应用上下文”，所以本节中我们就将上面提到的所有功能都封装到应用上下文中，从而实现spring的进一步标准化
​ 同时，为了在bean的生命周期中进行扩展，本节中还加入了对bean修改的接口，可以在bean实例化之前修改bean的注册信息，还可以在bean实例化之后修改bean对象，提供了两个标准接口BeanFactoryPostProcessor和BeanPostProcessor，实现前者的类，spring项目中就认为这是要在bean实例化之前修改bean的注册信息，实现后者的类，spring项目中就认为这是要在bean实例化之后修改bean对象，具体项目的整体结构为：
​ 所以总结来看，提出这两个新知识点的目的在于让spring变得更加标准化，功能更加丰富
思路
在这里说明整体的设计思路，直接通过debug的方式来描述整个运行流程，从实例化之前的修改，到实例化，到实例化之后的修改
​ 为了实现将整个项目包裹到应用上下文中，并且在其中bean的生命周期中加入修改的模块，需要将这两个部分分开介绍，首先是修改模块，在实例化之前的修改策略分为三步：
实 …</content></entry><entry><title>5.将bean的注册信息放入配置文件</title><url>/post/5.%E5%B0%86bean%E7%9A%84%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF%E6%94%BE%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍒 5.将bean的注册信息放入配置文件
之前几节已经实现了将bean的创建交给IOC容器，并且创建和属性填充已经分开，但是bean的定义、注册、属性填充、对象调用都是手动在测试方法中实现的，这与真正的spring并不相符，所以本节在之前的基础上将spring中bean的定义，注册，属性填充等都配置到配置文件中，然后编写代码读取配置文件中的信息，完成定义，注册，属性填充等操作，使其变得更像一个spring框架，详细的代码在
仓库
中
原因
​ 在之前几节中，我们实现了bean的创建交给IOC容器，并且创建和属性填充分开的效果，但是存在的问题是，不管怎么获取bean对象，在获取之前都需要将bean的注册信息手动配置好，然后再获取bean对象，这与真实的spring框架并不相同，正常需要从配置文件中获取bean的注册信息，所以本节的目标是为了将手动配置bean的注册信息改成从配置文件中获取。
思路
​ 为了实现在配置文件中读取bean的注册信息的目的，主要新增了一个资源加载和资源利用的模块，正常的bean注册和属性填充的功能保持不变。新增的功能分别处于core.io和beans模块中，从原先的在测试方法中手动编写bean的注册信息改成现在的在配置文件中加载，使其更加符合真实spring的情况
​ 为了实现本节中提到的将bean的注册信息改成从配置文件中读取的目的，主要新增了一个资源加载和资源利用的模块，正常的bean注册和属性填充的功能保持不变。新增的功能分别处于core.io和beans模块中，从原先的在测试方法中手动编写bean的注册信息改成现在的在配置文件中加载，使其更加符合真实spring的情况
​ 对于资源加载来说，类的整体结构图如下：
​ 对于资源利用来说，类的整体结构图如下：
通过加入以上两个模块，实现了将bean的注册信息由手动注册改为从配置文件中加载，下面介绍本节中一些类的变化：
修改的类
在本项目中，对原有的类进行了部分修改，下面逐个介绍每一个被修改的类，以及修改的意义是什么：
BeanFactory：在这个接口中新增一个按照类型获取bean对象的待实现方法，然后在AbstractBeanFactory类中进行了实现，新的类结构为：
AbstractBeanFactory：对上面提到的按照类型获取bean对象的方法进行了实现，也就是新增了一个方法， …</content></entry><entry><title>380.线性时间时间插入、删除和获取随机元素</title><url>/post/380.%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🍅 380.线性时间时间插入、删除和获取随机元素
实现RandomizedSet 类：
RandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。 你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。
思路提示-231 &lt;= val &lt;= 231 - 1 最多调用 insert、remove 和 getRandom 函数 2 * 10^5 次 在调用 getRandom 方法时，数据结构中 至少存在一个 元素。 基本思想为了实现线性时间的插入和删除，需要知道最耗费时间的是什么，为了插入和删除，首先需要找到这个元素，找元素的过程就很消耗时间，于是将找元素的功能集成到哈希表中，这样找元素就可以在线性时间内完成，为了进一步减小插入和删除的时间复杂度，可以将元素存储到一个数组中，插入时直接在尾部插入，然后在哈希表中记录元素的值和元素的位置，删除时先在哈希表中找到元素的位置，然后让数组的默认元素覆盖待删除的元素即可
哈希表负责记录元素的位置，数组负责存储元素，这样插入和删除都很快
执行流程初始化哈希表存储元素的位置，键代表元素的内容，值代表元素在数组中存储的位置 初始化数组存储元素的内容，使用一个下标记录当前有效元素的最后位置，因为提示中说最多调用 insert、remove 和 getRandom 函数 2 * 10^5 次，所以数组最大就是200000 插入时先记录元素的位置，再插入 删除时先获取元素的位置，再删除，删除的时候直接使用最后一个位置的元素覆盖待删除元素，然后更新哈希表中元素的位置，最后更新数组的长度即可 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class RandomizedSet { private Map&lt;Integer,Integer&gt; map; int[] nums; int index; Random r; public RandomizedSet() { map=new HashMap&lt;&gt;(); nums=new int[200001]; index=-1; r=new Random(); } public boolean insert(int val) { if(map.get(val)!=null) return false; nums[++index]=val; map.put(val,index); return true; } public boolean remove(int val) { if(map.get(val)==null) return false; int location=map.remove(val); //删除的不是最后一个元素 if(location!=index) //将最后一个元素覆盖到待删除的元素位置上 map.put(nums[index],location); //删除最后一个位置的元素 nums[location]=nums[index--]; return true; } public int getRandom() { return nums[r.nextInt(index+1)]; } } 总结主要是利用哈希表存储元素的位置，然后利用数组插入删除，尽可能降低时间复杂度
  ]]></content></entry><entry><title>4.bean的实例化和属性填充分离</title><url>/post/4.bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85%E5%88%86%E7%A6%BB/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍐 4.bean的实例化和属性填充分离
本节中主要是修改上一节中留下来的小问题，上一节中实现了带参的bean对象创建，但是一旦当前bean对象依赖另一个bean对象时，这种创建方式就会失效，因为上一节的带参bean对象创建需要先得到所有的参数。也就是说，当内部依赖另外一个bean对象时，需要先将这个bean对象new出来，然后将其当成参数传递给getBean方法，但是这又不符合bean对象的设计模式了，我们前面千辛万苦将bean的创建交给了IOC容器，现在不能将bean的创建工作交给自己，所以这里需要另辟蹊径，来实现bean的另外一种创建模式（先创建再属性填充），具体的代码在
仓库
中
原因
​ 由于spring中，bean与bean之间经常存在依赖关系，最典型的就是service中的bean肯定会依赖于dao中的bean，也就是说，service中的bean有一个参数，参数类型是另一个bean。上一节中我们实现了带参bean对象的创建，但是创建bean对象的时候，需要将这个bean对象需要的所有参数都准备好，这就出现了一个问题：
创建service中的bean时，需要将dao中的bean准备好，也就是提前需要得到dao中的bean对象，这不符合需要时才创建的逻辑，所以我们在这一节中就将解决这个问题
​ 为了实现使用时才创建，需要改变思路，上一节中是将所有的参数准备好，然后直接创建bean对象，这一节中将bean对象依赖的所有关系都记录下来，普通类型的参数直接记录值，bean类型的参数只记录一个依赖关系，然后先创建一个空的bean对象，之后再进行属性填充，这种创建bean的方式才更加符合原始spring框架的流程，具体如下图所示：
其实这种依赖关系可以进行配置，也就是这种依赖的属性列表可以配置到xml文件中，然后从xml配置文件中读取到对应的PropertyValues
​ 上一节中我们创建bean的时候，使用getBean函数需要传递bean需要的参数，这样才能创建带参的bean对象，这一节中我们不传递任何参数，只是将需要bean的参数的信息保存到一个类中，先创建空的bean对象，然后再进行属性填充，新的项目结构为：
不再是创建bean时就填充属性，而是创建好了之后再填充属性，这样就不用在getBean时就传递已经实例化的bean属性了，也就 …</content></entry><entry><title>JDK中的动态代理</title><url>/post/jdk%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url><categories><category>学习笔记</category></categories><tags><tag>动态代理</tag></tags><content type="html"><![CDATA[   🐇 JDK中的动态代理
本文主要介绍JDK中的代理是如何实现的，从基本的例子出发，先介绍简单的静态代理，然后重点介绍动态代理，开始分析源码，之后展示JDK动态生成的代理类长什么样，是如何实现代理的，最后总结整个代理的流程
静态代理所谓的代理，就是在原有方法的基础上进行增强，并且不侵入源代码，下面介绍一个静态代理的例子：
UserService接口的代码
1 2 3 4 5 public interface UserService { public void select(); public void update(); } UserServiceImpl类的代码，就是UserService接口的实现类
1 2 3 4 5 6 7 8 9 public class UserServiceImpl implements UserService { public void select() { System.out.println(&amp;#34;查询 selectById&amp;#34;); } public void update() { System.out.println(&amp;#34;更新 update&amp;#34;); } } UserServiceProxy类的代码，就是代理类，用来增强UserServiceImpl类的功能
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class UserServiceProxy implements UserService{ //保存需要被代理的对象 private UserServiceImpl target; public UserServiceProxy(UserServiceImpl target) { this.target = target; } //调用被代理的方法，对原始方法进行增强，对外暴露代理对象Proxy的接口 //使得用户对增强无感 @Override public void select() { before(); //调用被代理对象的方法 target.select(); after(); } @Override public void …  ]]></content></entry><entry><title>3.创建带参bean对象</title><url>/post/3.%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%8F%82bean%E5%AF%B9%E8%B1%A1/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🍈 3.创建带参bean对象
本文主要是在上一章的基础上对上一章中代码存在的问题进行改造，上一章中将bean对象的创建交给了IOC容器，利用反射创建bean对象并保存到IOC容器中，但是忽略了一点，上章中代码只能创建不携带参数的bean对象，所以这一章主要解决的问题就是创建有参数的bean对象，正常的spring创建带参的bean对象时，参数应该注册到了BeanDefinition中，然后先创建然后属性填充，但是本节中我们直接一步到位，简化bean的创建过程。具体的代码在
仓库
中
原因
​ 为什么上一章中只能创建不带参数的bean对象呢，主要问题出现在createBean函数中，可以查看createBean的代码就能够发现问题：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override protected Object createBean(String beanName, BeanDefinition beanDefinition) throws BeansException { Object bean; try { //利用反射,根据传递来的类信息创建一个实例化对象 bean = beanDefinition.getBeanClass().newInstance(); } catch (InstantiationException | IllegalAccessException e) { throw new BeansException(&amp;amp;#34;Instantiation of bean failed&amp;amp;#34;, e); } //在这里就是创建成功 //调用继承自DefaultSingletonBeanRegistry中的addSingleton方法将这个对象保存到容器中 addSingleton(beanName, bean); //将创建的bean返回，返回值用于getBean的返回值 return bean; } ​ 在第六行中，直接利用反射，调用newInstance方法创建一个bean对象，此处调用时并没有区分bean对象是否携带参数，导致创建出来的bean对象全都是无参的，所以需要改进的地方就在这里，将这里创建bean对象的代码进行扩充，接收bean对象的参数，就可以在创建bean对象时创建携带参数 …</content></entry><entry><title>H指数</title><url>/post/h%E6%8C%87%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🏞️ H指数
给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。
根据维基百科上 h 指数的定义
：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。如果 h 有多种可能的值，h 指数 是其中最大的那个。
思路
基本思想
思路1
主要就是要理解符合条件的H指数的定义为：至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。这代表H指数的大小不可能超过给定的论文篇数，因为前面的至少发表了h篇论文限制了H指数的范围，并且后面的限制条件为每篇论文至少被引用h次的意思是引用的次数有限制
这样分析不好理解，直接从答案的角度进行分析[3,0,6,1,5]这个数组
当H指数为0时，代表至少发表了0篇论文，每篇论文至少被引用了0次：这个条件很好满足，空集就可以满足，给定的[3,0,6,1,5]这个数组肯定可以满足，符合条件的论文数为5。所以H指数至少为0 当H指数为1时，代表至少发表了1篇论文，每篇论文至少被引用了1次，符合条件的论文数为4，分别是[3,6,1,5]，所以H指数可以为1 当H指数为2时，代表至少发表了2篇论文，每篇论文至少被引用2次，符合条件的论文数为3，分别是[3,6,5]，所以H指数可以为2 当H指数为3时，代表至少发表了3篇论文，每篇论文至少被引用3次，符合条件的论文数为3，分别是[3,6,5]，所以H指数可以为3 当H指数为4时，代表至少发表了4篇论文，每篇论文至少被引用4次，符合条件的论文数为2，分别是[6,5]，所以H指数不可以为4，因为每篇论文引用数至少是4，这样的论文只有两篇，所以不符合条件，4都不符合条件，5更加不符合条件 根据上面的分析流程，可以直接写出代码，分别模拟n为1,2,3,4。。。等数时的情况，看符合条件的论文数是否超过当前的n，超过时就可以成为H指数的候选，最终选一个最大的数作为H指数
思路2
题目的核心思想是为了找到超出引用数n的文章数count有多少，当对于某一个n来说，其对应的count大于等于n时，这个数就有可能成为H指数，所以干脆统计每一种引用数对应的文章数有多少。并且按照思路1的分析,H指数的大小不可能超过文章的发表数，也就 …</content></entry><entry><title>2.自动创建bean对象</title><url>/post/2.%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAbean%E5%AF%B9%E8%B1%A1/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"> 🤔 2.自动创建bean对象
本节中主要是以上一节为基础，并对上一节制作的IOC容器进行改良，上一节中，bean对象的实例化是手动new出来的，这一节中将bean对象的创建交给IOC容器本身，并且为了考虑扩展性，尽可能的使得每一个类都只执行一个职责，最终让整个项目变得更加健壮，本节中创建的bean默认单例。关于项目的源码存放在
仓库
中
思路
本节就是在上一节的基础上将bean的创建交给了IOC容器，并且实现了一个单例模式（默认）的bean，具体的设计图如下：
可以看出，只是在定义、注册、获取的基础上多了几个模块，例如获取bean对象的时候要判断是否已经存在，存在直接返回，不存在就创建再返回等。。。项目的核心类图如下：
下面依次针对每一个类进行讲解
类的说明
SingletonBeanRegistry：是一个接口，只是提供了一个待实现的getSingleton(String beanName)方法，后期获取bean对象时调用getBean方法，内部调用这个方法，尝试获取一个单例模式的bean，方法的实现在DefaultSingletonBeanRegistry类中，主要就是从容器中按照bean对象的名称尝试获取bean对象，对象不存在返回值为null
DefaultSingletonBeanRegistry：是SingletonBeanRegistry的实现类，类中有如下方法：
内部有一个名为singletonObjects的HashMap容器，主要存储已经实例化后的bean对象及其名称之间的映射关系，主要实现了getSingleton(String beanName)方法，并且还增加了一个addSingleton(String beanName, Object singletonObject)方法，主要作用是对外提供一个保存实例化后的bean对象的api，在AbstractAutowireCapableBeanFactory类中的createBean(String beanName, BeanDefinition beanDefinition)中使用，主要作用是将利用反射创建的bean对象保存到容器中，使的bean变成单例
BeanFactory：是一个接口，提供了一个待实现的getBean(String name)方法，对外暴露之后，可以实现从IOC容器中尝试 …</content></entry><entry><title>1.创建spring容器</title><url>/post/1.%E5%88%9B%E5%BB%BAspring%E5%AE%B9%E5%99%A8/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag><tag>源码</tag></tags><content type="html"><![CDATA[   😀 1.创建spring容器
本文介绍small_spring的第一节知识，简单的实现一个最基础的spring中的容器，包括定义、存储、获取这个容器中的bean对象，相比于真正的spring源码只是一个简化版本，后面的章节会慢慢的对这个容器进行扩充，文章中涉及到的代码在仓库中
思路​	一般的spring容器需要经历两步才能将一个bean存储到IOC容器中，分别是定义、注册，其中定义一般是存放bean的类型，但是在本节中直接存放的是bean对象本身，后期将对这个功能做出修改。注册一般是将bean的名称与其类型的映射关系，但是本节中直接实例化一个bean，然后将这个bean存储到容器中，最后的获取就是按照bean的名称获取对应的bean对象
​	按照上面的分析，代码的主要逻辑就是将bean的实例化对象存储到一个容器中，之后通过bean的名称获取，实现这中功能的容器一般是Map，整个流程如下：
实现定义：主要是定义一个BeanDefinition类，然后将bean的实例化对象存储进去，所以这里直接使用Object来存储这个对象 注册，主要是将BeanDefinition中的bean对象及其名称之间的映射关系保存起来，代码中直接使用HashMap来存储这种映射关系 获取，直接按照键，也就是bean的名称获取到对应的bean，这里并没有考虑bean不存在的问题，因为本节中只是最简单的手动实例化一个bean，然后将其存储到容器中 测试：针对定义的IOC容器进行测试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Test public void testBeanFactory() { //1.定义 //获取工厂对象 BeanFactory beanFactory = new BeanFactory(); //准备要注入的bean对象 UserService userService = new UserService(); //将其注入到BeanDefinition中 BeanDefinition beanDefinition = new BeanDefinition(userService); //2.注册 //将bean保存到IOC容器中 beanFactory. registerBeanDefinition(&#34;userService&#34;, beanDefinition); //3.获取 //根据名称从IOC容器中取出对应的bean UserService user = (UserService) beanFactory.getBean(&#34;userService&#34;); //执行bean的对应方法 user.print(); } 可以看出测试的过程就是上面描述的三步，只不过相比于真正的spting，大大的简化了所有的步骤
总结本节实现了一个最基础的不标准IOC容器，后面的章节会逐步对这个容器进行扩充
  ]]></content></entry><entry><title>80.删除有序数组中的重复项II</title><url>/post/80.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9ii/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🕯 80.删除有序数组中的重复项II
给你一个有序数组 nums ，请你**
原地
** 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
思路
基本思想
本题与
26.删除有序数组中的重复项
有些类似，只不过每种类型的元素不是只保留一个，而是最多保留两个，这个要求包含两层意思，第一个意思是本来就只出现一次或者两次的数据直接留下不删除，出现三次以上的数据需要删除多余的，只保留两次
这种从数组中删除不符合要求元素的题目，一般使用快慢指针来解题，需要明确的是，慢指针在题中代表的含义是当前需要保留的元素的最后位置。对于本题来说，当元素出现次数小于等于两次时就可以留下，如何使用代码表示当前元素出现次数小于等于两次呢？
可以考虑极端情况，当前元素是第三次出现，那么说明前两次已经保存起来了，现在slow慢指针指向的位置就是这个第三次出现的位置，当前元素不能保留，也就是当nums[fast]==nums[slow-2]的时候，这个元素不能保留，-2的原因是因为当前的元素需要保留最多两个，当前slow的位置前面有两个重复的元素时，当前slow的位置就可以覆盖，否则就不能覆盖
最开始的想法是，当当前元素出现第一次或者出现第二次时，都可以留下，判断的条件是：
1 nums[fast]!=nums[fast-1]||nums[fast]!=nums[fast-2] 但是当nums=[1,1,1,2,2,3]时，第一个2保留之后，nums变为[1,1,2,2,2,3]，此时slow在加粗的位置，fast在斜体的位置，使用上面的判断条件，fast处的元素无法保留，其实按照题意应该保留
使用nums[fast]!=nums[slow-2]这个条件时，一定能确保slow前面每种元素最多可以保留两个
核心就是明白slow代表当前需要保留的元素的最后的位置，fast是当前第一个待判断的元素
此处补充一下
26. 删除有序数组中的重复项
的解题思路，为了将每种元素保留一次，相当于每一种元素头一次出现时就需要记录一下，所以判断条件是nums[fast]!=nums[fast-1]就需要保留当前元素
执行流程
从第三个元素开始，判断每个元素是否应该保留
如果当前这种元素已 …</content></entry><entry><title>278.寻找重复数</title><url>/post/278.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🕊︎ 278.寻找重复数
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。
思路
基本思想
题目中说，一共有n+1个数，但是数字的范围为[1,n]。这是典型的鸽巢原理的题目，即使每个数字只出现一次，那么最后一定会多一个元素，这个元素就是重复的。这是最极端的情况，真实情况下，重复的元素可能不止重复一次，但是题目中又描述，只有一个重复的元素，说明就是这种最极端的情况
为了找到这个重复的元素，可以借鉴
环形链表II
的思想，先找到环，之后找到环的入口，这个入口就是重复的元素，为了找到环，需要使用快慢指针的思想。为了找到入口，需要从链表的起点和当前相遇的点开始向后走，二者再次相遇的地方就是环的入口，这是经过环形链表II中推导得到的。
但是上面的思想是链表中，本题中提供的是数组，所以需要将数组转换成链表，于是可以利用下标index和数值nums[index]之间的映射关系来构造一个链表
由于一共有n+1个数，所以数组元素下标的范围为[0~n]，而数组中的每一个元素的范围为[1~n]，这可以说明，可以直接建立映射，不用担心建立应设置后数组下标越界的情况
所以第一阶段就是判断环在哪
1 2 3 4 5 6 7 8 9 int slow = nums[0]; int fast = nums[0]; //快慢指针先各走一步 slow = nums[slow]; fast = nums[nums[fast]]; while (slow != fast){//不用担心下标越界的情况 slow = nums[slow]; fast = nums[nums[fast]]; } 因为必须要先走一步，所以可以将while循环改成do while循环
1 2 3 4 5 6 7 int slow = nums[0]; int fast = nums[0]; //找到快慢指针的相遇点 do{ slow = nums[slow]; fast = nums[nums[fast]]; }while (slow != fast); 上面代码中的快慢指针移动的方式需要注 …</content></entry><entry><title>31.下一个排列</title><url>/post/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🧤 31.下一个排列
整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。
例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。
必须**
原地 **修改，只允许使用额外常数空间。
思路
基本思想
有点类似于贪心的思想，尽可能的修改给定数组的后面位置，这样才能找到下一个位置，修改的时候，需要找到一个合适的位置交换元素，这个合适的位置需要从后向前找，这样修改时修改的尽可能是低位，从而变化尽可能小，才能找到下一个排列
根据上面的分析，需要找到第一个可以交换的较小的数，所以第一步需要从后向前找到这个较小的数，所以需要从后向前找到第一个升序对，这个升序对的左边的元素就是可以替换的最小的数，对应到上图中就是[5,7]这个升序对，5就是可以替换的最小的数，将其替换就可以让整体变得稍微大一些
为了找到下一个排列，需要将这个最小的数替换为一个尽可能小的大数，也就是从后向前找出第一个比当前这个最小的数大的数，这个数是比这个最小的数大一点点的数，交换之后，可以让整体变大一点，对应到上图就是6,5和6交换之后，可以让整体变大，因为高位变大
交换之后，需要注意的是，高位变大，后面的序列需要变的最小，从而使其成为下一个排列，为了让后面的序列变得最小，将其升序排列就变得最小，对应到上图就是5变成6之后，高位变大，后面的[7,5,4]还是降序，将其变得最小就可以让其变成下一个排列
交换之后就形成了下一个排列，对应到下图中就是：
如果搜索下来没有发现一个升序对，那就是[3,2,1]的情况，根据题意，需要将 …</content></entry><entry><title>数据库和java中的乐观锁</title><url>/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Cjava%E4%B8%AD%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81/</url><categories><category>学习笔记</category></categories><tags><tag>乐观锁</tag></tags><content type="html"><![CDATA[   数据库和java中的乐观锁
本文介绍mybatis plus和java代码中的乐观锁使用的不同，主要是针对代码层面进行分析
先介绍mybatis plus实现乐观锁的流程，然后介绍传统java代码中乐观锁的执行流程
本文主要介绍乐观锁，乐观锁认为，不是所有的并发操作都会出现问题，只有极少数的并发操作会出现丢失更新等风险，于是没有必要对于所有的请求进行加锁排队，这样大大浪费了资源，而对所有的请求都加锁的操作成为悲观锁，这种技术比较粗暴
乐观锁先放任所有的请求都执行，然后在更新的过程中执行CAS算法，也就是先进行操作，操作之后将这个值与更新前的值进行对比，如果没有变化就真的操作更新，如果这个值发生了变化，此时说明这个值被别人修改过了，当前这次更新需要作废，也就是Compare And Swap
另外一种乐观锁的机制是版本号机制
数据库数据库为了防止出现并发操作带来的问题，实现了一个乐观锁，这个乐观锁是基于版本号机制的
取出记录时，获取当前version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 执行流程数据库添加一个字段，一般名称为version，初始值为1：
java代码中的pojo实体类中添加一个属性，名称与数据库中的字段名保持一致，并且添加@Version注解，代表这个属性受到乐观锁的控制：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Data public class User { @TableId(type = IdType.ASSIGN_ID) private Long id; private String name; @TableField(value = &amp;#34;pwd&amp;#34;,select = false) private String password; private Integer age; private String tel; @TableField(exist = false) private Integer online; @TableLogic(value = &amp;#34;0&amp;#34; ,delval = &amp;#34;1&amp;#34;) private …  ]]></content></entry><entry><title>152.乘积最大子数组</title><url>/post/152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag><tag>动态规划</tag></tags><content type="html"> 152.乘积最大子数组
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
测试用例的答案是一个 32-位 整数。
子数组 是数组的连续子序列。
思路
基本思想
为了得到连续的子数组乘积，说明当前子数组中的元素不能删除或者移动，只能在原数组的基础上求得结果，简单的来看，当前位置得到的最大连续子数组乘积与之前的位置有关，得到一个更新数组： $$ dp[i]=max(dp[i],dp[i-1]*nums[i]) $$ 当前位置的元素是否加入当前连续的子数组乘积中，取决于加入之后乘积能否变大，不能变大的原因是因为当前元素为负，但是这种思路只能解决部分问题，例如当nums数组为[2,3,-2,4]这种类型可以，但是一旦遇到[-3,-1,-1]这种数组，最终求出来的结果就会是-1，但是真正的结果为3
出现上面情况的原因是因为上面给出的更新公式只考虑了前面元素为正的情况，为负的情况直接丢弃了，但是一旦当前元素为负，前面又出现一个为负的连续子数组乘积，那么此时负负得正，就会得到一个最大的值，所以需要分情况讨论：
当当前元素为正时，当前元素与之前的连续子数组的最大值相乘能得到一个更大的值 当当前元素为负时，当前元素与之前的连续子数组的最小值相乘能得到一个更大的值 所以从当前位置向前看，不仅需要当前位置向前的最大连续子数组的乘积，还需要当前位置向前的最小连续子数组的乘积
有了上面的分析过程，当前元素所处位置的最大连续子数组的乘积的更新公式就变成了： $$ dpMax[i]=max(dpMax[i],dpMax[i-1]*nums[i],dpMin[i-1]*nums[i]) $$ 一共有三项，从中取出最大的一项，取出第一项的原因是因为前面是负数，当前元素是正数，例如[-3,1]中元素1所处的位置，或者当前元素为负数，前面是正数 ，例如[2,3,-1]中元素-1所处的位置
取出第二项的原因是因为当前元素为正，前面的元素也为正，例如[2,3,4]中元素4所处的位置
取出第三项的原因是因为当前元素为负，前面的元素也为负，例如[-3,-1,2]中元素-1所处的位置
另外需要注意的是，还需要维护一个dpMin来记录当前元素之前的最小连续子数组的乘积
$$ …</content></entry><entry><title>Mybatisplus</title><url>/post/mybatisplus/</url><categories><category>学习笔记</category></categories><tags><tag>mybatisplus</tag></tags><content type="html"> 😻 mybatisplus
本文主要介绍一些mybatisplus的基础知识，之后直接引入一个标准CRUD的程序，之后介绍mybatisplus中的多条件查询以及多记录操作，最后介绍一个乐观锁以及代码生成器
MyBatisPlus入门案例与简介
这一节我们来学习下MyBatisPlus的入门案例与简介，这个和其他课程都不太一样，其他的课程都是先介绍概念，然后再写入门案例。而对于MyBatisPlus的学习，我们将顺序做了调整，主要的原因MyBatisPlus主要是对MyBatis的简化，所有我们先体会下它简化在哪，然后再学习它是什么，以及它帮我们都做哪些事。
入门案例
MybatisPlus(简称MP)是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提供效率。
开发方式
基于MyBatis使用MyBatisPlus 基于Spring使用MyBatisPlus 基于SpringBoot使用MyBatisPlus SpringBoot刚刚我们学习完成，它能快速构建Spring开发环境用以整合其他技术，使用起来是非常简单，对于MP的学习，我们也基于SpringBoot来构建学习。
学习之前，我们先来回顾下，SpringBoot整合Mybatis的开发过程:
创建SpringBoot工程
勾选配置使用的技术，能够实现自动添加起步依赖包
设置dataSource相关属性(JDBC参数)
定义数据层接口映射配置
我们可以参考着上面的这个实现步骤把SpringBoot整合MyBatisPlus来快速实现下，具体的实现步骤为:
步骤1:创建数据库及表
1 2 3 4 5 6 7 8 9 10 11 12 13 create database if not exists mybatisplus_db character set utf8; use mybatisplus_db; CREATE TABLE user ( id bigint(20) primary key auto_increment, name varchar(32) not null, password varchar(32) not null, age int(3) not null , tel varchar(32) not null ); insert into user …</content></entry><entry><title>Springboot</title><url>/post/springboot/</url><categories><category>学习笔记</category></categories><tags><tag>springboot</tag></tags><content type="html"> 👹 springboot
本文中介绍了springboot的基础知识，包括springboot是什么，springboot的配置文件，springboot类似于spring的整合junit，整合mybatis，最后将spring中的一个项目转换成springboot的项目
SpringBoot简介
SpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用简化 Spring 应用的初始搭建以及开发过程。
使用了 Spring 框架后已经简化了我们的开发。而 SpringBoot 又是对 Spring 开发进行简化的，可想而知 SpringBoot 使用的简单及广泛性。既然 SpringBoot 是用来简化 Spring 开发的，那我们就先回顾一下，以 SpringMVC 开发为例：
创建工程，并在 pom.xml 配置文件中配置所依赖的坐标 编写 web3.0 的配置类
作为 web 程序，web3.0 的配置类不能缺少，而这个配置类还是比较麻烦的，代码如下
编写 SpringMVC 的配置类 做到这只是将工程的架子搭起来。要想被外界访问，最起码还需要提供一个 Controller 类，在该类中提供一个方法。
编写 Controller 类 从上面的 SpringMVC 程序开发可以看到，前三步都是在搭建环境，而且这三步基本都是固定的。SpringBoot 就是对这三步进行简化了。接下来我们通过一个入门案例来体现 SpingBoot 简化 Spring 开发。
SpringBoot快速入门
开发步骤
SpringBoot 开发起来特别简单，分为如下几步：
创建新模块，选择Spring初始化，并配置模块相关基础信息 选择当前模块需要使用的技术集 开发控制器类 运行自动生成的Application类 知道了 SpringBoot 的开发步骤后，接下来我们进行具体的操作
创建新模块
点击 + 选择 New Module 创建新模块 选择 Spring Initializr ，用来创建 SpringBoot 工程
以前我们选择的是 Maven ，今天选择 Spring Initializr 来快速构建 SpringBoot 工程。而在 Module SDK 这一项选择我们安装的 JDK 版本。
对 SpringBoot 工程进行相关的设置
我们使用这种 …</content></entry><entry><title>Maven高级</title><url>/post/maven%E9%AB%98%E7%BA%A7/</url><categories><category>学习笔记</category></categories><tags><tag>maven</tag></tags><content type="html"> 🤠 maven高级
本文主要介绍maven的相关知识，重点内容是依赖管理还有聚合与继承，从项目的角度对maven的相关知识进行了介绍最后还介绍了如何搭建一套自己的私服，实现依赖的统一上传下载
模块开发
分模块开发设计
(1)按照功能拆分
我们现在的项目都是在一个模块中，比如前面的SSM整合开发。虽然这样做功能也都实现了，但是也存在了一些问题，我们拿银行的项目为例来聊聊这个事。
网络没有那么发达的时候，我们需要到银行柜台或者取款机进行业务操作 随着互联网的发展,我们有了电脑以后，就可以在网页上登录银行网站使用U盾进行业务操作 再来就是随着智能手机的普及，我们只需要用手机登录APP就可以进行业务操作 上面三个场景出现的时间是不相同的，如果非要把三个场景的模块代码放入到一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目无法正常启动，从而导致银行的多个业务都无法正常班理。所以我们会按照功能将项目进行拆分。
项目拆分之后，整个项目的结构变得更加清晰，同时后期也更加容易扩展
(2)按照模块拆分
比如电商的项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期的维护成本就比较高。我们就想能不能将它们公共的部分抽取成一个独立的模块，其他模块要想使用可以像添加第三方jar包依赖一样来使用我们自己抽取的模块，这样就解决了代码重复的问题,这种拆分方式就说我们所说的按照模块拆分。
经过两个案例的分析，我们就知道:
将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享。 刚刚我们说了可以将domain层进行拆分，除了domain层，我们也可以将其他的层也拆成一个个对立的模块，如:
这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。关于分模块开发的意义，我们就说完了，说了这么多好处，那么该如何实现呢?
分模块开发实现
前面我们已经完成了SSM整合，接下来，咱们就基于SSM整合的项目来实现对项目的拆分。
环境准备
原有项目的格式如下:
抽取domain层
步骤1:创建新模块
创建一个名称为maven_03_pojo的jar项目,为什么项目名是从02到03这样创建，原因后面我们会提到，这块的名称可以任意。
步骤2:项目中创建domain包
…</content></entry><entry><title>Springmvc02</title><url>/post/springmvc02/</url><categories><category>学习笔记</category></categories><tags><tag>springmvc</tag></tags><content type="html"> 🤩 springmvc02
本文主要介绍ssm整合以及将后端处理的数据如何统一封装返回给前端，之后全局的异常如何处理，前后端联调的过程以及最后的拦截器使用
SSM整合
前面我们已经把Mybatis、Spring和SpringMVC三个框架进行了学习，今天主要的内容就是把这三个框架整合在一起完成我们的业务功能开发，具体如何来整合，我们一步步来学习。
流程分析
(1) 创建工程
创建一个Maven的web工程 pom.xml添加SSM需要的依赖jar包 编写Web项目的入口配置类，实现AbstractAnnotationConfigDispatcherServletInitializer重写以下方法 getRootConfigClasses() ：返回Spring的配置类-&amp;amp;gt;需要SpringConfig配置类 getServletConfigClasses() ：返回SpringMVC的配置类-&amp;amp;gt;需要SpringMvcConfig配置类 getServletMappings() : 设置SpringMVC请求拦截路径规则 getServletFilters() ：设置过滤器，解决POST请求中文乱码问题 (2)SSM整合**[重点是各个配置的编写]**
SpringConfig 标识该类为配置类 @Configuration 扫描Service所在的包 @ComponentScan 在Service层要管理事务 @EnableTransactionManagement 读取外部的properties配置文件 @PropertySource 整合Mybatis需要引入Mybatis相关配置类 @Import 第三方数据源配置类 JdbcConfig 构建DataSource数据源，DruidDataSouroce,需要注入数据库连接四要素， @Bean @Value 构建平台事务管理器，DataSourceTransactionManager,@Bean Mybatis配置类 MybatisConfig 构建SqlSessionFactoryBean并设置别名扫描与数据源，@Bean 构建MapperScannerConfigurer并设置DAO层的包扫描，@Bean SpringMvcConfig 标识该类为配置类 @Configuration 扫 …</content></entry><entry><title>215.数组中的第k个最大元素</title><url>/post/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🍇 215.数组中的第k个最大元素
给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
思路基本思想找到第k个最大的元素本身很简单，可以使用堆排序或者普通排序找到第k个最大的元素，示例代码如下：
1 2 3 4 5 6 7 8 class Solution { //最大堆可以解决的问题 //排序之后找到第四个元素即可，相同的元素也占一位 public int findKthLargest(int[] nums, int k) { Arrays.sort(nums); return nums[nums.length-k]; } } 但是题目中规定了时间复杂度为O(n)，那么就不能使用排序，只能一次遍历解决问题
于是想到了改造经典的排序算法，这里选择改造快速排序，快速排序的每一趟都将一个元素归类到正确的位置上，如果某一次归类的元素刚好处于倒数第k个位置上，那么这个位置上的元素就是要找的，以此为基础进行改造
基础的快速排序代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static void quickSort(int[] nums,int low,int high){ if(low&amp;lt;high){ int i=low,j=high; int temp=nums[low]; //第一遍需要找到存放temp的合适位置 while(i&amp;lt;j){//这个循环控制i和j来回的移动，最终找到temp的位置 //这个循环控制从右边找到一个比temp小的元素放到前面 while(j&amp;gt;i&amp;amp;&amp;amp;nums[j]&amp;gt;=temp) j--; if(i&amp;lt;j){ nums[i]=nums[j]; i++; } //这个循环控制从左边找到一个比temp大的元素放到后面 while(i&amp;lt;j&amp;amp;&amp;amp;nums[i]&amp;lt;=temp) i++; if(i&amp;lt;j){ nums[j]=nums[i]; j--; } } //循环结束说明找到 …  ]]></content></entry><entry><title>Springmvc01</title><url>/post/springmvc01/</url><categories><category>学习笔记</category></categories><tags><tag>springmvc</tag></tags><content type="html"> ✊ springmvc01
本文主要介绍spring中的springmvc知识，介绍前后端交互的流程，postman工具的使用，以及主流的Rest风格
SpringMVC概述
学习SpringMVC我们先来回顾下现在web程序是如何做的，咱们现在web程序大都基于三层架构来实现。
三层架构
浏览器发送一个请求给后端服务器，后端服务器现在是使用Servlet来接收请求和数据
如果所有的处理都交给Servlet来处理的话，所有的东西都耦合在一起，对后期的维护和扩展极为不利
将后端服务器Servlet拆分成三层，分别是web、service和dao
web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端 service层主要负责业务逻辑的处理 dao层主要负责数据的增删改查操作 servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求
针对web层进行了优化，采用了MVC设计模式，将其设计为controller、view和Model
controller负责请求和数据的接收，接收后将其转发给service进行业务处理 service根据需要会调用dao对数据进行增删改查 dao把数据处理完后将结果交给service,service再交给controller controller根据需求组装成Model和View,Model和View组合起来生成页面转发给前端浏览器，相当于将后端查询到的数据和前端页面一起返回给浏览器，浏览器将数据填充到页面中就形成了网页 这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操作。 随着互联网的发展，上面的模式因为是同步调用，性能慢慢的跟不上需求，所以异步调用慢慢的走到了前台，是现在比较流行的一种处理方式。
因为是异步调用，所以后端不需要返回view视图，将其去除 前端如果通过异步调用的方式进行交互，后台就需要将返回的数据转换成json格式进行返回 SpringMVC主要负责的就是 controller如何接收请求和数据 如何将请求和数据转发给业务层 如何将响应数据转换成json发回到前端 介绍了这么多，对SpringMVC进行一个定义
SpringMVC是一种基于Java实现MVC模型的轻量级Web框架
springmvc将传统的mvc架构设计成了异步交互 …</content></entry><entry><title>79.单词搜索</title><url>/post/79.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🏳️‍🌈 79.单词搜索
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
思路
基本思想
为了从board中找到给定的单词,需要在board中搜索,只要找到一条完整的路径,且路径中的元素只被使用一次,那么就相当于找到了单词,对于这条路径来说,不一定非要一直向着一个方向,所以当处于一个节点时,可以向上下左右四个方向移动,所以这种搜索有点像图论中的岛屿问题,所以可以依次从board中的每一个位置出发,尝试搜索出一条合法的路径
对于board中的每一个位置来说,当当前位置无法与word中的元素匹配,那么就没有从这个位置出发的必要,直接返回false,当当前元素与word中的元素匹配,才可以进行下面的匹配
由于每一步的移动的前提是当前位置与word中的元素匹配,当当前元素匹配到了word中的最后一个位置的元素时,说明已经找到了一条路径,这条路径形成了word,此时可以逐层向上返回true,整个程序这里是递归返回点
当没有到达递归返回点,且当前位置匹配word中的元素时,需要从当前位置出发,向上下左右开始搜索,尝试找到下一个匹配的位置,找到了继续向下,没找到就返回false
总结整体的流程就是依次从board中的每一个元素出发,尝试找到形成word的一条路径,形成一个图的搜索形式,出现一个匹配的位置,就从这个位置继续向下匹配
执行流程
依次从board中的每一个元素出发进行搜索,形成一个图的搜索形式 当前元素与word的位置不匹配,直接返回false 当前元素与word的位置匹配,且匹配到了最后一个元素,直接返回true,递归从这里开始向上逐层返回true 当前元素与word的位置匹配,但是没到最后一个元素,此时需从当前元素出发,向上下左右遍历那些没访问过的元素,四个方向只要有一个方向匹配成功,就会继续向下匹配,如果没有一个位置匹配成功,此时就会逐层返回false,最终整个方法返回false,程序会继续选择board的下一个元素进行搜索,重复1的步骤 代码
根据以上分析,得出以下代码:
1 2 3 4 5 6 7 8 9 10 …</content></entry><entry><title>Java的移位操作符</title><url>/post/java%E7%9A%84%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/</url><categories><category>学习笔记</category></categories><tags><tag>Java</tag></tags><content type="html"> 🧢 Java的移位操作符
介绍Java中的移位操作符,一共有三种,从数据底层的存储开始介绍
数据在底层的存储
数据在计算机的底层统一采用补码的二进制形式存储,而Java的移位操作符只能作用于long,int,short,char四种基本整数类型上,所以这里用int进行介绍,其余的差别就是在所占的字节数上,这里总结Java中所有基本数据类型的占位情况
数据类型 位数 字节数 默认值 boolean 1 - false byte 8 1 0 short 16 2 0 char 16 2 &amp;amp;lsquo;u0000&amp;amp;rsquo; int 32 4 0 float 32 4 0f long 64 8 0L double 64 8 0d 正数
正数的补码就是其自身,例如整数5的二进制形式为00000000 00000000 00000000 00000101,补码也是00000000 00000000 00000000 00000101,对正数进行移位操作很简单
负数
负数的补码略微复杂一些,需要现将负数的原码表示出来,然后转换成反码,最后转换成补码,首先负数转换成原码需要注意,最高位是一个符号位
例如-5的原码是10000000 00000000 00000000 00000101,最高位是一个符号位
之后将原码转换成反码,除了符号位,剩下的每一位取反即可,-5的反码是11111111 11111111 11111111 11111010
最后将反码转换成补码,就是在反码的基础上对反码加1即可,-5的补码是11111111 11111111 11111111 11111011
移位操作符
左移
左移没有什么特殊的地方,高位直接覆盖,包括负数的符号位也直接覆盖,低位补零即可,例如-5的计算机存储形式为11111111 11111111 11111111 11111011,左移两位变成11111111 11111111 11111111 11101100,这是一个数的补码形式,将其转换成反码(补码-1)为11111111 11111111 11111111 11101011,进一步将其转换成原码(除了符号位都取反)为10000000 00000000 00000000 00010100,可以看出这是-20的原码,也就是说-5左移两位变成了-20
代码测试为:
1 2 3 4 5 …</content></entry><entry><title>Spring03</title><url>/post/spring03/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag></tags><content type="html"> 🧒 spring03
本文主要介绍spring中的面向切面编程AOP，实现不侵入源代码的情况下对代码进行增强处理，从入门到最后的配置以及案例进行讲解
AOP简介
前面我们在介绍Spring的时候说过，Spring有两个核心的概念，一个是IOC/DI，一个是AOP。
前面已经对IOC/DI进行了系统的学习，接下来要学习它的另一个核心内容，就是AOP。
对于AOP,我们前面提过一句话是:AOP是在不改原有代码的前提下对其进行增强。
对于下面的内容，我们主要就是围绕着这一句话进行展开学习，主要学习两方面内容AOP核心概念,AOP作用:
什么是AOP?
AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。 OOP(Object Oriented Programming)面向对象编程 我们都知道OOP是一种编程思想，那么AOP也是一种编程思想，编程思想主要的内容就是指导程序员该如何编写程序，所以它们两个是不同的编程范式。
AOP作用
作用:在不惊动原始设计的基础上为其进行功能增强，前面咱们有技术就可以实现这样的功能即代理模式。 AOP核心概念
为了能更好的理解AOP的相关概念，我们准备了一个环境，整个环境的内容我们暂时可以不用关注，最主要的类为:BookDaoImpl
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Repository public class BookDaoImpl implements BookDao { public void save() { //记录程序当前执行执行（开始时间） Long startTime = System.currentTimeMillis(); //业务执行万次 for (int i = 0;i&amp;amp;lt;10000;i++) { System.out.println(&amp;amp;#34;book dao save ...&amp;amp;#34;); } //记录程序当前执行时间（结束时间） Long endTime = System.currentTimeMillis(); //计算时间差 Long totalTime = endTime-startTime; // …</content></entry><entry><title>22.括号生成</title><url>/post/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🏧 22.括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
思路基本思想为了找出所有的合法括号组合,最简单的办法就是找出所有的括号组合,然后从中筛选出合法的括号组合,这个方法分为两步:
产生出所有的括号组合
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void generate(char[] path,int pos){ //括号组合生成完成，数组填充满了 if(path.length==pos){ if(isValid(path)) res.add(new String(path)); return; } else{ //对于当前位置,要么添加(,要么添加),形成2*n的长度立即返回 //可以递归搜索出所有的结果 //两种递归方式，因为每个位置有两种填充方式（左括号或者） path[pos]=&amp;#39;(&amp;#39;; generate(path,pos+1); path[pos]=&amp;#39;)&amp;#39;; generate(path,pos+1); } } 给定三个括号,一共六个位置,每个位置不是放置左括号就是放置右括号,所以可以使用递归的方法产生出所有的括号组合
判断括号组合是否合法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public boolean isValid(char[] path){ int balance = 0; for (char c: path) { if (c == &amp;#39;(&amp;#39;) { ++balance; } else { --balance; } if (balance &amp;lt; 0) { return false; } } return balance == 0; } 统计出所有的左括号数量,遇到一个右括号就将左括号的数量-1,当左括号的数量小于零时,括号组合不合法,返回false,当统计结束左括号还有剩余,也返回false,除此之外返回true
以上方法亲测可行,但是还可以进一步改进
上面的方法每次添加新括号时,可以进一步筛选,只有当右括号的数量大于等于左括号的数量时,才能继续添加一个右括号,否则右边的括号就不能无脑添加
左括号的数量超过整体数量的一半时,左括号也不能添加,所以可以添 …  ]]></content></entry><entry><title>Spring02</title><url>/post/spring02/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag></tags><content type="html"><![CDATA[   👋 spring02
本文主要介绍如何使用IOC和DI管理Bean，并且了解什么是spring中的注解开发，最后将mybatis和junit整合到spring中
IOC/DI配置管理第三方bean前面所讲的知识点都是基于我们自己写的类，现在如果有需求让我们去管理第三方jar包中的类，该如何管理?
案例:数据源对象管理在这一节中，我们将通过一个案例来学习下对于第三方bean该如何进行配置管理。
以后我们会用到很多第三方的bean,本次案例将使用咱们前面提到过的数据源Druid(德鲁伊)和C3P0来配置学习下。
环境准备学习之前，先来准备下案例环境:
创建一个Maven项目
pom.xml添加依赖
1 2 3 4 5 6 7 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.10.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; resources下添加spring的配置文件applicationContext.xml
1 2 3 4 5 6 7 8 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; &amp;lt;/beans&amp;gt; 编写一个运行类App
1 2 3 4 5 public class App { …  ]]></content></entry><entry><title>208.实现前缀树</title><url>/post/208.%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🌴 208.实现前缀树
Trie
（发音类似 &amp;amp;ldquo;try&amp;amp;rdquo;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
请你实现 Trie 类：
Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 思路
基本思想
前缀树也是一种树,只是树中的节点代表单词的一个字符,所以也称为字典树,每一个节点都有26个孩子节点,只是部分孩子节点才有值,由此形成了一个前缀树,也就是说,节点之间的连接完全可以使用一个数组来记录,26个元素的数组就可以记录节点之间的连接关系,对于单词cat来说,形成的前缀树如下:
其中c的下一个字符是a,所以c对应的26个分支中,只有a这一个分支不为空,由于节点的下一个位置还是节点,所以存储下一位置的数组的类型就是节点的类型,这里可以类比链表的next指针的类型就是节点自身的类型
知道了前缀树的基本原理之后,就是形成前缀树了,每一个前缀树都有一个root根节点,根节点也有26个分支,所以在空的前缀树中插入一个单词可以从根节点出发,每次遍历单词中的一个字符,形成一个新节点,后续再插入单词时,部分字符有可能就不用插入了,因为部分单词的前缀相同,所以在前缀树中共用一部分树的节点,例如apple和app
所以插入时需要判断,例如插入a时需要判断,长度为26的数组的a字符所对应的位置是不是空,不是空就直接使用,是空需要创建新的节点,插入到这个位置,当单词插入完成之后,需要将单词的尾部做一个标记,说明这个单词已经到头了
核心就是节点之间的连接使用一个数组,数组的元素类型就是节点的类型
1 2 3 4 class TrieNode{ public TrieNode[] children=new TrieNode[26]; public boolean …</content></entry><entry><title>207.课程表</title><url>/post/207.%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🧑‍💻 207.课程表
你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
思路
基本思想
这是一道典型的拓扑排序的题目,给定的所有课程的选择,有先修课程的概念,必须先选择先修课程,才能选择接下来的课程,这种结构可以看成是一种图,最开始的先修课程可以看成入度为零的节点,先修课程修完之后,从这个图中拿掉之后,又会出现新的入度为零的节点,也就是下一步可以修的课程
在图中来看,程序设计和高等数学就是是最开始的先修课程,入度为零,修完他们之后,将其从图中拿掉,又会出现新的入度为零的课程,也就是普通物理,离散数学,算法语言,就这样修完一门拿掉一门,不断地出现入度为零的节点,就这样一直拿,一直修改
最终可以形成一个图的拓扑排序,长度是图中所有节点的数量,本题中不要求将全部的拓扑排序求出来,只需要修够规定的课程数即可
拓扑排序的思想就是,整理得到课程图的信息,一个出发点对应很多到达点,所以对于一个出发点而言,需要一个容器存储所有的到达点,故需要容器的嵌套
从给定的所有课程的信息中获得所有边的信息,之后获得所有入度点的信息,下一步就是正常的拓扑排序,先找出所有的入度为零的节点加入队列中,之后讲这些节点标记为已修完,从而这些节点的到达点的入度会减一,当出现新的入度为零的节点时,将其加入队列中
重复上述操作,当队列中没有节点时,说明拓扑排序完成,若此时拓扑排序形成的结果长度刚好是图中节点的长度,说明拓扑排序完成,可以完成选修
重点就是入度为零的节点才能选修,选修之后,对应的到达点入度减一,从而判断是否有新的入度为零的节点出现
执行流程
初始化容器,包括所有的节点及其对应的到达点的容器,以及所有节点的入度情况 将初始状态下所有入度为零的节点加入队列中,从而将他们的到达节点的入度减一 判断是不是有新的入度为零的节点出现,将新节点加入队列中 判断拓扑排序中是不是包含 …</content></entry><entry><title>994.腐烂的橘子</title><url>/post/994.%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🍊 994.腐烂的橘子
在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：
值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。
返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。
思路基本思想读完题之后,知道题目大致的流程是每一轮都是当前的橘子感染新的橘子,下一轮由新感染的橘子去继续感染得到更下一轮中的新感染橘子,相当于一个蔓延的过程,如果蔓延到最后,无法感染新橘子,还有新鲜橘子的话,返回-1,如果没有新鲜橘子的话,就返回感染了几轮
这样描述下来就是一个广度优先遍历的过程,也可以理解为树的层次遍历,但是树的层次遍历最开始只从一个根节点出发,这里相当于有多个&amp;quot;根节点&amp;quot;,此时还是一样的逻辑,只是在&amp;quot;层次遍历之前&amp;quot;,需要将所有的&amp;quot;根节点入队&amp;quot;,增加了这样一步之后得到了多源广度优先遍历
需要注意的是,每次感染之后,需要将新鲜橘子的数量减一,并且这个新鲜橘子标记为被感染,入队之后下一轮从这些新感染的橘子出发进行蔓延
从图中可以看出,第一轮只蔓延了{[1,0],[0,1]}这两个橘子,第二轮从这两个新感染的橘子出发,感染了{[0,2],[1,1]}两个橘子,第三轮从这两个新感染的橘子出发,感染了{[2,1]}这个橘子,最后一轮感染了{[2,2]}这个橘子,至此所有的橘子都被感染完成,相当于没有新鲜橘子了,返回感染的轮次
执行流程广度优先遍历之前增加一步,找到所有的&amp;quot;根节点&amp;quot; 按照广度优先遍历的方式,一层一层的遍历 统计遍历的层数 遍历到最后没有新鲜橘子或者无法感染新鲜橘子就返回结果 代码根据以上描述,得出以下代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public int orangesRotting(int[][] …  ]]></content></entry><entry><title>236.二叉树的最近公共祖先</title><url>/post/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🍇 236.二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科
中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
思路
基本思想
为了找到两个节点的最近公共祖先,需要选择一个遍历方式,此处选择后序遍历,这是因为后序遍历的遍历顺序为左右根,也就是自底向上遍历,这样遇到的第一个祖先就是最近的公共祖先
最近公共祖先的状态右两种:
p和q分别位于这个公共祖先两边,此时这个节点就是公共祖先 p或者q就是另外一个节点的祖先,此时p或者q就是公共祖先 相当于要么位于两侧,要么位于一条路径上,第一种情况在图中就是假设p是6,q是2,此时5
就是最近的公共祖先,第二种情况在图中就是假设p为5,q为6,那么p就是最近的公共祖先
此时后序遍历一旦遇到p或者q亦或者空,就立即返回,向上返回时,一旦某个节点的左或者右有返回值,说明遇到了p或者q亦或者空,当返回值不为空时需要进行判断将其分成两种情况:
左右都不为空,由于是后序遍历,此时说明当前节点就是遇到的最近的公共祖先,直接返回当前节点 左右有一个为空,此时说明不为空的一边遇到了p或者q,此时直接返回原值,也就是不为空的返回值 总结起来就是一旦遇到了p或者q就提前返回,一层一层向上,到了根节点就会退出遍历,此时记录的值就是最近的公共祖先
拿图中举例,假设p是6,q是4,此时后序遍历先遍历左边,一路向下遇到了p,也就是6,此时就提前结束左边的遍历,向上返回,返回到5时,左侧不为空,右侧向下遍历遇到q时一层一层向上返回原值,直到5这个节点,此时由于左右都不为空,向上返回5,到了根节点结束遍历,返回最终的结果5
执行流程
正常的后序遍历
在遇到空返回的条件上加上遇到p或者q也返回
一旦当前节点的左或者右不为空,此时分为两种情况
只有一侧不为空,原值向上返回 两侧都不为空,返回当前节点 到了根节点退出遍历,返回最终的结果
代码
根据以上分析,得出以下代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, …</content></entry><entry><title>Spring01</title><url>/post/spring01/</url><categories><category>学习笔记</category></categories><tags><tag>spring</tag></tags><content type="html"> 🦳 spring01
主要介绍了spring的基础知识，包括IOC控制反转和DI依赖注入
Spring相关概念
初识Spring
在这一节，主要通过以下两个点来了解下Spring:
Spring家族
官网：https://spring.io，从官网我们可以大概了解到：
Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。 Spring并不是单一的一个技术，而是一个大家族，可以从官网的Projects中查看其包含的所有技术。 Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。
Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。
Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫全家桶，如下图所示
说明:
图中的图标都代表什么含义，可以进入https://spring.io/projects网站进行对比查看。
这些技术并不是所有的都需要学习，额外需要重点关注Spring Framework、SpringBoot和SpringCloud:
Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。 SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。 SpringCloud:这个是用来做分布式之微服务架构的相关开发。 除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData,SpringSecurity等，这些都可以被应用在我们的项目中。我们今天所学习的Spring其实指的是Spring Framework。
了解Spring发展史
接下来我们介绍下Spring Framework这个技术是如何来的呢?
Spring发展史
IBM(IT公司-国际商业机器公司)在1997年提出了EJB思想,早期的JAVAEE开发大都基于该思想。 Rod Johnson(Java和J2EE开发领域的专家)在2002年出版的Expert One-on-One J2EE Design and Development,书中有阐述在开发中使用EJB该如何做。 …</content></entry><entry><title>124.二叉树中的最大路径和</title><url>/post/124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🍃 124.二叉树中的最大路径和
二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。
思路基本思想为了得到最大的路径和,每一个节点都需要形成最大的路径和,最大的路径和可能出现在遍历的过程中,也就是最大路径不一定包含根节点,这里利用了贪心的思想
对于当前节点来说,如果最大路径包含当前节点,分为两种情况:
以当前节点为节点向两边出发形成一条最长路径
此时当前节点可以加上左右两边的节点的最长路径和
当前节点和上层节点在一起形成一条最长路径
此时当前节点向上返回时只能挑选较大的一侧返回
路径是一条线,不能出现在一个节点有两个分叉的情况,所以当前节点在向上返回时只能返回左右节点加上当前节点中的一条较大路径,只是在返回的途中由于当前节点将左右节点连接在一起形成了最大路径,从而临时的判断是不是出现了最大路径,返回时还是只能返回一侧
总结起来就是在向上返回较大的一侧时,临时判断当前节点+左右两侧的值是不是形成了最大的路径和
执行流程前序遍历正常执行 判断左右两侧的和与0谁大就保留谁,防止出现返回负数的情况,负数对最大路径和无法起到增益效果 临时判断当前节点+左右两侧节点是不是形成了最大路径和 正常向上返回一侧节点,与上层节点拼接在一起形成路径 遍历完成之后,全局变量res保存了最大路径和 代码根据以上分析,得出以下代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: //对于每一个节点来说,都有一个当前的最大路径和 //并且对于一个节点来说,向上返回时,只能返回左右一边,不然不能形成路径 int res=INT_MIN; int maxPathSum(TreeNode* root) { help(root); return res; } int help(TreeNode* root){ if(root==nullptr) return 0; //对于当前节点来说,当前节点的最大值是左右两边的最大值+当前值 //返回时只能挑选左右两边较大的返回才能和上层拼接在一起形成一条路径 int left=max(0,help(root-&gt;left)); int right=max(0,help(root-&gt;right)); //临时判断当前节点加上左右子树是不是形成了最大路径和 res=max(res,left+right+root-&gt;val); //正常返回 return max(left,right)+root-&gt;val; } }; 总结正常向上层返回一侧数据,防止路径出现分叉,返回的途中临时判断当前节点+左右两侧节点是不是形成了最大路径和,每个节点返回之前都临时判断一下,遍历结束之后,全局变量保存了最大路径和
  ]]></content></entry><entry><title>114.二叉树展开为链表</title><url>/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🌳 114.二叉树展开为链表
给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历顺序相同。 思路基本思想为了实现将二叉树转换成一个前序遍历的链表,需要在遍历到一个节点的时候,将这个节点的右指针指向前序遍历的前一个节点,如果直接在前序遍历时将当前节点的右指针指向前一个节点,也就是根左右的遍历顺序时将右指针指向前一个节点,会导致右子树断链找不到的情况
所以在使用当前节点的右指针之前,需要确保当前节点的右子树已经被访问,三个遍历中没有一个遍历是这样的,所以需要改造遍历的方法
为了不让右子树断链,需要最开始就先访问右子树,又为了形成根左右这种前序遍历的链表结构,加上当前节点的左指针需要清空.需要形成右左根的遍历顺序,这样遍历到左节点时,右节点已经被访问过了,直接将使用右指针也不会出现问题,所以改造出了一个新的遍历方法
执行流程先遍历右节点 再遍历左节点 最后根节点需要将右指针指向当前节点的前一个节点,然后左指针清空 再遍历右左根顺序的下一个节点时,需要记住上一个节点 代码根据以上分析,得出以下代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: //形成自己的遍历顺序:右左根 TreeNode *pre=nullptr; void flatten(TreeNode* root) { reinorder(root); } //逆前序遍历即可 void reinorder(TreeNode* root){ if(root==nullptr) return; //右左根的访问形式 reinorder(root-&gt;right); reinorder(root-&gt;left); root-&gt;right=pre; root-&gt;left=nullptr; pre=root; } }; 总结为了当前节点的右指针指向前序遍历中的前一个节点,并且左指针指向空,需要最先访问右节点,再访问左节点,最后访问根节点,形成右左根的访问顺序,相当于逆向的前序遍历,这样遍历到左的时候,左的右指针指向前一个节点,左指针清空就可以满足要求
  ]]></content></entry><entry><title>25.k个一组翻转链表</title><url>/post/25.k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🍍 25.k个一组翻转链表
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
注意，不足k个的链表不能翻转，也就是上面的[4,5]不能翻转
思路
基本思想
为了将链表中的节点k个一组进行翻转，同时不足k个的链表不能翻转，需要将链表中的节点进行分组，为了统一，先将不足k个的节点也翻转，之后如果判断出当前链表不足k个，那么就再翻转回来即可，翻转两次还是回到原来的形状
每形成一个翻转小链表，就将头结点保存到一个容器中，所有的节点翻转结束之后，将这些小链表合并成一个大链表
为了分组，需要记录当前遍历到了哪个节点上，一旦当前遍历到了第k个节点，说明形成了一个完整的翻转小链表，此时将这个小链表保存到容器中，同时重新开始翻转，翻转时使用了一个虚拟头结点，可以很好的记录当前翻转小链表的头结点
之后单独处理最后一个小链表，如果最后一个小链表的节点个数不足k个，那么就不能翻转，此时需要将其翻转回来
处理完所有的小链表之后，将其拼接在一起即可
执行流程
使用头插法进行链表翻转，虚拟头结点做辅助 当形成k个节点的翻转小链表之后，将其保存到容器中，之后清空虚拟头结点，重新开始翻转 所有的节点翻转完毕之后，需要单独处理最后一个小链表 如果最后一个小链表不足k个，就不能翻转，需要还原（再翻转一次） 如果最后一个小链表刚好k个，那么就可以翻转 之后将一个个的游离的小链表合并起来，返回最终的答案 代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Solution { public: //每次取k个进行翻转，之后将翻转之后的小链表进行合并 //长度不足k的链表不进行翻转 ListNode* …</content></entry><entry><title>2.两数相加</title><url>/post/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   2.两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
思路基本思想主要是模拟相加的过程，需要考虑进位，基本上使用了暴力法，从头开始遍历两个链表，两个节点相加，余10是当前位的结果，除10是下一位的进位，知道这些之后，就是代码的模拟，需要注意当前位相加得到结果之前，需要现将上一位的进位取出来，否则会出现覆盖的情况，在代码中为：
1 2 3 4 num=l1-&gt;val+l2-&gt;val; //相加之后是否需要进位 res[index]=(num+res[index])%10; res[index+1]=(num+res[index])/10; 这种代码就会将当前位的进位抹去，导致第四行的结果出错
执行流程从头开始遍历两个链表 将两个链表的节点值相加，再加上进位，余10得到当前位的结果，除10得到下一位的结果 重复上一步，直到某一个链表到了结尾 剩下的链表如果没到尾部，需要继续累加获得结果 返回最终的结果 代码根据以上分析，得到以下结果：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public: //从低位开始加，然后出现进位就向高位进位 ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { vector&lt;int&gt; res(101,0); int index=0,num=0; while(l1!=nullptr&amp;&amp;l2!=nullptr){ //需要先考虑进位，否则真正的进位会被覆盖 num=l1-&gt;val+l2-&gt;val+res[index]; //相加之后是否需要进位 res[index]=(num)%10; res[index+1]=(int)(num)/10; index++; l1=l1-&gt;next; l2=l2-&gt;next; } //到了这里由于节点的范围不超过9，所以直接拿出来即可 while(l1!=nullptr){ num=l1-&gt;val+res[index]; res[index]=(num)%10; res[index+1]=(num)/10; index++; l1=l1-&gt;next; } while(l2!=nullptr){ num=l2-&gt;val+res[index]; res[index]=(num)%10; res[index+1]=(num)/10; index++; l2=l2-&gt;next; } index=res[index]==0?index:index+1; res.resize(index); //到这里加法统计结束,需要形成链表 ListNode* dummyHead=new ListNode(0); ListNode* node=dummyHead; for(auto val:res){ ListNode* temp=new ListNode(val); node-&gt;next=temp; node=node-&gt;next; } node-&gt;next=nullptr; return dummyHead-&gt;next; } }; 总结就是简单的代码模拟，主要是要考虑进位
  ]]></content></entry><entry><title>148.排序链表</title><url>/post/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🧭 148.排序链表
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
思路基本思想为了给链表排序，最简单的办法就是将链表转化成数组，之后应用容器自带的排序规则排序，之后再转回链表，就是一个暴力模拟的过程，代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: ListNode* sortList(ListNode* head) { vector&amp;lt;int&amp;gt; temp; while(head!=nullptr){ temp.push_back(head-&amp;gt;val); head=head-&amp;gt;next; } sort(temp.begin(),temp.end()); ListNode* dummyHead=new ListNode(0); ListNode* res=dummyHead; for(auto val:temp){ ListNode* node=new ListNode(val); res-&amp;gt;next=node; res=res-&amp;gt;next; } res-&amp;gt;next=nullptr; return dummyHead-&amp;gt;next; } }; 但是这种方法的时间复杂度太高。于是想到了拆分在合并的思想，现将链表拆分成一个一个的单节点，之后将单节点两两合并，这用到了二分法和归并的思想，先使用二分法将链表拆分成一半一半的，一直递归的拆分，当拆分成单节点之后，开始合并
合并的时候是在回溯的时候，每次取左右两个链表依次合并形成更大的链表，之后返回上一层时，形成的链表是一个有序的，这样一层一层向上，最终得到一个完整的排序链表
这种将问题划分的思路称为分治法，将大问题拆分成小问题，当成为单独的问题时就开始向上回溯，在回溯的过程中从小问题的答案组合得到大问题的答案，类似的题目有：
108.将有序数组转换为二叉搜索树148.排序链表427.建立四叉树23.合并K个升序链表执行流程递归将当前链表划分成两半（使用快慢指针的思想划分） 当节点是一个单节点时返回 整个链表的节点都变成单节点之后开始回溯 回溯的过程中进行链表的有序合并 形成更大的链表之后向上层返回 代码根据以上分析，得出以下 …  ]]></content></entry><entry><title>Tcp Ip网络编程</title><url>/post/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url><categories><category>学习笔记</category></categories><tags><tag>linux</tag><tag>服务器</tag><tag>项目</tag></tags><content type="html"><![CDATA[   🎡 tcp-ip网络编程
本文是阅读《TCP/IP网络编程》时所记录的学习笔记，参考了一个github仓库，并在此基础上增加了自己的理解，做了相应的补充，重点放在了linux的部分，windows的部分只做了部分补充
理解网络编程和套接字本章代码，在TCP-IP-NetworkNote中可以找到，直接点连接可能进不去。
本章主要介绍网络编程的基本步骤
理解网络编程和套接字构建打电话套接字以电话机打电话的方式来理解套接字。
调用 socket 函数（安装电话机）时进行的对话：
问：接电话需要准备什么？
答：当然是电话机。
有了电话机才能安装电话，于是就要准备一个电话机，下面函数相当于电话机的套接字。可以指定套接字的属性，便于后期通信
1 2 3 #include &amp;lt;sys/socket.h&amp;gt; int socket(int domain, int type, int protocol); //成功时返回文件描述符，失败时返回-1 调用 bind 函数（分配电话号码）时进行的对话：
问：请问我的电话号码是多少
答：我的电话号码是123-1234
套接字同样如此。就想给电话机分配电话号码一样，利用以下函数给创建好的套接字分配地址信息（IP地址和端口号）：
1 2 3 #include &amp;lt;sys/socket.h&amp;gt; int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen); //成功时返回0，失败时返回-1 调用 bind 函数给套接字分配地址之后，就基本完成了所有的准备工作。接下来是需要连接电话线并等待来电。
bind函数需要转型，因为bind函数需要的是sockaddr结构体，但是结构体中是一个指针数组不好填充，所以先使用一个sockadrd_in结构体将各种属性填充好之后，做转型
调用 listen 函数（连接电话线）时进行的对话：
问：已架设完电话机后是否只需链接电话线？
答：对，只需要连接就能接听电话。
一连接电话线，电话机就可以转换为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接受连接状态。
1 2 3 #include &amp;lt;sys/socket.h&amp;gt; int listen(int sockfd, int …  ]]></content></entry><entry><title>238.除自身以外数组的乘积</title><url>/post/238.%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   238.除自身以外数组的乘积
给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。
请**不要使用除法，**且在 O(*n*) 时间复杂度内完成此题。
思路基本思想为了计算除自身以外的乘积且不能使用除法，所以需要想出其他的办法，可以看出，当前位置的结果与两侧的乘积有关，我们只需要将两侧的乘积分别统计出来记录到L和R中，最后当前位置i的结果等于L[i]*R[i]，统计时需要注意，统计L时，L[i]=L[i-1]*nums[i]，所以需要注意最左边的情况，同理统计R时需要注意最右边的情况
统计出两个辅助数组之后，就可以再经过一次统计得到最终的结果
上面的方法时间复杂度和空间复杂度都是O(N)，为了进一步减小空间复杂度，可以使用结果容器保存L或者R的内容，然后使用一个变量统计另外一个的内容，从而减小空间复杂度
不管如何L[i]代表第i个元素的左边的所有元素的乘积，包含第i个元素，R[i]同理
执行流程统计当前元素的两边的元素乘积 计算除本身的其余元素乘积 返回结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: //不能使用除法，否则直接将整体乘积求出来，之后除以每一个元素 //且只能一次遍历 vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; res(nums.size(),1); //res[i]代表第i个位置的右边所有元素乘积，包含第i个元素 res[nums.size()-1]=nums[nums.size()-1]; //使用res保存右边的乘积结果 for(int i=nums.size()-2;i&gt;=0;--i){ res[i]=nums[i]*res[i+1]; } int L=1; for(int i=0;i&lt;nums.size();++i){ if(i==0){ res[i]=res[i+1]; L=L*nums[i]; } else if(i==nums.size()-1) res[i]=L; else{ res[i]=res[i+1]*L; L=L*nums[i]; } } return res; } }; 总结善于将问题拆分，从而当前元素的结果等于左右所有元素的乘积，所以需要将左右元素的乘积求出来，用两个容器存储这些辅助元素，进一步为了减小空间复杂度，从而可以使用结果容器保存左边或者右边的辅助元素，从而另一边的辅助元素需要使用一个变量存储
当结果容器存放的是左边的辅助元素，那么就需要从尾部进行更新，从头更新会将辅助元素覆盖，当结果容器存放的是右边的辅助元素，那么就需要从头开始更新
核心就是当前元素的结果等于左右两边的元素乘积，之后结果容器保存辅助元素时，不能将没用过的辅助元素覆盖
  ]]></content></entry><entry><title>239.滑动窗口最大值</title><url>/post/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🛴 239.滑动窗口最大值
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回 滑动窗口中的最大值 。
思路基本思想本题求的是一个窗口中的最大值，并且窗口元素还会滑动，每滑动一次都需要重新计算窗口中元素的最大值，从而将最终得到的结果存放到一个容器中，最先想到的办法就是依次遍历，左侧出一个元素，右侧进一个元素，每形成一个新的滑动窗口，都需要遍历一遍滑动窗口中的元素找到最大值，耗时的步骤就是在这里
为了减小时间开销，定义一个双端队列，并且保持对头元素一直是当前窗口中的最大值，为了保持这个性质，对头的元素一定是当前窗口中最大的，因为对于一个窗口来说，我们只关注最大值，所以比最大值小的元素都没有用，在遍历的过程中就可以舍弃，保持双端队列的递减即可
每当元素入队列时，都需要保持这个递减的关系（非递增），当当前元素等于当前对头元素，说明当前窗口需要滑动，最大值需要更新，而双端队列中存储的递减元素就是每一个窗口中递减排序的元素，删除对头元素之后，下一个滑动窗口的最大值还是在新队头
一定要理解上面这段话，使用的是双端队列来解题
当当前元素等于对头元素时，说明当前窗口已满，对头元素不再是当前窗口中的最大值，此时对头元素需要删除，但是由于对头元素后面的元素都尽可能的保持最大，所以对头元素出对后，新的对头元素还是当前窗口的最大值
最终形成的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: //不是求滑动窗口中的和最大值，而是求每一个滑动窗口中的元素最大值 //暴力法是针对每一个窗口都从头筛选一遍 //保持对头始终是最大的元素 vector&amp;lt;int&amp;gt; maxSlidingWindow(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { vector&amp;lt;int&amp;gt; res; //判断极端情况 if(nums.size()&amp;lt;k||k==0) return res; //先累计一个滑动窗口，之后进一个出一个，每次 …  ]]></content></entry><entry><title>560.和为k的子数组</title><url>/post/560.%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🦺 560.和为k的子数组
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。
子数组是数组中元素的连续非空序列。
思路基本思想为了找出所有和为k的连续子数组，可以依次从每一个元素出发， 依次累加之后的元素，一旦能够形成一个k，当前子数组就能符合要求，并且当前子数组符合要求之后，还需要继续遍历，否则会漏掉情况，例如数组为[1,1,,-1,1]，k=2，那么子数组[1,1]符合要求，且[1,1,-1,1]也符合要求
这样从每一个元素出发搜索的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: //可以尝试滑动窗口 int subarraySum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { //暴力法,会超时 //从每个数出发，从而找出所有的和为k的组合 int res=0; for(int i=0;i&amp;lt;nums.size();++i){ int sum=0; for(int j=i;j&amp;lt;nums.size();++j){ sum+=nums[j]; //一旦能够形成一个合法的子数组就记录 if(sum==k) res+=1; } } return res; } }; 但是这样做会超时，因为时间复杂度为O(N)，所以需要找到另外的办法
超时的原因是因为从每一个元素出发，都需要遍历所有的求和结果，才知道当前元素出发的子数组中有哪些是合法的，这是需要改进的点
定义 pre[i] 为 [0..i] 里所有数的和，也就是范围[0&amp;hellip;i]中所有元素相加的结果是pre[i],而且per[i]可以由pre[i-1]推导得到： $$ pre[i]=pre[i-1]+nums[i] $$ 所以当范围[i,j]中的元素相加为k时，可以表示为： $$ pre[j]-pre[i]=k $$ 进一步当当前元素总和为sum时，我们只需要判断有多少子数组的和为sum-k,这样两个子数组相减的结果就可以累加到最终的结果中
核心就是一旦当前元素的累加和为sum，前面存在子数组相加的和为sum-k，那么中间的差距就形成了和为k的子数组
为了能够找到有多少个子数组能够形成和为sum的情况，需要 …  ]]></content></entry><entry><title>438.找到字符串中所有字母异位词</title><url>/post/438.%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🗺 438.找到字符串中所有字母异位词
给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。
思路基本思想为了找出所有的字母异位词，需要从s的头部开始遍历，每次都取出p长度的子串，判断是不是字母异位词，代码很好写，但是第一版代码超时了
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: //滑动窗口中保持与p一样的大小 //进一个出一个，每个滑动窗口都判断是不是p的字母异位词 //由于会重复 vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { //保存所有字母异位词的起始下标 vector&amp;lt;int&amp;gt; res; if(s.size()&amp;lt;p.size()) return res; //从头开始，看每一个子串是不是异位词 for(int i=0;i&amp;lt;=s.size()-p.size();++i){ if(isSame(s.substr(i,p.size()),p)) res.push_back(i); } return res; } //超时主要是这里判断字母异位词时 //判断是不是异位词 bool isSame(string str1,string str2){ unordered_map&amp;lt;char,int&amp;gt; umap; for(auto c:str1){ umap[c]+=1; } for(auto c:str2){ if(umap[c]&amp;gt;0) umap[c]-=1; else return false; } return true; } }; 原因就是在字母异位词的判断每次都需要从头开始判断，所以防止超时的办法就是改进判断字母异位词的方法，可以看到，上一个子串和下一个子串之间只是删除了最左边的元素，最右边新来一个元素，中间的部分都是重复的，没有必要重复统计，并且判断字母异位词的办法有很多。排序之后看是否相等，字符数量是否相等都可以
这里采用统计字符数量的办法，这样中间 …  ]]></content></entry><entry><title>3.无重复字符的最长子串</title><url>/post/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🌍 3.无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
思路基本思想子串是连续的子串，也就是说不能删除元素，如果可以删除元素的话，直接使用回溯法遍历得到幂集，然后找幂集中最长的不重复子串即可
这里需要找到最长的不重复连续子串，可以考虑使用滑动窗口，因为这里求的是一个连续的序列，当滑动窗口中出现了重复的元素，就从左边开始删除，直到删除到滑动窗口中没有重复的元素为止，为了尽可能快的找到滑动窗口中是否存在当前元素，也就是出现了重复，可以使用unordered_set来记录当前滑动窗口中有哪些元素
从左边删除是因为需要连续的子串，左边的元素已经遍历过了
核心的思想就是滑动窗口中保留的用元素不重复的子串，这样每新来一个元素，就可以判断新的滑动窗口中的子串是不是最长的
执行流程遍历字符串 滑动窗口中出现与当前的元素相同的重复元素，就将左边的元素删除，直到没有重复的元素出现 将当前的元素加入滑动窗口，保持滑动窗口的连续性 每次都判断是不是最长的连续子序列 返回结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: //滑动窗口直接解决问题 int lengthOfLongestSubstring(string s) { //unordered_set当成一个滑动窗口 unordered_set&lt;char&gt; uset; int left=0; int res=0; for(int i=0;i&lt;s.size();++i){ //当前元素在当前窗口中重复出现，需要删除到没有重复元素为止 //删除的是最左边的元素 while(uset.find(s[i])!=uset.end()){ //从左边删除元素 uset.erase(s[left]); left++; } //到这里滑动窗口中没有重复元素,将当前的新元素加入 uset.insert(s[i]); res=res&gt;uset.size()?res:uset.size(); } return res; } }; 总结核心就在保持滑动窗口的性质，从左边删除
  ]]></content></entry><entry><title>11.盛最多水的容器</title><url>/post/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🥣 11.盛最多水的容器
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
**说明：**你不能倾斜容器。
思路基本思想为了可以盛最多的水，也就是尽可能找到最长的底和高，最简单的办法就是使用双层for循环，外层for循环找左边界，内层for循环找右边界，形成一个容器就看能盛多少水，是不是能盛的最大水量，具体代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: //尽可能找到最长的底和高，就能接更多的雨水 int maxArea(vector&lt;int&gt;&amp; height) { if(height.size()==0) return 0; int res=0; //先尝试暴力法破解 for(int i=0;i&lt;height.size();++i){ for(int j=i+1;j&lt;height.size();++j){ int len=j-i; int high=min(height[i],height[j]); res=max(res,len*high); } } return res; } }; 但是上面的方法超时了，所以提出了另一种思路（双指针），但是不一定能想到。。。
为了盛更多的水，肯定尽可能要扩大容器的宽度和高度，从扩大宽度的角度来说，肯定容器的边界要尽可能选择在两边，从扩大高度的角度来说，肯定容器要尽可能选高的
所以我们从给定的数组两头出发，先计算当前容器的盛水量，然后考虑移动哪一个边界形成一个新的容器，此时容器一般有两种情况，第三种属于特殊情况：
左边界大于右边界 左边界小于右边界 左边界等于右边界 当左边界大于右边界时，我们肯定移动的是右边界，因为右边界是短板，换掉短板才有可能变大，从而使得容器体积变大，如果移动的是左边界，因为移动的是长板，从而只可能使得容器体积变小或者不变，因为即使长板变得更长，但是短板决定了容器的容积，那么何不放手一搏，尝试移动短板呢
当左边界小于右边界时也是一样的逻辑，只有移动短板才有体积变大的希望
而左右边界相等时，移动谁都是一样的，因为二者都可以看作是短板
核心就是一种博弈，只有移动短板才有变大的希望
执行流程从数组的两边出发，计算当前容器的体积 移动短板，看是否有容器变大的希望 当两个指针相遇时结束搜索 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: //尽可能找到最长的底和高，就能接更多的雨水 int maxArea(vector&lt;int&gt;&amp; height) { if(height.size()==0) return 0; int res=0; int left=0,right=height.size()-1; while(left&lt;right){ int len=right-left; int high=min(height[left],height[right]); //看体积是否会变大 res=max(res,len*high); //移动短板 height[left]&lt;height[right]?left++:right--; } return res; } }; 总结主要是博弈的思想，移动短板才有体积变大的希望，希望可以记住这种思想和解题方法。。。。
  ]]></content></entry><entry><title>128.最长连续序列</title><url>/post/128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 📏 128.最长连续序列
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
思路
基本思想
为了求出最长的连续子序列的长度，需要不断的将游离的子序列进行合并，这是一个核心的观点，为了合并游离的子序列，就需要在遍历到一个数时，将左右的可能存在的子序列进行合并
最简单的办法就是对数据进行排序，然后自然就合并了，但是题目要求时间复杂度，故不能合并，所以我们使用unordered_map来存储每一个连续子序列中左右端点以及其子序列的长度，例如[1,2,3,4]这个子序列，就只用存储umap[1]=4,umap[4]=4,中间的元素不用管
之所以只用存储端点的值，是因为一旦再新来一个元素，可以将两边游离的子序列合并，只需要读取这两个子序列端点的值就能知道子序列的长度，例如两个子序列[1,2,3,4]和[6,7,8]，此时元素5到达，可以将这两个子序列合并成[1,2,3,4,5,6,7,8]，合并时只需要读取元素5左右相邻的两个元素就可以得到两个子序列的长度
并且之后尝试合并时，只用尝试合并没有被访问过的元素，被访问过的元素已经尽可能的被合并了，对于只访问没被访问过的元素以及更新时为什么只更新区间端点，有另外一种说法：
(1). 为什么只更新端点? 答：因为中间点会被 if num not in hash_dict: 过滤掉，不会进入下面的逻辑。进入下面的处理逻辑的必然是GAP，如map中已有2,3，5；现在遍历至4才会进入下面的处理逻辑， 此时，left = 2，right = 1，加入4后形成新的连续序列，最大连续长度为4；最后更新的时候，也只需要更新map[2] = 4以及map[5] = 4即可。因为之后，3，4均不会被再次访问，只有当出现1或者6的时候，才会访问map[2]和map[5], 中间的map[2]、map[3]、map[4]永远不会再被访问到。
(2). 为什么 hash_dict[num] = 1 可以随意赋值? 答：诚如评论区的各位同行所言，此处赋值的意义仅在于占位；当map为空加入第一个元素时，left = right = 0，此时，无论给hash_dict[num]赋多少，最后都会被后面的值(hash_dict[num - left] = …</content></entry><entry><title>49.字母异位词分组</title><url>/post/49.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🐹 49.字母异位词分组
思路基本思想为了将所有的字母异位词分组，首先需要能判断两个单词是不是字母异位词，所以需要单独定义一个函数，如果两个单词是字母异位词，才能属于同一组
对于每一个单词，判断已有的结果容器中是不是有字母异位词，只需要将结果容器中每一组的第一个单词拿出来判断即可，因为这一组中全都是字母异位词，如果与第一个单词成为了字母异位词，那么这个单词就可以加入这一组
所以整体的流程就是，针对每一个单词，依次取出结果容器中每一组的第一个进行判断，找到了字母异位词就加入那一组，但是这样会超时，但是代码没错：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public: //将所有的字母异位词保存在一起 vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; //遍历给定的每一个单词，查看是否有已知的字母异位词 for(int i=0;i&amp;lt;strs.size();++i){ //从已有的结果列表中查看属于哪个字母异位词容器 int j=0; for(;j&amp;lt;res.size();++j){ //找到了属于哪一个字母异位词容器，直接break准备插入 if(isSame(strs[i],res[j][0])) break; } //区分是加入新的容器还是旧的容器 if(j==res.size()){ vector&amp;lt;string&amp;gt; temp; temp.push_back(strs[i]); res.push_back(temp); }else{ res[j].push_back(strs[i]); } } return res; } bool isSame(string str1,string str2){ if(str1.size()!=str2.size()) return false; //将第一个字符串转换成一个字典 …  ]]></content></entry><entry><title>127.单词接龙</title><url>/post/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url><categories><category>leetcode</category></categories><tags><tag>图论</tag></tags><content type="html"><![CDATA[   🐉 127.单词接龙
字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk：
每一对相邻的单词只差一个字母。 对于 1 &amp;lt;= i &amp;lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。 sk == endWord 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。
思路基本思想为了从beginWord变换到endWord，需要将每一步的变换都记住，从而从中找到一个最短的变换路径，也就是求图中两个顶点的最短路径问题，如下图所示：
从开始变换到结束有很多条路径，还需要找到最短的路径，所以分成两个任务：
找到所有的路径 从所有的路径中找到最短的 下面是具体的分析思路：
相当于从一个单词到下一个单词， 只能变换一个字母，所以对于一个单词来说，针对单词的每个位置，都可以有26种变换方法，所以对于一个单词来说，一共有word.size()*26种变换方法，所以我们拿到一个单词，需要执行这么多次变化，来看其中的某一种是不是出现在文中所给的字典中，如果出现在所给的字典中，那么说明当前变换有效
当前单词的所有有效变换找到之后，需要将这些有效变换进一步的进行变换，直到其中的某一步找到endWord，或者说所有的变换都找完了。还是没找到endWord，此时说明无法变换到endWord，直接返回0
整体来说，需要从beginWord出发，寻找下一阶段的所有能变换的单词（只差一步的单词），再从下一阶段的所有单词出发，找到更下一阶段的单词，从当前阶段到下一阶段，需要让步数+1，每到达一个新的单词，相当于做了一次变换
我们需要三个容器，一个容器记录当前字典中的单词，使用unordered_set，查询更快，一个容器记录变换路径上的所有单词以及到变换到这个路径需要多少步，所以使用unordered_map，另外一个就是记录当前所有变换的单词，以便下一步取出这些单词中的一个进行进一步的变换
更简单的办法就是利用图 …  ]]></content></entry><entry><title>Jupyter_notebook的使用</title><url>/post/jupyter_notebook%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>教程</category></categories><tags><tag>jupyter</tag></tags><content type="html"> jupyter_notebook的使用
本教程旨在不从零开始搭建一个jupyter notebook的环境并用来学习，默认已经安装了anaconda，可以解决现有的项目导入jupyter notebook中时无法指定conda虚拟环境用来隔离python环境的问题，按照教程操作之后，可以实现一个jupyter notebook对应一个虚拟环境
安装
需要现在虚拟环境中安装jupyter notebook，才能正常使用
创建一个虚拟环境
1 conda create -n d2l python==3.9 此时anaconda的虚拟环境中就带上了这个d2l虚拟环境
打开anaconda的Navigator：
在anaconda的对应的虚拟环境界面中安装jupyter notebook
如果没有安装jupyter notebook，显示的是install，点击install即可安装，此时还无法在已有项目中使用对应的虚拟环境
安装ipykernel
需要先激活对应的虚拟环境
1 2 conda activate d2l conda install ipykernel 安装ipykerbel之后，才能在jupyter notebook中使用虚拟环境，对应的虚拟环境才会显示
此时可以正常在浏览器中使用jupyter notebook并且指定虚拟环境
错误解决
修改项目地址 上面的步骤执行完毕之后，jupyter notebook就可以运行并选择虚拟环境了，可是项目的地址还是在C盘中，此时想要将这个虚拟环境中的jupyter notebook的项目地址改成自己指定的位置，需要进行修改
选择打开对应的jupyter notebook的文件位置，然后修改其属性
右键对应jupyter notebook的属性，将目标中的&amp;amp;quot;%USERPROFILE%/&amp;amp;quot;修改成自己的项目地址，例如：
我修改成了G:\D2L，后面打开jupyter notebook的时候，自动定位到这个项目中，并且可以查询到当前使用的虚拟环境是什么：
Navigator中启动jupyter notebook无法自动弹出浏览器
此时需要修改配置文件
对应虚拟环境中执行下面的代码生成或者覆盖原有的配置文件
1 jupyter notebook --generate-config …</content></entry><entry><title>1020.飞地的数量</title><url>/post/1020.%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</url><categories><category>leetcode</category></categories><tags><tag>图论</tag></tags><content type="html"> 🕹︎ 1020.飞地的数量
给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。
一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。
返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。
思路
基本思想
按照题目的描述，就是求那些陆地不能到达给定的图的边界，而一旦岛屿中的某一个陆地的上下左右的任意一个方向能够到达边界，那么整个岛屿中就没有”飞地“，也就是所有的陆地都能到达边界
所以将岛屿求面积的算法进行简单改进，在求岛屿面积的时候，将返回条件分开，一旦某一个陆地的上下左右四个方向中有一个方向到达边界，那么这整个岛屿都能到达边界，也就是说岛屿中不存在飞地
所以一旦超过边界，就可以返回true，这样一层一层的返回，最终岛屿就会返回true，而遇到了海洋和已遍历过的陆地，就暂时返回false，并且在遍历的过程中还需要统计岛屿的面积，因为一旦岛屿中出现飞地，也就是岛屿中的所有陆地都无法到达边界，最终就会返回false，那么岛屿中飞地的数量就是岛屿的面积
需要注意的是，遍历当前陆地的上下左右四个方向时，需要分开遍历，因为合在一起遍历，一旦出现一个true，岛屿没有遍历结束就会返回，剩下没有遍历的陆地就会被认为是一个新的陆地，可能造成飞地的数量变多，这是c++语法的问题，不是解题思路的问题
执行流程
遍历图中所有的节点，一旦出现陆地就开始统计面积 统计面积时一旦遇到边界，说明这个岛屿能够到达边界，返回true 遇到海洋或者已遍历的陆地时暂时返回false 将当前的陆地标记为已统计，同时岛屿的面积+1 上下左右四个方向分开进行统计，防止程序提前返回 返回四个方向的或，这样一旦出现一个true（能够到达边界），所有的陆地都返回true，最终说明岛屿能够到达边界 如果统计岛屿面积的时候，岛屿无法到边界，也就是返回了false，此时统计飞地的数量，也就是岛屿的面积 返回飞地的数量 代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 …</content></entry><entry><title>827.最大人工岛</title><url>/post/827.%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/</url><categories><category>leetcode</category></categories><tags><tag>图论</tag></tags><content type="html"> 👷 827.最大人工岛
给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。
返回执行此操作后，grid 中最大的岛屿面积是多少？
岛屿 由一组上、下、左、右四个方向相连的 1 形成。
思路
基本思想
为了形成最大人工岛，需要将临近的岛屿合并，合并的规则规定只能将一个海洋变成陆地，所以要尽可能的将临近的岛屿合并，但是找临近的岛屿不好找，于是换一种思路，找海洋的临近岛屿，如果一个海洋旁边（上下左右）有临近岛屿，就可以将岛屿合并，合并之后可能形成最大人岛，重点是合并的逻辑
为了将岛屿合并，需要先计算各个岛屿的面积，计算之后，岛屿中每个陆地都需要进行标记，这样海洋找到了岛屿中的任何一个陆地都可以直接进行合并（面积的相加），所以这个标记需要记住岛屿的面积
如果直接使用面积做标记，那么出现海洋临近同一个岛屿的不同陆地时，就无法区分这两个陆地是来自同一个岛屿的两个陆地还是来自相同面积的两个不同岛屿中的陆地，所以需要使用一个map来记录面积和岛屿编号的映射，这样岛屿是唯一的，一旦海洋接壤一个不同的岛屿就可以通过map查询到面积，从而进行合并
合并时可能出现好几种情况：上和左有不同岛屿，左和下有不同岛屿，下和右有不同岛屿，右和上有不同岛屿，上和左和下有不同岛屿，左和下和右有不同岛屿。。。甚至上下左右都有不同岛屿，所以还需要一个容器来记录那些岛屿被合并过
并且在初始求岛屿面积时，就需要记录最大岛屿的面积，最大岛屿的面积等于最大岛屿本身的面积加上可能存在的一个海洋，因为一旦给定的图中全是陆地，那么此时就不存在海洋，也就不需要合并，这样有两个好处:
当图中全是海洋时，求面积的循环不会执行，无法合并，此时最大陆地就是1，可以提前返回，结束代码 当图中全是陆地时，此时最大人工岛的面积就是最大岛屿的面积，并且不需要合并，此时可以直接返回最大的面积 剩下的就是普通的情况，需要先计算每个岛屿的面积，再看所有的海洋能不能将独立的岛屿进行合并
执行流程
定义求岛屿面积的函数，用来求岛屿的面积
按照常规的思想，求解每个岛屿的面积，并且将岛屿的面积和岛屿的编号进行映射，岛屿中遍历过的陆地全改成当前岛屿的编号，便于后期海洋合并时直接查询到这个岛屿的面积
注意岛屿的编号从2开始，避免出现未遍历的陆地原本编号是1，遍历过后岛屿的编号也是1，无法区分的问题
在求解岛屿面积的同 …</content></entry><entry><title>695.岛屿的最大面积</title><url>/post/695.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url><categories><category>leetcode</category></categories><tags><tag>图论</tag></tags><content type="html"> 👏 695.岛屿的最大面积
给你一个大小为 m x n 的二进制矩阵 grid 。
岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
岛屿的面积是岛上值为 1 的单元格的数目。
计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
思路
基本思想
主要的思想就是遍历整个图，将岛屿找出来，同时需要将岛屿中的面积计算出来，从而找出最大的面积，所以分为以下几步：
找出岛屿：
只需要遵循二叉树的遍历思路，一旦遇到一个陆地，将陆地遍历一下，然后已遍历的陆地进行标记，在该陆地的上下左右找是否存在相邻的陆地，将所有相邻的陆地找出来，才算是形成一个岛屿
计算岛屿的面积：
为了计算面积，岛屿中的一块陆地的面积为1，所以只需要将岛屿中的所有陆地统计出来即可，在遍历岛屿中所有的陆地时，遇到一个没有遍历的陆地，岛屿的面积应该+1，当岛屿中所有的陆地都被访问过之后，就得到了岛屿最终的面积
找出最大的面积：
为了找出最大的面积，每计算出一个面积，都需要判断当前面积是否是最大的，所以需要定义一个全局变量来存储最终的面积
经过以上步骤，就可以得到最终的结果
执行流程
遍历给定的图，出现一块陆地，将其相邻的所有陆地找出来形成一个岛 为了形成一个岛，需要从当前的陆地出发进行遍历，需要借助一个函数 进入当前函数时，如果当前的位置超过范围，或者是海洋，亦或者是已遍历的陆地，直接返回 当当前陆地没有被遍历，那么就需要遍历当前陆地，然后从当前陆地出发，遍历上下所有，查看是否存在陆地 遍历之前需要注意，当前的陆地面积为1，所以岛屿的面积应该+1 遍历结束之后，岛屿的面积统计到了，此时需要判断岛屿的面积是否是全局最大的面积 返回全局最大的面积 代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: int res=0;//如果没法更新，说明没有岛屿，此时返回0 //遇到一个陆地，就将相邻的陆地找出来，遇到一个没遍历过的陆地，面积+1 …</content></entry><entry><title>463.岛屿的周长</title><url>/post/463.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</url><categories><category>leetcode</category></categories><tags><tag>图论</tag></tags><content type="html"><![CDATA[   👦 463.岛屿的周长
给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。
网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
思路基本思想题目中只给出了一个岛屿，需要统计岛屿的周长，需要注意的是，只有遇到边界或者海洋时才需要统计周长，也就是下图中的情况
所以需要对岛屿的遍历问题进行简单的改造，一旦当前位置是海洋或者边界，那么当前位置就会出现一个岛屿的边，此时就会使得周长+1，所以返回时需要对返回的情况加以区分，遇到海洋或者边界时周长+1，此时返回1，遇到已遍历的陆地不需要对周长+1，此时返回0
所以此时岛屿的遍历函数需要有返回值，并且需要统计当前节点的上下左右哪些位置会造成周长+1，将这些情况统计出来，最终就是岛屿的周长
执行流程正常的遍历岛屿，遇到陆地节点就将其相邻的所有陆地找出来，形成一个岛屿 遍历陆地的相邻节点时，有以下几种情况： 当前节点超出边界或者是海洋节点，此时周长需要+1，返回1 当前节点是已经遍历过的节点，此时周长不需要+1，返回0 当前节点遍历过了之后，看上下左右四个方向是否能出现对周长产生增益的节点，也就是海洋或者边界，如果有的话就返回1 统计结束返回最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public: //当前节点是陆地，就有可能需要统计边界 //统计过后将遍历过的节点进行记录 //用来记录周长 int length; int islandPerimeter(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { for(int …  ]]></content></entry><entry><title>200.岛屿数量</title><url>/post/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url><categories><category>leetcode</category></categories><tags><tag>图论</tag></tags><content type="html"><![CDATA[   🏝 200.岛屿数量
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
也就是一旦出现一个陆地，就需要将相邻（上下左右）的陆地全部统计出来，形成一座岛
思路基本思想核心思想就是每次找到一个岛，需要将岛中的所有陆地找出来，标记为遍历过，所以需要使用遍历的方法，遍历的方法与二叉树遍历的方法类似
二叉树遍历时，遇到叶节点需要返回，之后遍历当前节点的两个叶子结点，也可以理解为相邻的两个节点，转换到图的遍历中，超出图的边界需要返回，之后遍历当前节点的四个相邻节点，也就是上下左右的四个节点
在本题中，为了将所有的相邻陆地找出来，所以需要在遇到一个陆地时，需要一直向下遍历，将所有相邻陆地全部遍历一遍，这样才算是将一个岛屿找出来
返回的条件就是遇到了图的边界或者遇到了海洋，此时需要返回
一个陆地的所有相邻陆地全部遍历一遍，才能形成一个完整的岛屿
执行流程遍历一个图 一旦遇到陆地节点，就需要将相邻的陆地全部找出来 遍历时出现已访问过的节点或者越界亦或是海洋节点时返回 当当前节点是陆地节点并且没有被访问过时，需要将当前节点标记为访问过，防止出现重复访问的情况 递归遍历当前节点的相邻节点（上下左右） 一个陆地的所有相邻陆地被访问过，一个岛屿才会形成 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: //什么时候才算是一个完整的岛屿 //将·所有陆地连接在一起，形成一个完整的岛屿 //也就是说，一旦遇到一个陆地，将与其相连的所有陆地统计出来，就可以形成一个岛屿 //统计完所有相邻的陆地，会形成一个岛屿 //再次遇到不相邻的陆地，就会形成新的岛屿 int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int res=0; for(int i=0;i&lt;grid.size();++i){ for(int j=0;j&lt;grid[0].size();++j){ //遇到没有遍历过的陆地，将相邻的所有陆地找出来形成一个岛屿 if(grid[i][j]==&#39;1&#39;){ dfs(grid,i,j); //岛屿数量+1 ++res; } } } //返回最终的结果 return res; } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int x,int y){ if(x&lt;0||y&lt;0||x&gt;=grid.size()||y&gt;=grid[0].size()|| //超过图的边界 grid[x][y]==&#39;0&#39;|| //遇到了海洋 grid[x][y]==&#39;2&#39;) //遇到了遍历过的节点 return; //到这里说明当前位置没有超过边界，也不是海洋，也没有遍历过 grid[x][y]=&#39;2&#39;; //遍历四周相邻节点 dfs(grid,x-1,y); //上 dfs(grid,x+1,y); //下 dfs(grid,x,y-1); //左 dfs(grid,x,y+1); //右 } }; 总结核心就是如何遍历图，参考二叉树的遍历逻辑，并且岛屿形成的标志是所有相邻的陆地全部被访问过后，才能形成完整的岛屿
  ]]></content></entry><entry><title>797.所有可能的路径</title><url>/post/797.%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url><categories><category>leetcode</category></categories><tags><tag>图论</tag></tags><content type="html"><![CDATA[   🚧 797.所有可能的路径
给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）
graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。
示例示例 1：
1 2 3 输入：graph = [[1,2],[3],[3],[]] 输出：[[0,1,3],[0,2,3]] 解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3 示例 2：
1 2 输入：graph = [[4,3,1],[3,2,4],[3],[4],[]] 输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] 第i行的所有元素代表从第i个节点出发，能够到达的所有节点
思路基本思想为了得到所有的路径，势必要进行搜索，从0号节点出发，最终到达n-1号节点就形成了一条路径，相当于是对给定的 二维数组进行遍历
所以使用了回溯的思想，在一层中遍历当前节点能到达的所有节点，选择其中的一个节点到达下一层，从这个新选择的节点出发，有可以到达一些节点，继续选择一个向下一层，最终到达n-1层说明形成了一个完整的路径，此时保存此路径，之后向上回溯，重新选择一个节点
当前层的所有节点遍历完成之后，向上回溯一层，重新选择一个没选择过的节点，然后继续向下，就这样不停地回溯再向下，最终搜索出所有可能的路径
执行流程从节点0出发，遍历其能到达的所有节点 选择其中的一个节点，继续向下 当到达最终的n-1号节点时，形成一个路径 此时向上回溯一层，选择一个新的节点继续向下 就是回溯法的基本逻辑
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: //如何遍历给定的有向无环图，也会形成一个搜索树，一层是对应的一个节点能到达的其所有节点 //一列是从一个节点到另一个节点，就是回溯法的简单改造 vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { //从0节点出发向后遍历，搜索树的第一层就是所有0号节点 path.push_back(0); dfs(graph,0); return res; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph,int node){ //当前形成路径的尾部是最后一个节点，也就是终点 if(node==graph.size()-1){ res.push_back(path); return; } //在本层中遍历当前节点node能到达的所有其他节点 for(int i=0;i&lt;graph[node].size();++i){ //从node出发，到达当前的graph[node][i]节点上，然后继续向下 path.push_back(graph[node][i]); dfs(graph,graph[node][i]); //当前节点遍历完了，从node出发换一个到达节点 path.pop_back(); } } }; 总结  ]]></content></entry><entry><title>925.长按键入</title><url>/post/925.%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🏔 925.长按键入
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。
你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。
思路基本思想主要就是用代码模拟手动匹配的过程
两个位置字符匹配时，一起向后移动 两个位置字符不匹配时，需要去除重复元素 当不匹配位置在开头，此时直接不符合要求，比如aabc和bc 当不匹配位置不在开头，此时需要将重复键入的元素去除 如果重复元素去除之后两个位置不匹配，此时返回false，例如aaabc和ac，在a和c位置不匹配，去除重复元素a之后，又在b和c位置不匹配，此时返回false 如果去除重复元素之后两个位置匹配，此时二者向后移动一位继续匹配 当任有一个字符串匹配结束之后，看另外一个字符串是否匹配完成 当name没有匹配完成，直接返回false，例如aabc和aaab 当typed没有匹配完成时，此时需要分情况讨论 当typed后面的元素全都相等时，返回true，例如aabc和aaabcccc 当typed后面的元素不全都相等时，返回false，例如aabc和aaabcccdc 执行流程执行流程同上
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public: bool isLongPressedName(string name, string typed) { if(typed.size()&lt;name.size()) return false; int i=0,j=0; //依次向后匹配，出现不匹配的元素，尝试将typed中的重复项去除再匹配 while(i&lt;name.size()&amp;&amp;j&lt;typed.size()){ //两个位置的元素匹配 if(name[i]==typed[j]){ ++i; ++j; } //两个位置的元素不匹配 else{ //第一个位置就不匹配，说明不是长按 if(j==0) return false; //去掉长按之后的重复项 while(j&lt;typed.size()&amp;&amp;typed[j]==typed[j-1]){ j++; } //去掉之后相等，需要继续向后匹配 if(name[i]==typed[j]){ ++i; ++j; } //去掉之后不匹配 else return false; } } //结束之后看name和typed是否匹配完毕 //如果name没有被匹配完，说明不是在输入名字 if(i&lt;name.size()) return false; if(j&lt;typed.size()){ while(j&lt;typed.size()){ if(typed[j]!=typed[j-1]) return false; ++j; } } //到这里应该返回true return true; } }; 总结主要是代码模拟匹配的过程，不匹配时需要去除重复键入的元素，返回false的情况分以下几种：
当不匹配位置出现在开头时直接返回false 当去重之后不匹配时也返回false 当其中一个字符串匹配完成且name没有匹配完成时直接返回false 当其中一个字符串匹配完成且typed没有匹配完成并且typed剩下的元素不全都相等时返回false   ]]></content></entry><entry><title>1002.查找共用元素</title><url>/post/1002.%E6%9F%A5%E6%89%BE%E5%85%B1%E7%94%A8%E5%85%83%E7%B4%A0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🏞 1002.查找共用元素
给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。
示例示例 1：
1 2 输入：words = [&amp;#34;bella&amp;#34;,&amp;#34;label&amp;#34;,&amp;#34;roller&amp;#34;] 输出：[&amp;#34;e&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;] 示例 2：
1 2 输入：words = [&amp;#34;cool&amp;#34;,&amp;#34;lock&amp;#34;,&amp;#34;cook&amp;#34;] 输出：[&amp;#34;c&amp;#34;,&amp;#34;o&amp;#34;] 思路基本思想为了找到words中每个单词都出现的字符，需要现将每个单词中的字符出现次数统计出来，最开始的想法是既然查找的是共用字符，那么字符出现的次数至少是words的长度，所以只需要在统计每个单词中字符出现次数时，字符首次出现时才需要统计，最终看哪个字符出现的次数与words的长度相等，但是这样不符合示例1
示例1给出的答案包含两个l，也就是说一个字符在公共字符中可以重复出现，只要他在每个单词中出现的次数都不止一次即可
所以需要更换思路，公共字符出现的次数肯定是所有单词中出现次数最少的，也就是示例2中，第一个单词中o出现两次，第二个单词中o出现一次，第三个单词中o出现两次，最终的结果o只能出现一次
所以以此为突破口，统计出每个单词中字符的出现次数之后，需要与下一个单词进行比较，留下最小的出现次数，遍历结束之后，出现次数不为零的字符就是共用字符
统计出来之后，留下最小值
执行流程遍历words中的所有单词 对于每一个单词统计字符出现的次数 保留当前每个字符出现的最小次数 words遍历结束之后，统计字符出现的次数，字符出现次数不为零，说明其是公共字符 出现次数是几，就需要将其加入到结果容器中几次 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: //有可能某一个字符在words中的每一个单词中都不止出现一次 //所以统计每个单词中字母出现的次 …  ]]></content></entry><entry><title>1207.独一无二的出现次数</title><url>/post/1207.%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🎆 1207.独一无二的出现次数
给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。
如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。
注意是元素出现的次数独一无二，而不是元素独一无二
思路基本思想为了了解每个元素的出现次数是否唯一，首先肯定需要先统计出元素的出现次数，之后在判断元素的次数是否唯一，所以可以分成两步：
统计元素的出现次数，为了将元素与其出现的次数对应，所以需要使用一个unordered_map来统计元素出现的次数 判断元素出现的次数是否唯一，为了判断出现次数是否唯一，需要一个可以快速查询容器中元素是否存在的容器，所以使用unordered_set来判断次数是否唯一 执行流程统计元素出现的次数 将所有出现的次数遍历一遍 如果在容器中已经找到了相同的出现次数，返回false 如果没找到相同的出现次数，此时将这个出现次数记录 继续遍历，直到遍历结束 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: //统计每个数的出现次数是不是独一无二的 //而不是判断每个数是不是独一无二的 bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) { if(arr.size()==1) return true; //使用一个map统计元素出现的次数 unordered_map&lt;int,int&gt; umap; for(auto num:arr){ umap[num]++; } //使用一个set判断出现的次数是否唯一 unordered_set&lt;int&gt; uset; for(auto it=umap.begin();it!=umap.end();++it){ //元素出现的次数不唯一 if(uset.find(it-&gt;second)!=uset.end()) return false; else uset.insert(it-&gt;second); } return true; } }; 总结主要是统计+判断，使用unordered_set来判断元素出现的次数是否唯一
  ]]></content></entry><entry><title>337.打家劫舍III</title><url>/post/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Diii/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🤡 337.打家劫舍III
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。
能够偷盗的房屋形成了一个二叉树
思路基本思想根据题中的描述，能够偷盗的房屋形成了一个二叉树，所以对于二叉树中的每一个节点，只有两种情况，要么偷要么不偷； 如果当前节点偷了，那么当前节点的孩子节点就不能偷，需要从孙子节点开始偷
如果当前节点没偷，那么当前节点的孩子节点就可以偷
从当前节点将遍历的路径分成了两条，两条路径上得到的金额不同，最终从当前节点出发得到的最大金额就是这两条路径得到的金额的较大者
对于程序来说，如果给定的二叉树是空树，此时直接返回0，如果给定的二叉树只有一个节点，那么直接偷，如果给定的二叉树从当前节点开始已经搜索过了，此时直接返回当前的答案供上面的节点使用
整体的遍历逻辑是：从上到下遍历，从下到上返回，最终返回从根节点出发的结果
执行流程如果当前节点为空节点，返回0 如果当前节点没有孩子节点，直接返回当前节点的值 如果当前节点不为空且有孩子节点，且已经统计了从当前节点开始偷盗的结果，那么将当前的结果返回给上层作为参考 如果当前节点出发没有被统计，那么分为两种情况： 当前节点偷，那么下一次偷的只能是孙子节点开始 当前节点不偷，那么下一次偷的就可以是孩子节点开始 返回最终的答案 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: //对于一棵树来说，当前节点只能是偷或者不偷 //下层节点需要参考上层节点是不是偷 //这个res记录了从那个节点开始偷能够获得的最大金额 unordered_map&lt;TreeNode*,int&gt; res; int rob(TreeNode* root) { //第一个代码块 { //确定递归的返回条件 if(root==nullptr) return 0; if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr) return root-&gt;val; } //第二个代码块 { //当前节点被偷过了，直接返回 if(res[root]) return res[root]; //当前节点没被偷过，此时需要分情况讨论 else{ //偷当前节点 int val1=root-&gt;val; if(root-&gt;left!=nullptr) val1+=rob(root-&gt;left-&gt;left)+ rob(root-&gt;left-&gt;right); if(root-&gt;right!=nullptr) val1+=rob(root-&gt;right-&gt;left)+ rob(root-&gt;right-&gt;right); //不偷当前节点 int val2=rob(root-&gt;left)+rob(root-&gt;right); res[root]=max(val1,val2); return res[root]; } } } }; 总结主要是从当前节点出发，分成两种情况，从而形成两种不同的路径，从上到下遍历，从下到上返回结果
  ]]></content></entry><entry><title>17.电话号码的字母组合</title><url>/post/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   ☎ 17.电话号码的字母组合
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
提示：
0 &lt;= digits.length &lt;= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 思路基本思想输入一串数字，对于每一个数字，都对应了不同的字符串，将每个数字对应的不同字符串组合起来，形成不同的组合
如果给定两个数字，那么就可以使用for循环嵌套，一层for循环遍历一个数字对应的字符串，但是一旦数字多了起来，那么for循环也就一层套一层，时间复杂度变得很高，所以考虑使用回溯法解决当前的问题
对于每一个数字来说，其对应的字符串都可以看做是回溯算法中的一层，这样只需要控制当前遍历到哪一个数字，取出当前数字对应的字符串，然后继续下一层遍历，取出下一个数字对应的字符串，每一层都遍历一个数字对应的字符串
所以整体代码的逻辑就是控制start来遍历给定的digits中的每一个数字，对于每一个数字，取出背后对应的字符串来形成不同的组合
将每个数字对应的字符串当成回溯法中的一层
执行流程判断当前是否遍历到了digits的最后一个元素，是的话说明形成了一个新的组合，此时记录当前的组合并且返回 根据记录的下标找到当前需要遍历的数字 根据当前需要遍历的数字找到当前需要遍历的字符串 将字符串的元素依次加入组合中 进行下一层的遍历 start记录的是当前遍历到了digits中的第几个数字
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public: //需要先建立映射关系，然后遍历digits中的每一个元素，将他们对应的string进行组合 //回溯法的一层就是digits中的一个元素 //每一层都遍历digits中的一个元素对应的若干字符 vector&lt;string&gt; res; string path=&#34;&#34;; string letter[10]={ &#34;&#34;, &#34;&#34;, &#34;abc&#34;, &#34;def&#34;, &#34;ghi&#34;, &#34;jkl&#34;, &#34;mno&#34;, &#34;pqrs&#34;, &#34;tuv&#34;, &#34;wxyz&#34; }; vector&lt;string&gt; letterCombinations(string digits) { if(digits.size()==0) return res; backtrack(0,digits); return res; } //start代表遍历到了digits的哪一个元素 void backtrack(int start,string digits){ //一旦遍历到了digits的末尾，说明形成了一个字母组合 if(start==digits.size()){ res.push_back(path); return; } //找到当前需要遍历的数字 int num=digits[start]-&#39;0&#39;; //根据数字找到对应的字符串 string charac=letter[num]; //遍历对应的字符串 for(auto c:charac){ //新形成一个字符串 path.push_back(c); //遍历digits中的下一个数字对应的字符串 backtrack(start+1,digits); path.pop_back(); } } }; 总结需要转换思维，将每个数字对应的字符串当成回溯法中的一层，start记录的是当前遍历到了digits中的第几个元素，其余的与回溯法没有什么区别
  ]]></content></entry><entry><title>77.组合</title><url>/post/77.%E7%BB%84%E5%90%88/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🤏 77.组合
给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。
思路基本思想为了求出所有数的组合，最直接的办法就是for循环，当求两个数的组合时，只需要两层循环，求三个数的组合时需要三层循环，但是一旦组合个数过多，就会导致时间复杂度太高，并且由于组合个数是动态指定的，所以无法固定for循环的层数：
1 2 3 4 5 6 int n = 4; for (int i = 1; i &amp;lt;= n; i++) { for (int j = i + 1; j &amp;lt;= n; j++) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; endl; } } 为了遍历所有的结果，可以采用回溯的办法，每一层都相当与一层for循环，但是采用递归的方式向下遍历，而不是强行for循环嵌套
当前一层遍历[1,n]的数，下一层遍历[2,n]的数，再下一层遍历[3,n]的数，以此类推，每层中选一个数，直接进行下一层的遍历，最后会形成一个搜索树
上一层选取一个数，可以跟下一层的所有元素配对，例如第一层先在[1,n]中选择一个1，这个1就可以和下一层[2,n]中的所有数依次配对，当形成一个个数为k的集合时，说明找到一个结果，此时将当前集合加入结果容器中，删除集合末尾的元素，重新建立新的集合，就这样一直搜索，最终可以搜索出所有的结果
选择范围时可以进行优化，例如集合中共有5个元素，当前已选择3个元素，需要组成3个元素的集合，那么剩下的两个元素无法形成新的3的元素的组合，可以直接不遍历，新的搜索树为：
此时在代码中需要推导出i的变化范围，当集合中剩余元素大于等于所需要元素时，可以正常遍历，集合中的剩余元素可以用n-i表示，所需要的元素可以用k-path.size()来表示，所以只需要符合： $$ n-i&amp;gt;=k-path.size() $$ 也就是： $$ i&amp;lt;=n-(k-path.size())+1 $$ 之所以需要加1是因为容器元素的下标从0开始
如果题目要求元素可以重复选择的组合问题，那么下一层回溯的时候，元素的开始位置可以为i，而不是i+1，但是不能每次都从0开始，这样会导致之前遍历过的元素被重复选取，出现很多重复的组合
组合问题分为好几种： …  ]]></content></entry><entry><title>236.二叉树的公共祖先</title><url>/post/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🦧 236.二叉树的公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
思路基本思想为了求两个节点的公共祖先，手工求解直接自底向上，遇到第一个交叉的节点就是两个节点的公共祖先，代码中为了模拟这种自底向上的流程，需要使用后序遍历
公共祖先出现的位置一共有三种情况：
二叉树为空，没有公共祖先 公共祖先是p或者q 公共祖先不是p也不是q 所以在后序遍历的过程中，遇到了p或者q，可以直接返回
也就是当前节点如果是p或者q亦或者是nullptr，则直接返回当前节点
然后在左右子树中搜索公共祖先，此时右两种情况：
左右子树都不为空，代表左右子树中遇到了p和q，相当于当前节点就是p和q的公共祖先
也就是p和q分布在当前节点的左右子树中，因为左右子树中遇到饿了p和q才会返回不为空的结果
左右子树任有一个为空，此时说明p或者q就是当前节点的公共祖先，因为左右子树遇到p或者q亦或者nullptr才会返回，如果任有一个为空，说明p和q都出现在当前节点的一侧，此时只需要返回p或者q即可
当遍历的过程中遇到了p或者q亦或者nullptr时，提前结束后序遍历
执行流程后序遍历二叉树
遇到p或者q亦或者nullptr就返回
当前节点的左右子树返回值都不为空，说明q和p出现在当前节点的两侧，返回当前节点作为公共祖先
当前节点的左右子树返回值有一个为空，说明p和q出现在当前节点的一侧，返回p或者q作为两个节点的公共祖先
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: //一旦找到 TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //当前节点为空节点或者遇到了p或者q，提前结束吧后序遍历 if(root==nullptr||root==p||root==q) return root; //正常后序遍历 TreeNode* left=lowestCommonAncestor(root-&gt;left,p,q); TreeNode* right=lowestCommonAncestor(root-&gt;right,p,q); //p和q出现在当前节点的两侧，当前节点就是公共祖先 if(left!=nullptr&amp;&amp;right!=nullptr) return root; //p和q出现在当前节点的一侧 return left!=nullptr?left:right; } }; 总结采用后序遍历求公共祖先，p和q出现在当前节点的两侧，说明当前节点就是公共祖先，p和q出现在当前节点的一侧，说明p和q其中一个为公共祖先，此时先遇到谁谁就是公共祖先
  ]]></content></entry><entry><title>501.二叉搜索树中的众数</title><url>/post/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🍌 501.二叉搜索树中的众数
给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。
如果树中有不止一个众数，可以按 任意顺序 返回。
假定 BST 满足如下定义：
结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 思路基本思想为了求众数，肯定需要统计每个数出现的次数，为了方便起见，相同的元素相邻统计起来肯定更方便，由于是二叉搜索树，所以中序遍历就可以使得到的序列是有序序列
得到有序序列之后，一旦当前节点是新节点，就需要重新统计出现的次数，如果是旧节点，那么直接将出现的频率加一即可，有一种特殊情况，初始状态下默认为新节点，也需要重新统计出现的次数
统计完当前节点的频率，就需要判断当前节点出现的频率是否闭最大频率还大，从而判断是否需要更新结果容器，最大频率初始状态下为-1，使得结果容器可以正常更新，如果当前节点出现的频率已经大于最大频率，就需要更新结果容器，之后在进行后续的统计
当前节点出现的频率与最大频率相同也需要更新结果容器，此时直接加入结果容器中即可
为了实现判断是否出现的是新节点，需要在中序遍历的基础上增加一个pre节点记录上一次遍历的节点，从而判断当前节点是否为新节点
执行流程中序遍历二叉树 更新当前节点出现的频率 判断频率是否大于等于最大频率 大于当前频率，容器需要清空，存储出现频率更大的节点 等于当前频率，直接将当前节点加入容器 更新pre节点 返回最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public: //统计出出现次数最多的数 vector&lt;int&gt; res; //统计当前数出现的次数 int count=0; //统计出现的最大次数 int max=-1; //用来判断当前节点是否是新节点 TreeNode* pre; vector&lt;int&gt; findMode(TreeNode* root) { if(root==nullptr) return res; help(root); return res; } void help(TreeNode* root){ if(root==nullptr) return; help(root-&gt;left); //中序遍历处理当前节点 //统计当前数出现的次数 //遇到新节点 if(pre==nullptr||root-&gt;val!=pre-&gt;val) count=1; //遇到旧节点 else count++; //统计完成当前节点出现的次数时，判断是否出现的频率更高 if(count&gt;max){ res.clear(); res.push_back(root-&gt;val); //更新最大的出现次数 max=count; } //当出现不止一个众数也加入结果容器中 else if(max==count) res.push_back(root-&gt;val); pre=root; help(root-&gt;right); } }; 总结中序遍历二叉树，当前节点更新完出现的频率之后，判断当前频率是否大于最大频率从而判断是否更新结果容器，只要大于等于都需要更新，大于必须清空容器，因为当前容器中存放的元素出现的频率小于当前节点出现的频率
  ]]></content></entry><entry><title>347.前k个高频元素</title><url>/post/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🦝 347.前k个高频元素
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
思路基本思想为了找出出现频率前k个的元素，首先肯定是先统计出元素出现的频率，一个元素对应一个频率，所以是成对出现的，所以考虑使用map来存储元素出现的频率
统计完元素出现的频率，需要对频率进行排序，但是正常的map排序都是对键进行排序，而我们统计时，元素出现的频率保存在了值上，所以不能使用map进行排序
此时借助到了优先级队列，优先级队列中默认使用元素的&lt;来排序、但是这里我们使用map存储元素，元素是以pair的形式存在，需要针对pair的second进行排序，所以需要自定义排序规则，一旦需要指定自定义的排序规则，就需要手动指定底层的存储容器
当排序规则制定好之后，需要确保优先级队列中存储的是前k个高频元素，所以需要建立小根堆，不建立大根堆的原因是因为大根堆删除元素时删除的是最大的元素，无法将这些元素保留
当将统计过频率的元素形成的pair都插入优先级队列中，最后剩下来的k个元素就是所要的元素，此时直接将pair中的first元素拿出来就是所求的结果
执行流程统计元素出现的频率 对频率排序 将剩下的pair中的元素取出来形成vector作为最后的结果 返回结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: // 小顶堆 class mycomparison { public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) { return lhs.second &gt; rhs.second; } }; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { // 要统计元素出现频率 unordered_map&lt;int, int&gt; map; // map&lt;nums[i],对应出现的次数&gt; for (auto num:nums) { map[num]++; } // 对频率排序 // 定义一个小顶堆，大小为k //优先级队列的底层存储容器为vector //要想自定义排序规则，就需要手动指定底层存储容器 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map&lt;int, int&gt;::iterator it = map.begin(); it != map.end(); it++) { pri_que.push(*it); if (pri_que.size() &gt; k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); } } // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) { result[i] = pri_que.top().first; pri_que.pop(); } return result; } }; 总结主要是对频率的排序，无法使用正常的排序规则，所以借助了优先级队列进行排序
优先级队列使用自定义排序规则时需要手动指定底层存储的容器，因为在创建优先级队列时，需要确保底层容器中的元素能够根据你的自定义排序规则正确地构建堆结构。
  ]]></content></entry><entry><title>151.反转字符串中的单词</title><url>/post/151.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🔡 151.反转字符串中的单词
给你一个字符串 s ，请你反转字符串中 单词 的顺序。
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。
注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
思路基本思想为了实现单词的翻转，需要借鉴左旋转字符串的思想，为了实现单词的逆转，需要先将单词逆转，然后在逆转整个字符串，但是不能直接逆转，需要去除多余的空格，所以整个问题分为两个解决步骤：
去除多余的空格，但是每个单词之间需要保留一个空格
为了实现这个功能，第一个单词之前不能加空格，所以需要两个指针解决问题，一个指针找到单词的起点，然后一个指针接受单词，将空格覆盖
接受单词之前，需要判断是否需要加上一个空格作为单词之间的间隔
一旦找到一个单词的起点，就一次性将整个单词取出，具体的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //去除单词中的多余空格 int fast=0,slow=0; for(;fast&amp;lt;s.size();++fast){ //找到单词开头 if(s[fast]!=&amp;#39; &amp;#39;){ //单词之间增加一个空格 if(slow!=0){ s[slow++]=&amp;#39; &amp;#39;; } //将单词取出来 while(fast&amp;lt;s.size()&amp;amp;&amp;amp;s[fast]!=&amp;#39; &amp;#39;){ s[slow++]=s[fast++]; } } } 去除多余的空格之后，就是完成单词的反转，此时就和左旋转字符串的思想一致了，先逆转每个单词，然后将字符串整体逆转
每个单词的逆转需要找到单词的位置，记住起始位置和结束位置，因为最后一个单词不能用空格判断单词的结束，只能通过判断当前下标是不是字符串的末尾
所以需要统一交换的区间，区间为左闭右闭时，判断到单词的结尾需要传递上一位置，区间为左闭右开时，直接传递当前位置
具体的代码如下：
1 2 3 4 5 6 7 8 9 10 11 //翻转每一个单词 int start=0; for(int i=0;i&amp;lt;=slow;++i){ //走到最后一个单词或 …  ]]></content></entry><entry><title>541.反转字符串II</title><url>/post/541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2ii/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🤸 541.反转字符串II
给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
思路基本思想因为每2*k个元素就要反转前k个元素，也就是字符串被分成了若干段，每一段都是2*k个字符，最后一段除外
此时对于每一段元素，逆转前k个元素即可，最后一段如果不足k个元素，就将剩下所有的元素都逆转一遍
那么核心就是找到每一段的开头位置，为了实现段的跳跃，for循环的步数可以设置为2*k，此时每走一步就是下一段的开始位置，从这个位置开始逆转即可
逆转时需要判断当前是否有k个元素，因为最后一段可能没有k个元素
执行流程外层for循环一次走2*k步，找到每一段逆转的开头位置 判断当前端是否还有k个元素 有k个元素直接逆转k个元素 没有k个元素就逆转剩下的元素 返回逆转之后的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: //每次找到需要翻转的起点，也就是一步走2k长 //然后翻转k个字符 string reverseStr(string s, int k) { for(int i=0;i&lt;s.size();i+=2*k){ //从头开始逆转k个字符 //逆转需要分两种情况，第一种是够k个元素，第二种是不够k个元素 //够k个元素直接逆转 if(i+k&lt;s.size()){ swap(s,i,i+k-1); } //不够k个元素 else{ swap(s,i,s.size()-1); } } return s; } //根据给定的范围逆转元素 //为了将改变传回形参，需要使用引用传递的方式 void swap(string &amp;s,int begin,int end){ for(int i=begin,j=end;i&lt;j;++i,--j){ char temp=s[i]; s[i]=s[j]; s[j]=temp; } } }; 总结核心有两点：
for循环一次走2*k步，找到每次逆转的开头位置 每次逆转都需要判断是否还有k个元素，为了处理最后一个分段不足k个元素的情况   ]]></content></entry><entry><title>18.四数之和</title><url>/post/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   18.四数之和
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
0 &amp;lt;= a, b, c, d &amp;lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。
思路基本思想相比于15题，本题就是多了一个数，并且数的和不再是0而是target，但是基本的思路还是一样的，只需要将三数之和进行简单的改造，如果题解看不懂，需要先看15题的题解
将问题分解，四数之和分成一个数与三个数的和，这样问题就变成了三数之和的问题
只是三数之和的目标不再是0，而是target-nums[i],这个nums[i]就是第四个数，这四个数相加刚好是target
为了实现一个数与三个数的和，首先需要从nums中取出一个数，然后从余下的元素中使用三数之和的方法找出符合条件的数组成四元组
从nums中取出元素的操作，需要注意去重，也就是说不能从相同的元素开始搜索
整道题的逻辑就是建立在15题的基础上，只是编写代码时需要注意细心
核心的地方有两点：
去重的时候有三个地方都需要去重
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //第一次去重 if(nums[i]&amp;gt;target&amp;amp;&amp;amp;nums[i]&amp;gt;0) break; if(i&amp;gt;0&amp;amp;&amp;amp;nums[i]==nums[i-1]) continue; //第二次去重，仿照第一次去重的经验 if(nums[j] + nums[i] &amp;gt; target &amp;amp;&amp;amp; nums[j] + nums[i] &amp;gt;= 0) break; //防止从重复的元素出发搜索剩下的元素 if(j&amp;gt;i+1&amp;amp;&amp;amp;nums[j]==nums[j-1]) continue; //第三次去重 while(left&amp;lt;right&amp;amp;&amp;amp;nums[right]==nums[right-1]) right--; …  ]]></content></entry><entry><title>15.三数之和</title><url>/post/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   ➕︎ 15.三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k，j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
思路基本思想需要整理思路，题目要求三数之和，并且数的下标不能重复，三个数的组合不能重复，所以需要去重，去重的第一步就是排序，这样相同的元素聚集在一起，以一个元素出发搜索其他所有符合要求的元素形成了三元组，下一次搜索时就不能从这个元素出发了，所以需要第一次去重，体现在代码中为：
1 2 3 //防止从重复的a出发 if(i&amp;gt;0&amp;amp;&amp;amp;nums[i]==nums[i-1]) continue; 为了统计出所有符合要求的三元组，从一个元素出发，剩下的两个元素可以从余下元素的两端开始统计，也就是i+1和nums.size()-1的位置，这样就可以防止三个元素的下标重复为什么左边从i+1是因为之前的元素都已经被统计了，也就是第一个元素是从头开始的，如果左边从头开始，会出现很多重复的三元组
关于左边从i+1开始需要好好理解
当三个元素形成一个合法的三元组时，需要注意左右两端的元素也不能重复，此时需要第二次去重，体现在代码中为：
1 2 3 4 5 //将左右两个数去重，防止出现重复的三元组 while(left&amp;lt;right&amp;amp;&amp;amp;nums[right]==nums[right-1]) right--; while(left&amp;lt;right&amp;amp;&amp;amp;nums[left]==nums[left+1]) left++; 整体的思路就是从一个数出发，统计出剩下的两个数，统计的过程中需要经历两次去重
执行流程对给定的元素排序
依次从数组中的每一个元素出发，从余下的元素中试图统计出剩下的两个元素组成合法的三元组
判断当前出发的元素是否已经被统计过，第一次去重
从余下的元素中找出符合要求的两个元素
三数之和大于0，右边的数需要变小 三数之和小于0，左边的数需要变大 三数之和等于0，形成合法的三元组 对左右两边的元素去重，第二次去重 形成三元组，将三元组加入结果容器中 继续尝试统计出新的三元组 从新的元素 …  ]]></content></entry><entry><title>454.四数相加</title><url>/post/454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   ➕︎ 454.四数相加
给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：
0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
思路基本思想为了求出四个数的和，最简单的方法就是使用四层嵌套for循环，暴力求解，但是这样会超时，所以需要将问题分解
四个数可以分成两个数一组，第一组求和，第二组求和，形成新的求和数组之后，四数之和就变成了两数之和，为了进一步减小运行时间，第一组求和的数组可以用哈希表存储，这样在第二组数求和的过程中就可以判断求和之后第一组中是否有符合要求的数
由于两组数求和可能会出现同一个答案，所以需要将求和之后的数出现的次数进行统计，这样第二组数求和统计时，就可以直接得出当前会出现几个0
核心就是将四组数两两分组
执行流程四组数两两分组，第一组数求和形成哈希表 第二组数求和，并判断第一组数中是否有相加为0的元素 统计所有出现0的组合 返回结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) { //将四个数分成两个数一组，第一组负责构建哈希表，第二组负责在哈希表中查找 //哈希表的键值代表&lt;值，出现次数&gt; //创建哈希表 unordered_map&lt;int,int&gt; umap; for(int i=0;i&lt;nums1.size();++i){ for(int j=0;j&lt;nums2.size();++j){ umap[nums1[i]+nums2[j]]+=1; } } //在哈希表中查找是否有符合条件的元素 int res=0; for(int i=0;i&lt;nums3.size();++i){ for(int j=0;j&lt;nums4.size();++j){ //添一个负号，查看哈希表中是否有元素可以相加之后等于0 if(umap[-(nums3[i]+nums4[j])]&gt;0){ //一旦有相加和为0的元素，出现几次说明就可以相加出现几个0 res+=umap[-(nums3[i]+nums4[j])]; } } } return res; } }; 总结主要是将问题拆分，四数之和变成两组数之和，由于同一个数的可能出现多次，例如4+1与2+3都是5的这种情况，需要统计一个数的出现次数，一旦这个数存在另外一个数相加为0，那么形成这个数的所有情况都需要统计
  ]]></content></entry><entry><title>202.快乐数</title><url>/post/202.%E5%BF%AB%E4%B9%90%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 😹 202.快乐数
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」 定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。
思路
基本思想
基本思想就是对一个数分离各个位上的数并平方求和，如果不是1就继续分离并求和，直到遇到1，但是分离并求和的过程中肯定不是一直分离下去，一旦遇到之前求和过的结果，肯定会陷入死循环，此时这个数肯定不是快乐数
所以需要将问题分解，首先求当前数的分离之后的平方和结果，判断这个数是否之前出现过，这一步需要借助一个容器存储之前出现的所有结果，这里使用unordered_set，因为他的存储效率和查询速度在这里最适合
将问题分解之后就是简单的代码了
执行流程
定义分离求平方和的函数 对当前的数求平方和 判断平方和是否为1，是的话就是快乐数，返回true 不是的话需要判断这个结果之前是否出现过 出现过说明陷入死循环，直接返回false 没出现过继续对当前的数分离求平方和 代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: bool isHappy(int n) { unordered_set&amp;lt;int&amp;gt; uset; while(1){ //计算当前的sum int sum=getSum(n); if(sum==1) return true; else{//不等于1判断是否需要计算新的sum if(uset.find(sum)!=uset.end()) return false; else uset.insert(sum); } //重新计算新的sum n=sum; } } int getSum(int n){ int sum=0; while(n){ sum+=(n%10)*(n%10); n/=10; } return sum; } }; 总结
主要是知道如何将一个不知道位数的数的各个位分离下来，并且知道当前的平方和在之前出现过则说明陷入死循环，当前的数一定不是快乐数</content></entry><entry><title>142.环形链表II</title><url>/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> ➰ 142.环形链表II
给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
不允许修改 链表。
思路
基本思想
相比于
141题
，本题不仅需要判断是否有环，还需要将入环的第一个节点给找到，所以增加了难度，在141题的基础上，如果有环，需要增加代码，将入环节点找到
此时有两种解决办法，第一种直接抛弃141题的方式，遍历链表，将链表存储到一个unordered_set中，一旦存储的过程中发现容器中有了此节点，说明找到了第一个入环节点，此方式需要使用容器辅助，增加了空间复杂度
第二周解决办法就是在141题的基础上，通过推导发现数学规律，从而找到入环节点，当找到环时，快慢指针所处的状态如图所示：
此时slow指针走过的步数为x+y，fast指针走过的步数为x+y+n(y+z)，并且由于快指针走两步慢指针才走一步，所以两个指针步数之间的关系为： $$ x+y+n(y+z)=2(x+y) $$ 化简之后为： $$ n(y+z)=x+y $$ 进一步化简为： $$ (n-1)(y+z)+z=x $$ 也就是说，x和z之间，就差了若干个y+z，从快慢指针相遇节点和头结点分别出发，再次相遇的节点就是入环节点
执行流程
方法一
定义一个unordered_set 遍历链表，尝试将每一个节点加入容器 加入之前判断容器中是否已存在当前节点 已存在直接返回当前节点，不存在继续遍历 遍历到结束都没有找到就返回nullptr 方法二
快慢指针从头出发 快指针走两步慢指针走一步 当快慢指针相遇时有环 从快慢指针和头结点的位置分别出发向后遍历 第一个相遇位置就是入环节点 没找到环返回nullptr 代码
根据以上分析，得出以下代码：
方法一
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: ListNode *detectCycle(ListNode …</content></entry><entry><title>19.删除链表的倒数第N个结点</title><url>/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   👋 19.删除链表的倒数第N个结点
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
思路基本思想为了删除倒数第n个节点，最简单的办法就是求出链表的长度，然后再找到倒数第n个节点的前一个节点进行删除，此时就需要两次遍历，第一次求出链表长度，第二次找到倒数第n个节点的前一个节点，为了简化流程，想到一个更简单的办法
定义两个变量，使用双指针，快指针先走n步，然后快慢指针一起走，当快指针移动到末尾时，慢指针就移动到了倒数第n个节点，为了找到倒数第n个节点的前一个节点，并且当链表中只有一个节点时也能完美删除，申请一个虚拟头结点，让链表的操作变得统一
核心就是双指针+虚拟头结点
执行流程申请虚拟头结点，虚拟头结点的next指针指向链表的首元结点 快慢指针都从虚拟头结点出发 快指针走n步 快慢指针一起走，当快指针到了末尾，慢指针就到了倒数第n个节点的前一个节点 删除节点，返回虚拟头结点的next指针 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(head==nullptr) return head; ListNode* dummyHead=new ListNode(0); dummyHead-&gt;next=head; ListNode* fast=dummyHead; ListNode* slow=dummyHead; int num=n; while(fast-&gt;next!=nullptr){ if(num&gt;0){ fast=fast-&gt;next; num--; }else{ fast=fast-&gt;next; slow=slow-&gt;next; } } slow-&gt;next=slow-&gt;next-&gt;next; return dummyHead-&gt;next; } }; 总结核心就是快慢指针+虚拟头结点
  ]]></content></entry><entry><title>59.螺旋矩阵II</title><url>/post/59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   😵 59.螺旋矩阵II
给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
示例示例 1：
1 2 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2：
1 2 输入：n = 1 输出：[[1]] 思路基本思想为了模拟螺旋的情况，一圈循环当成一个整体，一圈一圈的向内收缩，并且每一圈可以分割成等长的四个长方形，分割情况如下图所示：
其中每一个颜色代表一个分割结果，创建螺旋数组时，需要选择一个起点，每一圈的起点都不同，并且每个螺旋数组旋转的圈数也不同，所以需要定义很多变量：
1 2 3 4 5 6 7 8 int startx=0;//起点的横坐标 int starty=0;//起点的纵坐标 //由于每一圈的地点都在主对角线上，所以一个start就可以记录起点的位置 //int start=0;//起点的坐标 int loop=n/2;//螺旋数组遍历多少圈 int mid=n/2;//螺旋数组的中心点 int num=1;//螺旋数组中每个位置的值 int offset=1;//定义每一圈分割之后，长方形的长度 需要注意的是螺旋数组遍历多少圈，这个需要理解，如果给定n=3，那么只需要遍历一圈，如果给定n=5，那么需要遍历两圈
其中offset代表每一圈分割成四个长方体之后，长方体的长度，每遍历一圈，长方体的长度就会减小一，理解了这些就是纯代码模拟了
执行流程从左到右填充第一个长方形，此时行不变 从上到下填充第二个长方形，此时列不变 从右到左填充第三个长方形，此时行不变 从下到上填充第四个长方形，此时列不变 一圈结束之后，更新下一圈的起点，并且下一圈的长方形的长度也需要更新 注意for循环中的i，j不能使用临时变量，要在for循环外定义，方便记住此时的遍历位置
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: //主要是靠代码模拟旋转 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; …  ]]></content></entry><entry><title>209.长度最小的数组</title><url>/post/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🔢 209.长度最小的数组
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, &hellip;, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
思路基本思想为了求出连续的子数组，首先想到的就是将数组排序，从最大的一直累加，直到超过target，说明找到了连续的子数组，但是题意并不是如此，前提不能改变数组中元素的位置，只能从原数组中找出一个连续的子数组
为了不变更数组中元素的位置，只能一次从每一个元素为起点，然后向后累加，但是这又会用到一个双层循环，为了减小时间复杂度，一旦超过target，代表找到了一个连续的子数组，此时判断当前子数组的长度是否小于当前记录的最小长度，是的话就更新
更新完成之后，需要从下一个元素为起点开始遍历，细想一下会发现元素之间有重叠的部分，例如以[1,2,3,4,5]为例，target=10，1+2+3+4已经大于等于10，此时变换起点，以2 为起点，会发现2+3+4这一部分已经计算过了，不需要重复计算，所以只需要简单的去掉1即可，在图中就是[3,1,2]是重复的部分
并且一次不只是去掉一个元素，一直删除元素，直到当前的和小于target才更换起点，因为删除元素的过程中如果还是大于等于target，那么最小连续子数组的长度就会更新。
此时需要记录起点的位置，方便计算超过target之后，连续子数组的长度，最后需要注意，只有当sum大于等于target时，才会更新min，所以 min有可能一直不会更新，所以需要注意返回最终的结果时还需要判断一次
执行流程sum一直累加
当sum大于target时开始删除起点
删除起点之后，最小连续子数组的长度变小，则更新 sum减小 重复上面的步骤，直到sum小于target 转到1
返回结果时需要判断min是否更新
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int start=0; int sum=0; //保证min一定可以更新 int min=INT_MAX; for(int i=0;i&lt;nums.size();++i){ sum+=nums[i]; //一旦超过target，一直删除，直到小于target while(sum&gt;=target){ min=(i-start)+1&lt;min?(i-start)+1:min; //删除一个元素就更换一下起点 sum-=nums[start++]; } //sum小于target时，sum继续累加 } return min==INT_MAX?0:min; } }; 总结利用了滑动窗口的思想，只要sum超过target，那么就更新min的值，并且删除起点，代表从新节点出发，只要sum大于target，就一直删除起点，只要sum小于target，就一直累加sum
  ]]></content></entry><entry><title>27.移除元素</title><url>/post/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🐵 27.移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
思路基本思想为了将
所有值为val的元素移除，需要将所有不是val的元素向前移动，以覆盖所有val的元素，逆向思维将问题转化之后，一切迎刃而解，使用双指针解题
fast寻找每一个不是val的元素，一旦找到，slow位置就放置不是val的元素，如果遇到值为val的元素，slow不动，fast向后寻找不是val的元素覆盖slow位置上的元素即可
执行流程遍历数组 遇到不是val的元素，直接将元素搬到slow的位置上 遇到是val的元素，slow不动，fast向后移动寻找不是val的元素将值为val的元素覆盖 返回slow的值就是删除之后数组的长度 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int fast=0,slow=0; while(fast&lt;nums.size()){ if(nums[fast]!=val){//找到不是val的元素 nums[slow++]=nums[fast++]; }else{//找到是val的元素 ++fast; } } //slow就是数组的长度 return slow; } }; 总结主要是思维的转换，将删除val元素转换为将不是val的元素向前移动，之后只需要找出所有不是val的元素移动即可
  ]]></content></entry><entry><title>841.钥匙和房间</title><url>/post/841.%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🗝️ 841.钥匙和房间
有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。
当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。
给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。
思路基本思想只能从0号房间开始，相当于从0开始向后扩散，越来越大，这个扩散的过程形成了一个有向图，每走到一个节点，能进入的房间都会非递减的增长，所以只需要统计哪些房间可以进入，进入之后拿到钥匙，范围扩大到了哪
关键点就是记录这个范围，初始记录所有的房间都无法访问，然后从0号房间开始出发，进行深度搜索，每到一个房间都拿出房间中的钥匙，然后用这些钥匙去指定的房间，遇到访问过的房间就去下一间
执行流程从0号房间出发，拿到0号房间中放置的钥匙 去对应的房间开锁，拿到对应房间的钥匙 重复2，直到遇到已经进入过的房间 一层一层向下，偶尔回溯 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) { vector&lt;bool&gt; visited (rooms.size(),false); //需要以0号房间为起点 dfs(visited,0,rooms); //查看是否有房间没被访问 for(int i=0;i&lt;visited.size();++i){ if(!visited[i]){//有房间没被访问 return false; } } //所有的房间都被访问 return true; } //注意要传递引用 void dfs(vector&lt;bool&gt; &amp;visited,int key,vector&lt;vector&lt;int&gt;&gt; rooms){ if(visited[key]){//当前房间有钥匙，但是被访问过了 return; } //当前房间有钥匙没被访问 visited[key]=true; //进入当前房间，拿到当前房间的钥匙 vector&lt;int&gt; keys =rooms[key]; //拿到钥匙之后，递归向下，目的是使用所有的钥匙 for(int key:keys){ dfs(visited,key,rooms); } } }; 总结主要是进入一个房间之后，拿到这些钥匙，就依次进入对应的房间，然后再从这个房间拿到对应的钥匙，没进入一个房间拿到对应的钥匙，都设置一个for循环，目的是使用拿到的钥匙去打开所有的房间，这样所有的钥匙都会被使用
最后查看是否有房间没被打开，有的话说明即使全部钥匙都使用了，但还是无法进入所有房间
  ]]></content></entry><entry><title>673.最长递增子序列的个数</title><url>/post/673.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 📈 673.最长递增子序列的个数
给定一个未排序的整数数组 nums ， 返回最长递增子序列的个数 。
注意 这个数列必须是 严格 递增的。
示例
示例 1: 1 2 输入: [1,3,5,4,7] 输出: 2 解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2: 1 2 输入: [2,2,2,2,2] 输出: 5 解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
思路
基本思想
与
300题
的思路类似，300题求的是最长递增子序列的长度，所以只需要在求以每个元素结尾的递增子序列中统计出长度最长的即可
本题中是求最长递增子序列的个数有多少，有可能两个最长递增子序列是以同一个元素结尾（示例1），所以没办法按照300题的方法进行统计
核心就是将300题中dp数组的更新逻辑拆分成两部分
此时需要新增一个容器，用来存储当前位置之前，有几个最长的子序列，于是本题中就有两个容器需要更新，分别的含义为：
dp[i]代表以第i个元素结尾的最长递增子序列的长度
count[i]代表以第i个元素结尾的最长递增子序列的个数
一旦dp[i]更新，有两种情况：
找到了更长的递增子序列，此时当前递增子序列的长度需要更新，递增子序列的个数也需要更新，其中dp[j]+1代表第j个元素之前的元素加上第i个元素形成的递增子序列
1 2 3 4 5 6 if(dp[j]+1&amp;amp;gt;dp[i]){ //长度应该+1 dp[i]=dp[j]+1; //个数应该一样 count[i]=count[j]; } 找到了一样长的递增子序列，我们认为此时也需要更新，但是count的更新方式不一样了：
1 2 3 4 5 6 if(dp[j]+1==dp[i]){ //长度不变 dp[i]=dp[j]+1; //个数累加 count[i]+=count[j]; } 以上两种情况需要更新count，其余情况正常按照300题的思路更新dp即可，但是count[i]中记录的是第i个元素之前的最长递增子序列的个数。不知道全局的最长递增子序列的长的是多少，所以需要统计一下所有符合最长递增子序列长度的个数，累加起来，累加的时候也有技巧
当以当前元素结尾的最长递增子序列长度是全局的最长递增子序列长度时，此时以当前元素结尾的最长递增子序列个数也需要统计 …</content></entry><entry><title>131.分割回文串</title><url>/post/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🖇 131.分割回文串
给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
回文串 是正着读和反着读都一样的字符串。
思路基本思想开始第一想法是将一个字符串的所有分割结果列出来，统计其中所有的回文串，但是这种方法不符合题意，题目要求将字符串进行分割，分割的每一个子串都要求是回文串，而不是简单的从幂集中找出所有的回文串
所以需要使用回溯法进行搜索，当前子串是回文串，才能进行下一步分割，当前子串不是回文串，需要一直向后搜索，直到到了字符串末尾或者找到一个回文子串
一旦找到一个回文子串，剩下的部分就可以继续分割，继续分割可以使用回溯法，从当前位置的下一位置开始分割，也就是回溯法
当形成一个完整的分割方法时，分割位置走到了字符串的末尾，这是一个标志，代表着形成了一个完整的分割结果，因为只有前面的分割结果是回文串，才能对后面剩余的字符串进行分割
形成一个完整的分割结果之后，需要搜索下一个完整的分割结果，所以需要一步一步回溯，此时保存分割结果的path就需要一步一步的删除元素
执行流程回溯法分割字符串，当前子串是回文串才对后面的字符串进行分割 将当前分割结果加入path 对剩下的字符串进行分割 形成完整的分割结果返回时，path需要删除元素 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: //存储每个分割的回文串结果 vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; path; vector&lt;vector&lt;string&gt;&gt; partition(string s) { if(s.size()==0) return res; backtrack(s,0,s.size()); return res; } //判断一个字符串是不是回文串 bool isPalindrome(string s,int start,int end){ for(int i=start,j=end;i&lt;j;++i,--j){ if(s[i]!=s[j]) return false; } return true; } void backtrack(string s,int index,int n){ if(index==n){ res.push_back(path); return; } //开始分割字符串 for(int i=index;i&lt;n;++i){ //当前子串是回文串，后面剩下的才需要分割，否则当前子串还需要继续增加 if(isPalindrome(s,index,i)){ path.push_back(s.substr(index,i-index+1)); backtrack(s,i+1,n); //当前分割方法统计完成需要回溯 path.pop_back(); } //不是回文串，继续向后尝试分割，当前子串不需要分割 } } } 总结主要是形成一个回文串，才可以对剩余的字符串进行分割，所以分割和回溯的逻辑都写在了if语句里面，形成一个完整的分割结果时，将分割结果存储到res中
  ]]></content></entry><entry><title>5.最长回文子串</title><url>/post/5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   5.最长回文子串“
给你一个字符串 s，找到 s 中最长的回文子串。
如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
思路基本思想与647题思路一致，只是统计的目标不一样，647题统计的是所有回文子串的数量，本题统计的是所有回文子串中最长的回文子串，需要多一步，最初的想法是使用回溯法将字符串的所有分割结果穷举出来，然后判断每一个子串是否是回文子串，然后判断当前回文子串是否变长，变长的回文子串就会更新，经历三步：
穷举字符串的所有分割结果 判断字符串是不是回文子串 最长回文子串是否需要更新 但是此方法超时，主要问题还是在回溯法穷举的时间太长，并且长回文子串一定包含短回文子串，也就是重复判断了很多次，短的回文子串的判断结果可以交给长的回文子串，于是想到了动态规划
当i+1~j-1范围内的子串是回文串时，加上s[i]==s[j]的条件，回文串的长度就会进一步变大，并且i+1~j-1到i~j范围内的变化是从左下角到右上角，所以需要从左下角开始统计，然后将左下角的结果用到右上角上
dp数组的含义是：dp[i][j]代表i~j范围内的子串是否是回文子串
此题中没有递推公式，只要当i+1~j-1范围内的子串是回文串时，加上s[i]==s[j]的条件就可以形成新的回文串
只要有新的回文串，最长回文串的结果就有可能更新
要清楚遍历字符串时,每一行中的遍历范围是从对角线向前的元素,这样从左下角向右上角统计的过程中字符串的遍历范围逐步扩大,最终遍历整个字符串,得到最长的回文子串
执行流程初始化dp数组，默认所有范围内的子串都不是回文串 从左下角开始向右上角推导，满足一定条件说明当前范围内的子串是回文子串 判断最长回文子串是否需要更新 遍历完成之后，返回最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: string res=&amp;#34;&amp;#34;; string longestPalindrome(string s) { //使用动态规划 string res=&amp;#34;&amp;#34;; vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; …  ]]></content></entry><entry><title>52.N皇后II</title><url>/post/52.n%E7%9A%87%E5%90%8Eii/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 👑 52.N皇后II
n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。
思路
基本思想
与
51题
思路一样，只是统计结果是略有不同，需要将问题分解，拆成两部分：
如何搜索整个棋盘，从每一个位置出发，遍历下面的棋盘都会形成不同的搜索结果 如何判断皇后之间不相互攻击，也就是同行同列同对角线都只有一个皇后 对于1来说，这种遍历所有情况的问题，使用回溯法最方便，每次选择一个新位置，然后就开始向下一层回溯，下一层遍历完成之后，返回上一层，继续选择下一个新位置，然后向下一层回溯，这样来来回回就可以搜索到所有的结果，形成的搜索树为：
对于2来说，当前位置是否可以放皇后，取决于同列同对角线是否有皇后，同行一定没有皇后，因为当前行选中一个位置放皇后之后，会进入下一层，所以当前层在当前时刻只会存储一个皇后，下一层的位置经过合法性判断之后也可以放皇后
由于代码是从上到下遍历的，所以当前位置的西南方向和东南方向一定没有皇后，只需要判断当前列，东北方向，西北方向是否有元素即可
考的是代码模拟的能力，思路很简单
当遍历到最后一行的下一行时，说明所有行都放置了一个皇后，形成了一个方案，此时将这个方案统计，当回溯法结束，说明所有有效的方案都统计完毕
执行流程
回溯法遍历，穷举所有可能的情况 判断是否到了最后一行的下一行，也就是第n行，是的话说明形成了合法的结果，需要统计，不是的话转3 到了这里说明没有到最后一行的下一行，本行还需要放皇后，在本行中找一个有效位置，进入下一行继续找。。。 有效位置的判断有单独的函数 回溯法穷举结束，就可以统计出所有有效的情况 代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public: int num=0; int totalNQueens(int n) { //1.判断当前位置是否可以放置皇后 //2. …</content></entry><entry><title>代码托管到github</title><url>/post/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%88%B0github/</url><categories><category>教程</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[   🏭 代码托管到github
如何将本地代码托管到github仓库中，前提已经安装了git，并且已经连接到了github，添加了公钥
github创建存放的代码的仓库
url就是访问仓库的地址
初始化仓库
1 git init 此时文件夹中会多出一个.git文件夹
其中config文件中存放的是关键的配置信息
将本地仓库和远程github仓库连接起来 其中origin是远程仓库的别名，后期提交时使用origin就会自动解析为远程仓库的地址
1 git remote add origin xxx 这里的xxx就是github中创建的仓库提供的url，此时config文件会发生变化
这里的origin相当于远程仓库的别名，如果想要把同一个本地仓库提交给不同的远程仓库，那么就可以修改这个命令，修改之后形成如下的映射：
将项目文件添加到暂存区 1 git add . 提交代码到本地仓库,引号中填写自己的描述 1 git commit -m &#34;commit&#34; 将本地仓库中的代码提交到远程仓库 使用master分支提交，前提需要确保本地仓库和远程仓库的分支都是master
1 git push -f origin master 显示如下效果表示完成推送 如果无法完成推送，查看当前分本地分支与远程仓库分支是否对应，下面是一些常见的git命令：
1 2 3 4 5 6 7 8 9 10 #查看当前本地分支名 git branch #修改当前的本地分支 git checkout &lt;branch_name&gt; #创建并切换到新分支 git checkout -b &lt;branch_name&gt; #推送时显示Timeout git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 git config --global http.proxy 总结起来就是以下几步：
创建远程仓库 初始化本地仓库 远程仓库取别名 代码添加到暂存区 代码上传到本地仓库 代码上传到远程仓库   ]]></content></entry><entry><title>100.相同的树</title><url>/post/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🌳 100.相同的树
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
思路基本思想为了辨别两棵树是否是相同的树，直接同时遍历两棵树，一旦遇到不相等就返回false，只有遍历到最后都返回true，最终的结果才是true，遍历的过程没有难点，主要是要分几种情况：
两个节点都为空：返回true 两个节点任有一个为空：返回false 两个节点值相等，当前返回true 查看两个节点的左孩子和右孩子是什么情况 上面的遍历顺序不能反，一旦到了2，说明至少有一个节点不是空，一旦到了3，说明两个节点都不是空，一旦到了四，说明两个节点的值相等
执行流程两个节点都为空：返回true 两个节点任有一个为空：返回false 两个节点值相等，当前返回true 查看两个节点的左孩子和右孩子是什么情况 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: //逻辑要清晰，每一种情况都要考虑到 bool isSameTree(TreeNode* p, TreeNode* q) { if(p==nullptr&amp;&amp;q==nullptr) return true; //到这里肯定是只有一个为空 else if(p==nullptr||q==nullptr) return false; else//到这里两个都不为空 return (p-&gt;val==q-&gt;val)&amp;&amp;isSameTree(p-&gt;left,q-&gt;left) &amp;&amp;isSameTree(p-&gt;right,q-&gt;right); } }; 总结逻辑要清晰，上一步的代码作为下一步代码的前提筛选条件
  ]]></content></entry><entry><title>1382.将二叉搜索树变平衡</title><url>/post/1382.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🎋 1382.将二叉搜索树变平衡
给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。
如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的
思路基本思想将二叉搜索树变平衡，可以将问题拆解，现将其转化为中序遍历的序列存储到vector中，然后将vector中的元素转化为平衡二叉树，最终实现将二叉搜索树变平衡的说法。
一旦将问题分解，唯一的难点就在将中序遍历序列转化为平衡二叉树，可以参考108题，需要计算二叉树中节点的位置，使用类似于二叉搜索的思想，每次丢弃一半的元素，找到目标的元素，直接申请新节点，在创建平衡二叉树的过程中有几点需要注意：
得到中序遍历序列时，必须传递引用，否则中序遍历的结果无法存储到vector容器中 由容器中的元素构建平衡二叉树时，传递的范围必须是有效元素的范围，也就是(0,res.size()-1)，而不是(0,res.size())，后者会造成空指针访问的情况，因为当pos=res.size()时，也会尝试访问容器中的元素 执行流程得到中序遍历序列 根据中序遍历序列得到平衡二叉树 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: TreeNode* balanceBST(TreeNode* root) { //分为两步，第一步将二叉搜索树存放在有序数组中：使用中序遍历 //第二步将有序数组转化成二叉搜索树 vector&lt;int&gt; res; trans(root,res); //传递的元素范围必须是有效范围 return create(res,0,res.size()-1); } //将二叉树转化成有序数组,传递的必须是引用，才能将结果保存到res中 void trans(TreeNode *root,vector&lt;int&gt; &amp;res){ if(root==nullptr) return; trans(root-&gt;left,res); res.push_back(root-&gt;val); trans(root-&gt;right,res); } //将有序数组转化为平衡二叉树 TreeNode* create(vector&lt;int&gt; res,int begin,int end){ if(begin&gt;end) return nullptr; int pos=(begin+end)/2; TreeNode *node=new TreeNode(res[pos]); node-&gt;left=create(res,begin,pos-1); node-&gt;right=create(res,pos+1,end); return node; } }; 总结将问题分解，变成两个简单的问题，需要注意参数传递时传递引用，传递元素范围时需要传递有效元素的范围
  ]]></content></entry><entry><title>129.求根节点到叶节点数字之和</title><url>/post/129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🌴 129.求根节点到叶节点数字之和
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。 每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -&amp;gt; 2 -&amp;gt; 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。
示例示例 1：
1 2 输入：root = [1,2,3] 输出：25 解释： 从根到叶子节点路径 1-&amp;gt;2 代表数字 12 从根到叶子节点路径 1-&amp;gt;3 代表数字 13 因此，数字总和 = 12 + 13 = 25 示例 2：
1 2 输入：root = [4,9,0,5,1] 输出：1026 解释： 从根到叶子节点路径 4-&amp;gt;9-&amp;gt;5 代表数字 495 从根到叶子节点路径 4-&amp;gt;9-&amp;gt;1 代表数字 491 从根到叶子节点路径 4-&amp;gt;0 代表数字 40 因此，数字总和 = 495 + 491 + 40 = 1026
思路基本思想根节点到每一个叶子结点都会形成一个路径，路径上的数会组成一个数，将这些路径上组成的数全部加在一起即可
所以想到了回溯法，往下一层，形成的数多一位，往回一层，形成的数就会变少一位，但是都是在末尾进行操作，所以可以使用回溯法的模版处理问题
由于从根节点向下，为了能够判断是叶子节点，并且好回溯，向下递归时传递的是root-&amp;gt;left和root-&amp;gt;right，而不是root，这是有原因的，因为当回溯到这一层时，如果传递的是root，就无法回溯，传递的是下一层的节点，回溯之后自然就回到了当前层节点
并且回溯之后，需要将形成的数字最后一位删除，一旦遇到叶子结点，就是形成了一个数，需要将其累加到sum中，sum不能丢失原来的值，所以定义为全局变量
回溯的模版就是先遍历这一层的一个节点，拿着这一层的一个去遍历下一层的所有节点，这个节点组合下一层的所有节点的情况都搜索完成，再拿当前层的下一个节点去统计下一层的所有节点。。。
这样一直搜索，最终可以将整棵树搜索完毕，每一个叶子结点都可以遍历到
执行流程将根节点加入，否则根节点无法统计到 遇到叶子结点直接将形成的数累加到sum中 不是叶子结点，需要进行递归，并且当前节点的值需要加到形成的数中，具体的递归就是去搜索当前节点 …  ]]></content></entry><entry><title>Windows主机加入k8s集群</title><url>/post/windows%E4%B8%BB%E6%9C%BA%E5%8A%A0%E5%85%A5k8s%E9%9B%86%E7%BE%A4/</url><categories><category>教程</category></categories><tags><tag>k8s</tag></tags><content type="html"><![CDATA[   windows主机加入k8s集群
本文在Kubernetes集群完整搭建步骤的基础上，将windows主机当成工作节点加入到k8s集群中
前言k8s集群中现在已有一个master节点，两个工作节点，三个节点的linux系统版本为Ubuntu 22.04.2 LTS，windows主机加入集群之后，当成一个工作节点，主机规划如下：
主机名 主机ip 子网掩码 master 192.168.1.24 255.255.255.0 node1 192.168.1.25 255.255.255.0 node2 192.168.1.27 255.255.255.0 node3 192.168.1.26 255.255.255.0 linux节点中，docker版本为v19.03.3，kubenetes版本为v1.23.10
步骤集群预处理改变已有配置flannel开启ipv4流处理（所有节点） 本集群中使用flannel作为集群节点之间通信的网络插件，为了让windows加入已有的k8s集群，需要使用flannel需要为iptables开启IPv4流处理，现有集群中所有的节点都要操作：
1 2 # 为iptables开启IPv4流处理（集群搭建过程中已开启则略过此步骤） sysctl net.bridge.bridge-nf-call-iptables=1 配置docker镜像源（所有节点） 之前搭建集群时，docker的镜像加速已经配置完成，所以这里不再配置：
修改kube_flannel.yaml文件中的配置（只在master节点）
之前搭建集群时，从这里下载了对应的kube-flannel.yml文件，并向其中添加了指定网卡的参数，此时为了将windows节点加入集群中，并与windows中的flannel进行通信，需要再次配置文件中的参数
具体修改的参数如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 #修改的参数 net-conf.json: | { &amp;#34;Network&amp;#34;: &amp;#34;10.244.0.0/16&amp;#34;, &amp;#34;Backend&amp;#34;: { &amp;#34;Type&amp;#34;: &amp;#34;vxlan&amp;#34;, &amp;#34;VNI&amp;#34;: 4096, # 新增 &amp;#34;Port&amp;#34;: …  ]]></content></entry><entry><title>205.同构字符串</title><url>/post/205.%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🔡 205.同构字符串
给定两个字符串 s 和 t ，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
思路基本思想要理解题中的两个要求：
不同字符不能映射到同一字符上，例如&amp;quot;badc&amp;quot;和&amp;quot;baba&amp;quot;就不是同构字符串，因为a映射给了a，后面的c也想映射到a，这是不被允许的，a不能对应两个映射 相同字符只能映射到同一字符上，例如&amp;quot;add&amp;quot;和&amp;quot;egg&amp;quot;，d只能映射到g，才能满足两个字符串是同构的 并且需要注意，字符串中的元素不全都是字母，也有可能是数字，即&amp;quot;abcd&amp;quot;和&amp;quot;1234&amp;quot;都是字符串，所以记录某个字符是否被记录时，不能使用下面的语句：
1 2 #数组中的每一个位置代表对应的字母是否被映射过了 vector&amp;lt;int&amp;gt; v(26,0) 所以为了完成第一个要求，需要使用一个unordered_set记录已被映射的元素，每次形成新的映射时，都要判断元素是否已经被映射
为了满足条件2，每次都判断是否存在已经建立好的映射，防止相同元素映射到了不同的字符上
所以设置两个容器，分别是unordered_set和unordered_map，前者记录元素是否被映射过，后者记录元素的映射关系
执行流程定义两个容器分别记录元素是否被映射和元素的映射关系 对于字符串中的每个元素，判断是否有映射 如果有映射，判断映射之后是否与另外一个字符串的对应位置相等，不相等说明不是同构字符串 如果没有映射，需要新建映射关系，同时还需要注意元素是否已经被映射，防止不同的元素映射到了同一个字符上 一旦出现映射不匹配或者已经被映射的情况，都返回false，没有上述情况则返回true 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: bool …  ]]></content></entry><entry><title>141.环形链表</title><url>/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🍩 141.环形链表
给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
思路基本思想如果链表中存在环，那么遍历之后一定会回到遍历过的位置，这里可以采用多种方式，遍历过得节点打上标记，一旦遍历到有标记的节点，那么就说明有环
本文中采用快慢指针的方式，快指针一次走两步，慢指针一次走一步，如果存在环，快指针总会追上慢指针，也就是说当快慢指针相遇，则说明有环，当便利的过程中走到了链表的尾部，说明无环，具体的判断逻辑为：
1 2 3 4 5 6 7 8 ListNode* fast=head-&gt;next; ListNode* slow=head; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ if(fast==slow) return true; fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } 需要注意的是fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr缺一不可，fast!=nullptr是保证了fast-&gt;next的存在，并且其至少为nullptr，此时才能有fast-&gt;next的语句出现，不会出现空指针异常的情况
fast-&gt;next!=nullptr是为了保证fast-&gt;next-&gt;next的存在，并且至少为nullptr，不会出现空指针异常
并且fast!=nullptr需要出现在fast-&gt;next!=nullptr的前面。先确保fast-&gt;next的存在
执行流程去除空链表和只有一个节点的情况 定义快慢指针 循环遍历，查看快慢指针是否相遇 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: //使用快慢指针的方法，快指针一次走两步，慢指针一次走一步 //如果有环，那么快慢指针一定会相遇 bool hasCycle(ListNode *head) { if(head==nullptr||head-&gt;next==nullptr) return false; ListNode* fast=head-&gt;next; ListNode* slow=head; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ if(fast==slow) return true; fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } return false; } }; 总结主要是知道快慢指针的原理，并且明白fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr缺一不可，并且出现的前后顺序不能改变
  ]]></content></entry><entry><title>143.重排链表</title><url>/post/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   ⛓︎ 143.重排链表
给定一个单链表 L 的头节点 head ，单链表 L 表示为：
L0 → L1 → … → Ln - 1 → Ln 请将其重新排列后变为：
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例示例 1：
1 2 输入：head = [1,2,3,4] 输出：[1,4,2,3] 示例 2：
1 2 输入：head = [1,2,3,4,5] 输出：[1,5,2,4,3] 思路基本思想根据题目的描述，需要将链表的节点取下来组成一个新的链表，并且取节点的顺序有限制，必须头先取一个插入新链表，之后尾部取一个插入新链表，插入的顺序为尾插法，知道这个流程之后就是使用代码模拟
为了不出现空指针，先给新链表中擦干入一个节点，并且为了可以首尾取节点，也就是随机访问，需要先遍历一遍链表，将链表转化为数组，从而实现随机访问
为了首尾取节点，使用双指针法遍历数组，当数组中只剩下一个元素时，需要单独处理，防止重复加入，并且最后需要将链表尾置空，这样才能成为一个真正的新链表
知道上述这些细节之后，接下来的工作就是模拟插入的过程
执行流程判断链表是否为空，为空不用处理 将链表转化为数组 新链表中插入一个节点，方便后续操作 剩下的节点依次从头尾各取一个插入新链表中 判断是不是有一个单独的节点需要处理，防止重复加入 链表尾部置空 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: void reorderList(ListNode* head) { if(head==nullptr) return; //到这里链表中至少有一个节点 vector&lt;ListNode*&gt; node; //将链表转化为vector，这样就可以随机访问 while(head!=nullptr){ node.push_back(head); head=head-&gt;next; } int i=1,j=node.size()-1; ListNode *temp=new ListNode(0); head=node[0];//先加入一个节点 temp=head; while(i&lt;j){ temp-&gt;next=node[j]; temp=temp-&gt;next; temp-&gt;next=node[i]; temp=temp-&gt;next; i++; j--; } if(i==j){ temp-&gt;next=node[i]; temp=temp-&gt;next; } //不要忘记链表的尾部置空 temp-&gt;next=nullptr; } }; 总结重点是模拟插入的过程，不能出现空指针，并且head的位置不能变，所以需要加入一个新指针辅助节点的插入，并且需要先加入一个节点，方便统一后面节点的插入过程，以新增一个虚拟头结点是一样的道理
  ]]></content></entry><entry><title>24.两两交换链表中的节点</title><url>/post/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🔀 24.两两交换链表中的节点
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
示例示例 1：
1 2 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2：
1 2 输入：head = [] 输出：[] 示例 3：
1 2 输入：head = [1] 输出：[1] 思路基本思想相当于两两交换节点，两个为一组，进行交换，所以可以申请一个虚拟头结点指向给定的链表
申请虚拟头结点的目的是为了解决第一个节点的逆置问题，这样可以让首元结点与后面的节点处理方式一样，申请虚拟头结点的方式为：
1 ListNode *node=new ListNode(0); 这样才能申请一个正常的节点，之后就是两两逆置的思路，需要使用两个指针，完成逆置
逆置的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 p=node; q=node-&gt;next; while(p-&gt;next!=nullptr&amp;&amp;q-&gt;next!=nullptr){ //节点的两两逆转 p-&gt;next=q-&gt;next; q-&gt;next=q-&gt;next-&gt;next; p-&gt;next-&gt;next=q; //节点的向后移动 p=q; q=q-&gt;next; } 必须加上p-&gt;next!=nullptr，否则会报错，举例为[1,2,3,4]，因为交换两次之后，p指向4，q指向nullptr，nullptr无法访问next，就会出现空指针异常，所以两个判断条件都需要同时满足
执行流程初始化指针，分别为虚拟头结点以及两个辅助节点 执行逆置操作 返回虚拟头结点的下一个节点为最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: ListNode* swapPairs(ListNode* head) { if(head==nullptr) return head; ListNode *node=new ListNode(0); node-&gt;next=head; ListNode *p=nullptr; ListNode *q=nullptr; p=node; q=node-&gt;next; while(p-&gt;next!=nullptr&amp;&amp;q-&gt;next!=nullptr){ //节点的两两逆转 p-&gt;next=q-&gt;next; q-&gt;next=q-&gt;next-&gt;next; p-&gt;next-&gt;next=q; //节点的向后移动 p=q; q=q-&gt;next; } return node-&gt;next; } }; 如果上述代码无法理解，可以尝试将p看成slow指针，q看成fast指针：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: //两个指针一前一后移动，从而使得节点可以两两交换 ListNode* swapPairs(ListNode* head) { //链表中没有节点或者只有一个节点时不需要交换 if(head==nullptr||head-&gt;next==nullptr) return head; //到这里至少两个节点 ListNode* dummyHead=new ListNode(0); dummyHead-&gt;next=head; ListNode* fast=dummyHead-&gt;next; ListNode* slow=dummyHead; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ //两个节点交换 slow-&gt;next=fast-&gt;next; fast-&gt;next=fast-&gt;next-&gt;next; slow-&gt;next-&gt;next=fast; //移动指针，保持slow始终在待交换节点的前一个位置 slow=fast; fast=fast-&gt;next; } return dummyHead-&gt;next; } }; 需要一直保持slow指针在待交换的两个节点的前一个节点
总结主要有两个需要注意的地方：
申请一个虚拟头结点用来让首元结点与其他节点的操作逻辑一样 弄清楚逆置的逻辑，while的循环条件缺一不可   ]]></content></entry><entry><title>922.按奇偶排序数组II</title><url>/post/922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   #️ 922.按奇偶排序数组II
给定一个非负整数数组 nums， nums 中一半整数是 奇数 ，一半整数是 偶数 。
对数组进行排序，以便当 nums[i] 为奇数时，i 也是 奇数 ；当 nums[i] 为偶数时， i 也是 偶数 。
你可以返回 任何满足上述条件的数组作为答案 。
思路基本思想想法就是将奇数和偶数间接排列，偶奇偶奇偶奇偶奇这样的排列，所以需要将数组中的奇数和偶数分开来，第一想法就是遍历，遇到偶数就放到偶数位置，遇到奇数就放到奇数位置，所以需要两个下标，分别记录当前奇数和当前偶数的插入位置，一旦有插入就移动对应的下标
执行流程遍历输入 遇到偶数元素就插入到偶数下标对应的位置，偶数下标移动两个位置 遇到奇数元素就插入到奇数下标对应的位置，奇数下标移动两个位置 返回最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; nums) { //使用两个下标，一个奇数下标，一个偶数下标 //遇到奇数插入后就奇数下标移动 //遇到偶数插入后就偶数下标移动 //这样可以做到一次遍历就得到最终的结果 //不用再分开遍历 int even=0,odd=1; vector&lt;int&gt; res(nums.size(),0); for(int i=0;i&lt;nums.size();++i){ if(nums[i]%2==0){//遇到了偶数 res[even]=nums[i]; even+=2; }else{//遇到了奇数 res[odd]=nums[i]; odd+=2; } } return res; } }; 总结使用两个下标分开记录偶数和奇数的位置，避免了重复遍历，这样可以做到一次遍历就得到结果
  ]]></content></entry><entry><title>34.在排序数组中查找元素的第一个和最后一个位置</title><url>/post/34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🔢 34.在排序数组中查找元素的第一个和最后一个位置
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
思路基本思想如果不要求时间复杂度的话，可以直接使用遍历的方式，从左到右遍历，第一个相等的元素的位置就是开始位置，最后一个不相等的元素的前一个位置就是结束位置，但是本题中强调了时间复杂度
由于是排序数组，所以可以考虑二分查找，先找到相等的元素
找到之后，向左的第一个不相等位置的下一个位置就是开始位置，向右的第一个不相等位置的前一个位置就是结束位置
查找开始和结束位置时需要注意，防止下标越界，到了数组的两端就会强制结束，此时会有两种情况，一种是两端的位置时开始或结束位置
此时nums[right]==target或者nums[right]==target
数组的两端就是目标，如果只是单纯的到了数组两端，并且数组两端的元素并不是，目标，此时就需要执行left+1或者right-1，理解下面的代码即可
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int left=index,right=index; //增加left!=0是为了防止下标越界 while(nums[left]==target &amp;amp;&amp;amp; left!=0){ left--; } //找到了开始位置，判断是到了开头结束还是不相等结束 index=nums[left]==target?left:left+1; res[0]=index; //增加right!=nums.size()-1是为了防止下标越界 while(nums[right]==target &amp;amp;&amp;amp; right!=nums.size()-1){ right++; } //找到了结束位置,判断是到了末尾结束还是不相等结束 index=nums[right]==target?right:right-1; res[1]=index; while循环结束就需要分情况讨论，直接使用三目运算符分情况
执行流程代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 …  ]]></content></entry><entry><title>724.寻找数组的中心下标</title><url>/post/724.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   ❤‍🔥 724.寻找数组的中心下标
给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
思路基本思想找中心下标肯定是两端向中间逼近，这种题目适合用双指针法，从两头分别开始向中间移动。
最初的想法是从两端向中间移动，一旦有一端小了，这一端就需要累加，当两端一样大时，就同时累加，知道两个指针相遇，也就是：
左小于右，左向后累加 右小于左，右向前累加 两者相等，一起累加 但是这样只考虑了数组中元素为正的情况，一旦出现[-1,-1,-1,-1,-1,0]的情况，此时就会出现左边一直向后累加，直到走到数组末尾的情况，其实数组中的元素可以为负，错误代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int pivotIndex(vector&lt;int&gt;&amp; nums) { //从两端向中间移动，谁小移动谁，一旦相等就同时移动 int i=0,j=nums.size()-1; int rsum=nums[nums.size()-1]; int lsum=nums[0]; while(i&lt;j){ if(rsum&gt;lsum){//左边的小 ++i; lsum+=nums[i]; } else if(rsum&lt;lsum){//右边的小 --j; rsum+=nums[j]; } else{//两个一样大 ++i; --j; lsum+=nums[i]; rsum+=nums[j]; } } if(i==j) return i; else return -1; } }; 为了求出一个通用的办法，需要找出共性，中心点两边的元素和相等，一旦出现一个元素，两边的和相等，那么这个元素就是中心点
为了防止出现[1,2,3,1]中误以为元素2是中心点的情况，需要判断中心点元素加上两边元素和是不是数组的和，也就是2 * sum + nums[i] == total
找到共性
执行流程求出数组和 遍历数组元素，查看是否有2 * sum + nums[i] == total的元素，如果有的话此元素就是中心点，直接返回即可 代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int pivotIndex(vector&lt;int&gt;&amp; nums) { int total=accumulate(nums.begin(),nums.end(),0); int sum=0; for(int i=0;i&lt;nums.size();++i){ if(2*sum+nums[i]==total){ return i; } sum+=nums[i]; } return -1; } }; 总结需要找到题目的关键点，抽象成代码去解决问题，本题中要注意到中心点两边的元素和相等
也就是两边的和加上中心点的元素就是整个数组的和
  ]]></content></entry><entry><title>189.轮转数组</title><url>/post/189.%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   🔄 189.轮转数组
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
提示：
1 &lt;= nums.length &lt;= 105 -231 &lt;= nums[i] &lt;= 231 - 1 0 &lt;= k &lt;= 105 思路基本思想考研408的题目，直接将数组逆序三遍即可，但是需要注意k&gt;nums.size()的情况，k==nums.size()相当于走了一圈回到自身，没有任何变化，所以逆序之前需要做一件事，对k进行预处理，处理方式为： $$ k=k&gt;nums.size()?(k%nums.size()):k $$ 而不是： $$ k=k&gt;nums.size()?(k-nums.size()):k; $$ 因为k有可能比两个nums.size()还要大，其余的没有要注意的地方
执行流程编写逆序函数 预处理k 执行三遍逆序 代码根据以上分析，得出以下代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: //将元素三次逆序即可 void rotate(vector&lt;int&gt;&amp; nums, int k) { //因为k大于nums.size时，相当于走了一圈回到原地，做了无用功 //只有不回到原地的操作才是正确的 k=k&gt;nums.size()?k%nums.size():k; reverse(nums,0,nums.size()-k); reverse(nums,nums.size()-k,nums.size()); reverse(nums,0,nums.size()); } //传递的是引用才能将形参的改变传递给实参 void reverse(vector&lt;int&gt; &amp;nums,int start,int end){ for(int i=start,j=end-1;i&lt;j;++i,--j){ int temp=nums[i]; nums[i]=nums[j]; nums[j]=temp; } } }; 总结注意逆序之前k需要预处理，因为有可能k&gt;nums.size()
并且逆序时需要传递引用，否则逆序之后的结果无法保存
  ]]></content></entry><entry><title>941.有效的山脉数组</title><url>/post/941.%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   ⛰ 941.有效的山脉数组
给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。
让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组：
arr.length &gt;= 3 在 0 &lt; i &lt; arr.length - 1 条件下，存在 i 使得： arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1] 思路基本思想能找到一个一个数，这个数的右边和左边都成递减趋势，并且是严格递减，而不能存在相等的情况
所以需要找到变化的点，也就是找到先上升在下降的点，上升时严格上升，递减时严格递减
在转折点之前必须严格递增，转折点之后必须严格递减，并且转折点之后严格递减，所以需要模拟严格递增的过程，一旦出现递减，说明找到了转折点，并且需要判断转折点在哪
递减的过程中不能出现递增或者想等的情况，模拟上述过程即可
执行流程为了递增过程的连续性，先使用一个while循环模拟递增的过程 递增过程中一旦出现相等，直接返回false，一旦出现递减，说明找到了转折点 判断转折点是不是开头或末尾，防止[2,1]或者[1,2,3]的情况 递减过程中一旦出现相等，直接返回false，一旦出现递增，也返回false 遍历到了末尾说明一直符合要求，此时才返回true 代码根据以上分析，得出以下代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: bool validMountainArray(vector&lt;int&gt;&amp; arr) { if(arr.size()&lt;3) return false; int i=0; int max=INT_MIN; while(i&lt;arr.size()-1){//严格递增的代码 if(arr[i+1]==arr[i]){ return false; } else if(arr[i+1]&lt;arr[i]) { break; } i++;//严格递增就i++ }//到这里就是找到了转折点,并且之前的元素都是严格递增 if(i==0||i==arr.size()-1) return false; while(i&lt;arr.size()-1){ if(arr[i+1]&gt;=arr[i])//一旦出现等于或者递增的情况，直接返回false return false; i++;//严格递减就i++ } return true; } }; 总结需要找到这个转折点，从而判断两端是否是严格递增递减
  ]]></content></entry><entry><title>2.集群环境搭建</title><url>/post/2.%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url><categories><category>学习笔记</category></categories><tags><tag>k8s</tag></tags><content type="html"> 😄2.集群环境搭建
集群环境搭建
环境规划
集群类型
kubernetes集群大体上分为两类：一主多从和多主多从
一主多从：一台master，多台node，搭建简单，但是master出现错误，整个集群不再可用 多主多从：多台master，多台node，搭建麻烦，但是容错率高 为了简单，本文中使用一主两从
安装方式
目前生产部署Kubernetes 集群主要有两种方式：
1.kubeadm（本文中采用）
Kubeadm 是一个K8s 部署工具，提供kubeadm init 和kubeadm join，用于快速部署Kubernetes 集群。
官方地址：https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/
2.二进制包
从github 下载发行版的二进制包，手动部署每个组件，组成Kubernetes 集群。
Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，利于后期维护。
kubeadm 部署
kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：
创建一个Master 节点kubeadm init 将Node 节点加入到当前集群中$ kubeadm join &amp;amp;lt;Master 节点的IP 和端口&amp;amp;gt; 安装要求
在开始之前，部署Kubernetes 集群机器需要满足以下几个条件：
一台或多台机器，操作系统CentOS7.x-86_x64 硬件配置：2GB 或更多RAM，2 个CPU 或更多CPU，硬盘30GB 或更多 集群中所有机器之间网络互通 可以访问外网，需要拉取镜像 禁止swap 分区 最终目标
在所有节点上安装Docker 和kubeadm 部署Kubernetes Master 部署容器网络插件 部署Kubernetes Node，将节点加入Kubernetes 集群中 部署Dashboard Web 页面，可视化查看Kubernetes 资源 准备环境
角色 IP地址 组件 k8s-master01 192.168.5.3 …</content></entry><entry><title>1365.有多少小于当前数字的数字</title><url>/post/1365.%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"><![CDATA[   󠀼󠀼👌1365.有多少小于当前数字的数字
给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。
换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i]
以数组形式返回答案。
思路基本思想相比于单调栈，本题中求的是所有比自己小的元素，可以用暴力算法，依次拿数组中的每一个元素去和数组中每一个元素比较，从而统计得到结果，此时需要双层循环，代码为:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ans(nums.size(),0); for(int i=0;i&lt;nums.size();++i){ for(int j=0;j&lt;nums.size();++j){ //找到比自己小的元素 if(nums[i]&gt;nums[j]){ ans[i]+=1; } } } return ans; } }; 为了减少运行的时间复杂度，可以先对元素进行升序排序，这样小于自己的都在自己的前面，并且当前元素的下标就代表了前面有几个小于自己的元素
但是有一个特殊情况：
当两个数字相同时，第一个2的下标为1，代表前面有一个比自己小的元素，符合要求，但是第二个2的下标为2，代表前面有两个比自己小的元素，显然有错误
所以可以从后向前遍历，这样第二个二的结果就会被第一个二覆盖，形成正确的结果
知道每个元素有几个比自己小的元素之后，还需要调整位置，不能以排序之后的位置提交代码
相当于先对nums进行排序，并且nums原有的顺序要有记录
执行流程定义一个新的vector存储nums中的数据，对这个vector排序，防止nums中的元素顺序改变 定义一个unordered_map，用来存储每个元素有几个小于自己的元素，当成一个字典 为了形成最终的结果，不能直接使用排序后统计的结果，所以还需要调整顺序 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ans(nums.size(),0); vector&lt;int&gt; vec=nums; sort(vec.begin(),vec.end()); unordered_map&lt;int,int&gt;temp; for(int i=vec.size()-1;i&gt;=0;--i){ //代表元素nums[i]前面有i个小于自己的元素 temp[vec[i]]=i; } //调整位置，将temp当成一个字典 //使用unordered_map效率更高 for(int i=0;i&lt;nums.size();++i){ ans[i]=temp[nums[i]]; } return ans; } }; 总结对元素进行排序，从而巧妙的得到有几个元素比自己小，遇到相同的元素时，从后向前遍历，可以覆盖错误的结果，所以也是一个技巧
并且最终要求的结果是不能排序的，所以还需要调整结果的顺序，所以不能直接对nums的数据排序，需要单独定义一个vector来排序
  ]]></content></entry><entry><title>503.下一个更大元素II</title><url>/post/502.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</url><categories><category>leetcode</category></categories><tags><tag>单调栈</tag></tags><content type="html"><![CDATA[   🧭 503.下一个更大元素II
给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。
数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。
思路基本思想相比于739题，增加了一个限制条件，数组变成循环数组，走到最后会回到开始，并且找到第一个比自己大的元素时，存储到不是元素的下标，而是元素的值
所以为了实现循环，当前元素下标变化不再是简单的++i，而是变成(i+1)%nums.size()，这样即使走到了末尾也会回到开头，也就是末尾的下一个元素是开头的元素，可以模拟遍历两次nums，这样就可以变成循环数组
执行流程初始化ans数组全为-1，因为一旦元素找不到比自己大的元素，结果就为1 设置元素遍历两遍，这样就可以走一圈走到自身，并且还不至于一直循环 返回最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { stack&lt;int&gt; s; vector&lt;int&gt; ans(nums.size(),-1); s.push(0); //这里不用for(int i=1;i&lt;nums.size();(i+1)%nums.size()) //否则会陷入死循环 for(int i=1;i&lt;nums.size()*2;++i){ if(nums[i%nums.size()]&lt;=nums[s.top()]){ s.push(i%nums.size()); }else{ while(!s.empty()&amp;&amp;nums[i%nums.size()]&gt;nums[s.top()]){ ans[s.top()]=nums[i%nums.size()]; s.pop(); } s.push(i%nums.size()); } } return ans; } }; 总结元素至多找一圈就可以找到第一个比自己大的元素，代码中模拟遍历了两遍nums，是为了控制最终代码能够正常结束，如果遍历逻辑为：
1 for(int i=1;i&lt;nums.size();(i+1)%nums.size()) 那么代码永远不会停止，因为i永远小于nums.size()，但是正确答案已经存储到了ans当中，所以代码控制遍历的长度，两边以内肯定可以找到最终的结果
整个数组中肯定只有一种元素找不到第一个比自己大的元素，因为他就是全局最大的元素
遍历两遍是为了控制循环可以正常退出，并且遍历两遍一定可以找到最终的结果
一旦出现当前元素大于栈顶元素，那么栈顶元素就找到了第一个更大的元素，因为是
  ]]></content></entry><entry><title>496.下一个元素I</title><url>/post/496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0i/</url><categories><category>leetcode</category></categories><tags><tag>单调栈</tag></tags><content type="html"><![CDATA[   👾 496.下一个元素I
nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。
给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。
对于每个 0 &amp;lt;= i &amp;lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。
返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。
相当于在nums2中的元素统计比自己大的第一个元素的同时，增加了判断条件，只有出现在nums1中的元素才需要统计
思路基本思想按照739题的思想先求第i个元素的右边第一个大于自己的元素，找到之后看第i个元素是不是nums1中的元素，如果是的话，那么当前统计的结果就有用，如果不是的话，当前栈顶元素就不用统计
本题与739题的不同是，739题求的是元素的距离，本题求的是第一个比自己大的元素的值，不再是求距离，所以可以直接将当前元素作为结果存储到ans中
对应的查询逻辑为：
1 2 3 4 5 6 7 8 9 10 11 12 if (nums2[i] &amp;lt;= nums2[st.top()]) { st.push(i); } else { while (!st.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[st.top()]) { //看栈顶元素是否在nums1中 if (umap.find(nums2[st.top()]) !=umap.end()) { result[umap[nums2[s.top()]]]=nums2[i]; } st.pop(); } st.push(i); } 如果当前元素小于等于栈顶元素，对于栈顶元素来说没找到比自己大的元素，可以直接统计结果 如果当前元素大于栈顶元素，那么栈顶元素就找到了第一个比自己大的元素 如果当前栈顶元素在nums1中，那么就可以统计，因为题目最终求的就是nums1中的元素在nums2中的第一个比自己大的元素 如果当前栈顶元素不 …  ]]></content></entry><entry><title>739.每日温度</title><url>/post/739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url><categories><category>leetcode</category></categories><tags><tag>单调栈</tag></tags><content type="html"><![CDATA[   🌡️ 739.每日温度
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，在该位置用 0 来代替。
思路基本思想要与后面的数进行比较，然后结果传递给前面的数，所以第一想法就是暴力法，判断对于当前元素来说，下一个比他大的元素出现在后面的第几个位置，这样统计最终得到结果，暴力法的代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt;&amp;amp; temperatures) { vector&amp;lt;int&amp;gt; ans(temperatures.size(),0); for(int i=0;i&amp;lt;temperatures.size();++i){ int index=0; //从当前元素开始找 for(int j=i;j&amp;lt;temperatures.size();++j){ //当前元素不比第i个元素大，就继续找 if(temperatures[j]&amp;lt;=temperatures[i]){ ++index; }else{//找到比第i个元素大的元素 ans[i]=index; break;//退出当前循环 } } //内层for循环结束都没有找到比第i个元素大的，就不更新 //此时ans为0 } return ans; } }; 当测试用例过长时，程序运行超时
像这种寻找一个元素的左边或者右边，第一个比自己大或者比自己小的元素的位置，可以使用单调栈
单调栈有两个注意的点：
栈中存放的是元素的下标，这样取元素时直接拿着下标去原数组中找即可 栈中的元素从栈顶到栈底需要满足一定的条件，递增或递减 知道这两点之后，在具体情况具体分析
本题中，求的是第i个元素的右边第一个比自己大的元素，也就是说比较小的元素都不统计，所以单调栈的栈顶到栈底的元素需要递增，这样满足第i个元素后面的元素全是小于等于自己的
一旦出现大于自己的元素，就说明找到了第一个大于自己的元素，可以用下标相减的方式来计算这个元素隔了几个位 …  ]]></content></entry><entry><title>Kubernetes集群完整搭建步骤</title><url>/post/kubernetes%E9%9B%86%E7%BE%A4%E5%AE%8C%E6%95%B4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</url><categories><category>教程</category></categories><tags><tag>k8s</tag></tags><content type="html"> kubernetes集群完整搭建步骤
使用Ubuntu搭建k8s集群的完整步骤，包含常见错误解决办法
前言
k8s介绍
用于自动部署、扩展和管理“容器化应用程序”的开源系统
kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器&amp;amp;mdash;-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。
kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：
自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器 弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整 服务发现：服务可以通过自动发现的形式找到它所依赖的服务，想要什么服务就自动去寻找 负载均衡：如果一个服务启动了多个容器，能够自动实现请求的负载均衡 版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本 存储编排：可以根据容器自身的需求自动创建存储卷 从上图中可以看出k8s的整体结构，一个k8s集群主要分为两类节点，一类是master节点，一类是工作节点，也就是主节点和从节点，具体的区别如下：
主节点主要用来管理集群，接受客户端的请求，安排容器的执行并且运行控制循环 从节点主要用来部署应用，听从主节点的调度 环境规划
集群类型
kubernetes集群大体上分为两类：一主多从和多主多从
一主多从：一台master，多台node，搭建简单，但是master出现错误，整个集群不再可用 多主多从：多台master，多台node，搭建麻烦，但是容错率高 为了简单，本文中使用一主两从
安装方式
目前生产部署Kubernetes 集群主要有两种方式：
1.kubeadm（本文中采用）
Kubeadm 是一个K8s 部署工具，提供kubeadm init 和kubeadm join，用于快速部署Kubernetes 集群。
官方地址：https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/
2.二进制包
从github 下载发行版的二进制包，手动部署每个组件，组成Kubernetes 集群。
Kubeadm 降低部署门槛，但屏蔽 …</content></entry><entry><title>3.资源管理</title><url>/post/3.%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url><categories><category>学习笔记</category></categories><tags><tag>k8s</tag></tags><content type="html"><![CDATA[   😄3.资源管理
资源管理资源管理介绍在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。
kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。
kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在Pod中，而kubernetes一般也不会直接管理Pod，而是通过Pod控制器来管理Pod
Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了Service资源实现这个功能。
当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种存储系统。
学习kubernetes的核心，就是学习如何对集群上的Pod、Pod控制器、Service、存储等各种资源进行操作
YAML语言介绍YAML是一个类似 XML、JSON 的标记性语言。它强调以数据为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称&amp;quot;一种人性化的数据格式语言&amp;quot;。
1 2 3 4 &amp;lt;heima&amp;gt; &amp;lt;age&amp;gt;15&amp;lt;/age&amp;gt; &amp;lt;address&amp;gt;Beijing&amp;lt;/address&amp;gt; &amp;lt;/heima&amp;gt; 1 2 3 heima: age: 15 address: Beijing YAML的语法比较简单，主要有下面几个：
大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格( 低版本限制 ) 缩进的空格数不重要，只要相同层级的元素左对齐即可 &amp;lsquo;#&amp;lsquo;表示注释 YAML支持以下几种数据类型：
纯量：单个的、不可再分的值 对象：键值对的集合，又称为映射（mapping）/ 哈希（hash） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期 # 1 布尔类型 c1: true (或者True) # 2 整型 c2: 234 # 3  …  ]]></content></entry><entry><title>516.最长回文子序列</title><url>/post/516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   🔄516.最长回文子序列
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
思路基本思想本题与647题有点类似，只不过647题求的是回文串的数量，并且是回文子串而不是回文子序列，也就是不能删除元素，本题可以删除元素，那么就会导致出现问题
本题中的dp[i][j]代表i~j范围内最长的回文子序列长度，当两个元素相等时，判断逻辑如下：
1 2 3 if(s[i]==s[j]){ dp[i][j]=dp[i+1][j-1]+2; } 当然有一种特殊情况，只有一个元素时，也满足s[i]==s[j]，可是此时不能+2，只能+1，所以这种情况单独拿出来统计，剩下的情况即使aa这种字符串，s[0]==s[1]，那么dp[0][1]=dp[1][0]+2
而dp[1][0]已经被初始化为0，所以不会有问题
当两个元素不相等时，类似于abac，此时a和c不匹配，但是可以去除一个元素，所以我们分别取出a和c，判断是否形成新的回文子串，是的话就更新dp数组，并且以去除元素形成的回文子序列作为当前的结果累加到后面，形成最终的结果，例如：
当前子串为abac，整体子串为abacaba，当前子串的回文子序列问aba，累加到后面，最终的结果为abaaba
理解如下的执行流程：
执行流程初始化dp数组，全为0 按照更新逻辑更新dp数组 返回最终的结果 理解如下的执行流程：
忘记怎么做，就按照图，对着代码模拟一遍
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int longestPalindromeSubseq(string s) { vector&lt;vector&lt;int&gt;&gt;dp(s.size(), vector&lt;int&gt;(s.size(),0)); //s至少有一个元素，所以回文子序列的长度至少为1 int res=1; //防止出现一个元素时，直接+2的情况 for(int i=0;i&lt;s.size();++i) dp[i][i]=1; for(int i=s.size()-1;i&gt;=0;--i){ //j从i+1开始，就是去除只有一个元素的情况 //只有一个元素的情况单独处理了 for(int j=i+1;j&lt;s.size();++j){ if(s[i]==s[j]){ dp[i][j]=dp[i+1][j-1]+2; }else{ //当两个元素不相等时，判断去除一个元素会不会形成回文子序列 //abac的情况 dp[i][j]=max(dp[i+1][j],dp[i][j-1]); } res=max(res,dp[i][j]); } } return res; } }; 总结在647题上做出改进，也是求当前子串是不是回文子串，并且当两个元素不相等时可以删除，如果删除之后可以形成回文子串，那么就可以累加到后面
并且由于判断逻辑，当前两个元素相等时，一次+2，所以只有一个元素的情况需要单独处理，j从i+1开始遍历，所以每次遍历至少有两个元素，+2符合逻辑
  ]]></content></entry><entry><title>647.回文子串</title><url>/post/647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   🔄647.回文子串
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。
子字符串 是字符串中的由连续字符组成的一个序列。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例示例 1： 输入：s = &amp;ldquo;abc&amp;rdquo; 输出：3 解释：三个回文子串: &amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;
示例 2： 输入：s = &amp;ldquo;aaa&amp;rdquo; 输出：6 解释：6个回文子串: &amp;ldquo;a&amp;rdquo;, &amp;ldquo;a&amp;rdquo;, &amp;ldquo;a&amp;rdquo;, &amp;ldquo;aa&amp;rdquo;, &amp;ldquo;aa&amp;rdquo;, &amp;ldquo;aaa&amp;rdquo;
两个aa不一样的原因是因为结束位置不同，但是为什么只有两个aa，应该有三个aa？
提示：
1 &amp;lt;= s.length &amp;lt;= 1000 s 由小写英文字母组成 思路基本思想需要求出字符串的全部子串，然后判断每一个子串是不是回文串，也就是求出当前字符串的幂集，然后统计幂集中的所有回文子串的数目，不包括空集
所以得到了一下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: vector&amp;lt;char&amp;gt; path; int res=0; int countSubstrings(string s) { backtrack(s,0); return res; } //回溯法求解字符串的幂集 void backtrack(string s,int index){ if(isCircle(path))//是回文串结果加一 ++res; if(index==s.size()) return; for(int i=index;i&amp;lt;s.size();++i){ path.push_back(s[i]); backtrack(s,i+1); //回溯完成之后返回 path.pop_back(); } } //判断一个字符串是 …  ]]></content></entry><entry><title>Kubernetes完整版笔记</title><url>/post/kubernetes%E5%AE%8C%E6%95%B4%E7%89%88%E7%AC%94%E8%AE%B0/</url><categories><category>学习笔记</category></categories><tags><tag>k8s</tag></tags><content type="html"> 😄kubernetes
kubernetes的完整学习笔记，与黑马课堂笔记一样
Kubernetes介绍
部署方式演变
在部署应用程序的方式上，主要经历了三个时代：
传统部署：互联网早期，会直接将应用程序部署在物理机上
优点：简单，不需要其它技术的参与
缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响
虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境
优点：程序环境不会相互产生影响，提供了一定程度的安全性
缺点：增加了操作系统，浪费了部分资源
容器化部署：与虚拟化类似，但是共享了操作系统
优点：
可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等
运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦
容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署
容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：
一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器 当并发访问量变大的时候，怎么样做到横向扩展容器数量 这些容器管理的问题统称为容器编排问题，为了解决容器编排问题，就产生了一些容器编排的软件：
Swarm：Docker自己的容器编排工具 Mesos：Apache的一个资源统一管控的工具，需要和Marathon结合使用 Kubernetes：Google开源的的容器编排工具 kubernetes简介
kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器&amp;amp;mdash;-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。
kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：
自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器 弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整 服务发现：服务可以通过自动发现的形式找到它所依赖的服务，想要什么服务就自动去寻找 负载均衡：如果一个服务启动了多个容器，能够自动实现请求的负载均衡 版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本 存储编排：可以根据容器自身的需求自动创建存 …</content></entry><entry><title>Kubernetes集群管理工具kubectl</title><url>/post/kubernetes%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7kubectl/</url><categories><category>学习笔记</category></categories><tags><tag>k8s</tag></tags><content type="html"> 😄kubernetes集群管理工具kubectl
概述
kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署
命令格式
命令格式如下
1 kubectl [command] [type] [name] [flags] 参数
command：指定要对资源执行的操作，例如create、get、describe、delete type：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式 例如：
1 2 3 kubectl get pod pod1 kubectl get pods pod1 kubectl get po pod1 name：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源，例如 1 kubectl get pods flags：指定可选的参数，例如可用 -s 或者 -server参数指定Kubernetes API server的地址和端口 常见命令
kubectl help 获取更多信息
通过 help命令，能够获取帮助信息
1 2 3 4 5 # 获取kubectl的命令 kubectl --help # 获取某个命令的介绍和使用 kubectl get --help 基础命令
常见的基础命令
命令 介绍 create 通过文件名或标准输入创建资源 expose 将一个资源公开为一个新的Service run 在集群中运行一个特定的镜像 set 在对象上设置特定的功能 get 显示一个或多个资源 explain 文档参考资料 edit 使用默认的编辑器编辑一个资源 delete 通过文件名，标准输入，资源名称或标签来删除资源 部署命令
命令 介绍 rollout 管理资源的发布 rolling-update 对给定的复制控制器滚动更新 scale 扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Job autoscale 创建一个自动选择扩容或缩容并设置Pod数量 集群管理命令
命令 介绍 certificate 修改证书资源 cluster-info 显示集群信息 top 显示资源(CPU/M) cordon 标记节点不可调度 uncordon 标记节点可被调度 drain 驱逐节点上的应用， …</content></entry><entry><title>72.编辑距离</title><url>/post/72.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄72.编辑距离
给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
插入一个字符
删除一个字符
替换一个字符
思路基本思想错误代码
首先想到的就是word1要转换成word2，那么相同的部分肯定不用理会，只有不相等的部分才需要进行增删改，那么就可以先求出其最长公共子序列的长度，剩下的元素就需要变动
在变动时，就看谁剩下的元素更多，那么就将这些元素全部变动，最终word1和word2相等，核心就是在求最长公共子序列上，但是发现这样只能通过一部分示例：
问题在&amp;quot;intention，execution&amp;quot;这两个字符串上，在元素e的匹配上，ention中间有个多余的n
ecution中间有两个多余的cu，程序判断的逻辑会造成错误，因为程序判断的逻辑为：
1 max(word1.size()-res,word2.size()-res); res就是最长公共子序列，导致最后返回4，其实正确结果为5，错误代码为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;dp(word1.size()+1, vector&amp;lt;int&amp;gt;(word2.size()+1,0)); int res=0; for(int i=0;i&amp;lt;word1.size();++i){ for(int j=0;j&amp;lt;word2.size();++j){ if(word1[i]==word2[j]){ dp[i+1][j+1]=dp[i][j]+1; }else{ dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]); } res=max(res,dp[i+1][j+1]); } } return max(word1.size()-res,word2.size()-res); } }; 按照思路分析，无非就是一下几个操作：
dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符 …  ]]></content></entry><entry><title>583.两个字符串的删除操作</title><url>/post/583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄583.两个字符串的删除操作
给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。
每步 可以删除任意一个字符串中的一个字符。
思路基本思想与392题一样，需要将思路进行转换，从问题中发现关键的地方
本题中求的是尽可能少的删除字符串中的字符，使得两个字符串保持一致，既然要最少的删除，那么留下来的肯定是最大的，也就是可以先求两个字符串的最大公共子序列，之后两个字符串多余的元素就应该删除，这些元素的个数就是最终的答案
dp[i][j]表示以第i个元素和第j个元素结尾的两个字符串的最长公共子序列的长度
更新逻辑为：
1 2 3 4 5 6 if(s[i]==t[j]){ dp[i+1][j+1]=dp[i][j]+1; } else{ dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]); } 最终结果为： $$ word1.size()+word2.size()-2*res $$ 删除多余的部分
执行流程初始化dp数组 更新dp数组 返回最终结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt;dp(word1.size()+1, vector&lt;int&gt;(word2.size()+1,0)); int res=0; for(int i=0;i&lt;word1.size();++i){ for(int j=0;j&lt;word2.size();++j){ if(word1[i]==word2[j]){ dp[i+1][j+1]=dp[i][j]+1; }else{ dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]); } res=max(res,dp[i+1][j+1]); } } return word1.size()+word2.size()-2*res; } }; 总结主要是懂得思维的转换，尽可能少的删除元素使得两字符串保持一致，也就是尽可能多的留下元素，而最长公共子序列就留下了最多的元素，所以核心转换成了求最长公共子序列
  ]]></content></entry><entry><title>392.判断子序列</title><url>/post/392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄392.判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&ldquo;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。
思路基本思想判断一个字符串是不是另外一个字符串的子序列，可以转换一种思路，判断一个两个字符串的最长公共子序列的长度是多少，如果最长公共子序列的长度是s的长度，那么就可以说s是t的子序列
只要将问题转换成这个，就只需要在1143题的基础上增加一步判断，判断其最长公共子序列的长度是不是等于s的长度即可
而判断两个字符串的最长公共子序列的方法就是拿一个字符串的一个元素去与另外一个字符串的每个元素做对比，一旦出现匹配的元素，最长公共子序列的长度就递增，否则就说明有一个元素多余，此时换一种判断标准去更新dp数组
其中dp[i][j]表示以第i个元素和第j个元素结尾的两个字符串的最长公共子序列的长度
形成的判断逻辑为：
1 2 3 4 5 6 if(s[i]==t[j]){ dp[i+1][j+1]=dp[i][j]+1; } else{ dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]); } 执行流程初始化dp数组，使其元素全为零 遍历两个字符串，遍历的过程中更新dp数组 为了求最长公共子序列的长度，需要在更新的过程中记录出现的最大值 看最大值是不是s的长度，从而判断是不是t的子序列 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: bool isSubsequence(string s, string t) { vector&lt;vector&lt;int&gt;&gt;dp(s.size()+1, vector&lt;int&gt;(t.size()+1,0)); int res=0; for(int i=0;i&lt;s.size();++i){ for(int j=0;j&lt;t.size();++j){ if(s[i]==t[j]){ dp[i+1][j+1]=dp[i][j]+1; }else{ dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]); } res=max(res,dp[i+1][j+1]); } } return res==s.size(); } }; 总结主要是转换思想，先求两个字符串的最长公共子序列长度，最后在判断最长公共子序列的长度与s的长度是否相等，相等的话s就是t的子序列
  ]]></content></entry><entry><title>Kubeadm和二进制方式搭建k8s集群的对比</title><url>/post/kubeadm%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AF%B9%E6%AF%94/</url><categories><category>学习笔记</category></categories><tags><tag>k8s</tag></tags><content type="html"> 😄kubeadm和二进制方式搭建k8s集群的对比
Kubeadm方式
很多东西kubeadm已经配置好了，只需要init即可
安装虚拟机，在虚拟机安装Linux操作系统【3台虚拟机】 对操作系统初始化操作 所有节点安装Docker、kubeadm、kubelet、kubectl【包含master和slave节点】 安装docker、使用yum，不指定版本默认安装最新的docker版本 修改docker仓库地址，yum源地址，改为阿里云地址 安装kubeadm，kubelet 和 kubectl k8s已经发布最新的1.19版本，可以指定版本安装，不指定安装最新版本 yum install -y kubelet kubeadm kubectl 在master节点执行初始化命令操作 kubeadm init 默认拉取镜像地址 K8s.gcr.io国内地址，需要使用国内地址 安装网络插件(CNI) kubectl apply -f kube-flannel.yml 在所有的node节点上，使用join命令，把node添加到master节点上 测试kubernetes集群 二进制方式
很多东西都需要自己配置
安装虚拟机和操作系统，对操作系统进行初始化操作 生成cfssl 自签证书 ca-key.pem、ca.pem server-key.pem、server.pem 部署Etcd集群 部署的本质，就是把etcd集群交给 systemd 管理 把生成的证书复制过来，启动，设置开机启动 为apiserver自签证书，生成过程和etcd类似 部署master组件，主要包含以下组件 apiserver controller-manager scheduler 交给systemd管理，并设置开机启动 如果要安装最新的版本，下载二进制文件进行安装 部署node组件 docker kubelet kube-proxy【需要批准kubelet证书申请加入集群】 交给systemd管理组件- 组件启动，设置开机启动 批准kubelet证书申请 并加入集群 部署CNI网络插件 测试Kubernets集群【安装nginx测试】</content></entry><entry><title>53.最大子数组和</title><url>/post/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag><tag>贪心算法</tag></tags><content type="html"><![CDATA[   😄53.最大子数组和
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
思路贪心基本思想当前元素加上之后只要和不为负数，就可以对后面的元素产生正面的影响，至少相加之后不会拖后面元素后腿，所以只要是正数就一直加
相加的过程中，可能会出现正数被后面的负数拉低的情况，此时就需要一个全局的res来统计出现的最大和，当出现负数和时，对后面的元素无法起到正面的影响，会拖后腿，还不如不加，所以当前的和直接变为0，从当前位置开始重新累加
为正就继续加，为负就直接为0
执行流程从前向后遍历 正数和就直接向后加，负数和就变成0 统计遍历过程中的最大值作为最终的结果 动态规划思想当前位置的和肯定与之前的元素和有关，所以使用动态规划解题
当前元素加上之前的和还不如当前元素本身大，说明前面的和为负数，此时还不如不加，对应贪心中的步骤就是和置0，然后从当前位置开始加，对应到动态规划中，就是当前位置的和变成自身，以供后面的元素使用
后面的元素加上前面的和变得更大，那么就继续加，更新当前的dp数组，对应的递推方程为： $$ dp[i+1]=max(dp[i]+nums[i],nums[i]) $$
dp[i]的含义是累加到第i个元素得到的最大和
更新dp的过程中需要记录最大的和作为最终的结果
对当前元素有增益就加，没增益就不加
执行流程初始化dp数组全为0，对累加的和没有影响 按照递推方程更新dp数组 更新过程中统计最大的和作为最终的结果 代码贪心1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { //记录最大值的标志 int res=INT32_MIN; //记录序列的累加和 int sum=0; //遍历容器 for(int i=0;i&lt;nums.size();++i){ sum+=nums[i]; //每走一步就统计一下最大值 //并且必须放在累加之后，因为有可能最大序列和是负数 //此时就会 if(sum&gt;res) res=sum; //小于零的序列和舍弃 if(sum&lt;0) sum=0; } return res; } }; 动态规划1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size()+1,0); int res=INT_MIN; for(int i=0;i&lt;nums.size();++i){ dp[i+1]=max(dp[i]+nums[i],nums[i]); res=max(res,dp[i+1]); } return res; } }; 总结不管是贪心还是动态规划，只要对当前元素有正面的影响，前面的元素就应该累加到当前元素上，如果没有正面的影响，前面的累加和结果就应该丢弃，对应到贪心中就是累加和为0，对应到动态规划中就是当前的dp变成当前元素本身，也相当于累加和为0
  ]]></content></entry><entry><title>1035.不相交的线</title><url>/post/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   🔃1035.不相交的线
在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
以这种方法绘制线条，并返回可以绘制的最大连线数。
思路基本思想只有相等才能绘制一条直线，并且线不能相交，这与最长公共子序列是一样的思路，只不过描述成了划线的步骤，所以可以根据最长公共子序列的思路做题
没有连接的线说明他们俩不匹配，是多余的元素，去掉多余的元素不影响线的连接，但是不能改变元素的相对位置，相当于线不能交叉
与1143题最长公共子序列是一样的思路，只不过换了一个描述
执行流程初始化dp数组 按照递推方程更新dp数组 返回最后的元素作为最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1,0)); for(int i=0;i&lt;nums1.size();++i){ for(int j=0;j&lt;nums2.size();++j){ if(nums1[i]==nums2[j]){ dp[i+1][j+1]=dp[i][j]+1; }else{//当前两个数无法连线 dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]); } } } return dp[nums1.size()][nums2.size()]; } }; 总结当前两个数可以连线，直接结果数+1
当前两个数无法连线，那么有一个数是多余的，只有一个多余，而不是至少一个多余，要想明白这个逻辑，因为是拿nums1中的一个元素与nums2中的所有元素依次比较，比较到一个不相等的位置，说明当前有一个元素多余，返回较长的公共子序列长度作为当前的结果
  ]]></content></entry><entry><title>1143.最长公共子序列</title><url>/post/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄1143.最长公共子序列
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，&ldquo;ace&rdquo; 是 &ldquo;abcde&rdquo; 的子序列，但 &ldquo;aec&rdquo; 不是 &ldquo;abcde&rdquo; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
思路基本思想与718题很像，但是本题是求公共的子序列长度，子序列不要求连续，只要相对位置不改变就可以成为子序列，所以在比较时不是不相等就不比较，当当前两个元素不相等，可能之前的元素有相等的，所以还需要看之前的元素是不是相等
本题中的dp[i][j]代表以第i个元素和第j个元素结尾的两个字符串的最长公共子序列长度
具体这个看之前的元素是不是相等的判断逻辑 体现在代码中为：
1 2 3 4 5 if (text1[i - 1] == text2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } 只要当前的两个元素不相等，那么就返回之前的元素中子序列长度最长的结果
体现在图中就是：
当前的元素不相等时，说明以当前两个元素结尾的字符串公共子序列长度不可能增加，就选择最长的公共子序列长度作为当前的结果，更新当前的结果供后面的元素匹配时使用
主要理解这个图的更新过程，求的是当前位置的最长公共子序列
执行流程初始化dp数组，让其都为0 根据递推公式更新dp数组 返回最终的元素当成最后的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&lt;vector&lt;int&gt;&gt; dp(text1.size()+1, vector&lt;int&gt;(text2.size()+1,0)); for(int i=0;i&lt;text1.size();++i){ for(int j=0;j&lt;text2.size();++j){ if(text1[i]==text2[j]){//匹配说明最长公共子序列长度要增加 dp[i+1][j+1]=dp[i][j]+1; }else{//不匹配就统计以这两个元素结尾的最长公共子序列 dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]); } } } return dp[text1.size()][text2.size()]; } }; 总结主要分为两点：
当前两个元素匹配时，最长公共子序列的长度肯定最长
当前两个元素不匹配时，说明有一个元素多余了，此时就看是谁多余了
使用max函数统计当前两个元素去掉其中一个的最长公共子序列长度作为当前的结果
以便以后面的元素使用
统计以当前两个元素结尾的字符串的最长公共子序列长度即可
看懂图片中的更新过程   ]]></content></entry><entry><title>使用kubeadm搭建k8s集群</title><url>/post/%E4%BD%BF%E7%94%A8kubeadm%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4/</url><categories><category>学习笔记</category></categories><tags><tag>k8s</tag></tags><content type="html"> 😄使用kubeadm搭建k8s集群
使用kubeadm工具搭建k8s集群，屏蔽搭建集群时的一些细节，使得搭建集群变得简单
使用kubeadm方式搭建K8S集群
kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。
这个工具能通过两条指令完成一个kubernetes集群的部署：
1 2 3 4 5 # 创建一个 Master 节点 kubeadm init # 将一个 Node 节点加入到当前集群中 kubeadm join &amp;amp;lt;Master节点的IP和端口 &amp;amp;gt; Kubeadm方式搭建K8S集群
使用kubeadm方式搭建K8s集群主要分为以下几步
准备三台虚拟机，同时安装操作系统CentOS 7.x 对三个安装之后的操作系统进行初始化操作 在三个节点安装 docker kubelet kubeadm kubectl 在master节点执行kubeadm init命令初始化 在node节点上执行 kubeadm join命令，把node节点添加到当前集群 配置CNI网络插件，用于节点之间的连通【失败了可以多试几次】 通过拉取一个nginx进行测试，能否进行外网测试 安装要求
在开始之前，部署Kubernetes集群机器需要满足以下几个条件：
一台或多台机器，操作系统 CentOS7.x-86_x64 硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多【注意master需要两核】 可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点 禁止swap分区 准备环境
角色 IP master 192.168.177.130 node1 192.168.177.131 node2 192.168.177.132 然后开始在每台机器上执行下面的命令
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 关闭防火墙 systemctl stop firewalld systemctl disable firewalld # 关闭selinux # 永久关闭 sed -i …</content></entry><entry><title>1.Kubernetes简介</title><url>/post/1.kubernetes%E4%BB%8B%E7%BB%8D/</url><categories><category>学习笔记</category></categories><tags><tag>k8s</tag></tags><content type="html"> 😄1.Kubernetes简介
对Kunbernetes的一些基础介绍
Kubernetes介绍
部署方式演变
在部署应用程序的方式上，主要经历了三个时代：
传统部署：互联网早期，会直接将应用程序部署在物理机上
优点：简单，不需要其它技术的参与
缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响
虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境
优点：程序环境不会相互产生影响，提供了一定程度的安全性
缺点：增加了操作系统，浪费了部分资源
容器化部署：与虚拟化类似，但是共享了操作系统
优点：
可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等
运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦
容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署
容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：
一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器 当并发访问量变大的时候，怎么样做到横向扩展容器数量 这些容器管理的问题统称为容器编排问题，为了解决容器编排问题，就产生了一些容器编排的软件：
Swarm：Docker自己的容器编排工具 Mesos：Apache的一个资源统一管控的工具，需要和Marathon结合使用 Kubernetes：Google开源的的容器编排工具 kubernetes简介
kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器&amp;amp;mdash;-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。
kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：
自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器 弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整 服务发现：服务可以通过自动发现的形式找到它所依赖的服务，想要什么服务就自动去寻找 负载均衡：如果一个服务启动了多个容器，能够自动实现请求的负载均衡 版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本 存储编排： …</content></entry><entry><title>718.最长重复子数组</title><url>/post/718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄718.最长重复子数组
给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。
思路基本思想拿一个数组中的元素去与另外一个数组中的元素进行匹配，一旦遇到了相同的元素，后面的元素依次匹配，直到遇到第一个不匹配的元素，就这样一直统计，返回统计出现的最大值，就是公共最长子数组的长度
根据上面的流程分析，可以判断得到当前元素的最长公共子数组与前面的元素有关，所以我们可以利用动态规划来做，当前元素一旦相等，当前元素的对应的dp数组就有可能更新，并且更新与前一个元素有关
所以设置一个二维dp数组，dp[i][j]代表以第i个元素和第j个元素结尾的两个数组，最长公共子数组的长度是多大
形成的递推方程为： $$ dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1) $$ 取max是因为防止[0,1,3,2,1]和[0,1,3]中更新1出现的问题，其实1对应的dp应该是2，但是最后的1也会进行匹配，不加max会导致1对应的dp数组变成1
执行流程初始化二维dp数组，使其全为0，这样匹配时初次匹配的两个元素对应的dp会变成1 按照递推方程更新dp数组 更新dp数组的过程中，统计出现的最大值 返回最大值作为最终的结果 代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt;dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0)); int res = 0; for(int i=0;i&lt;nums1.size();++i){ for(int j=0;j&lt;nums2.size();++j){ if(nums1[i]==nums2[j]){//遇到匹配的元素就可能更新dp数组 dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+1); } //当前元素对应的dp数组中的元素应该+1，因为下标0对应第一个元素 if(res&lt;dp[i+1][j+1]) res=dp[i+1][j+1]; } } return res; } }; 总结与300题类似，遇到相等的元素就可能更新，所以设置对应的递推方程
拿第一个数组中的元素依次与第二个数组中的每一个元素进行比较，公共的长度与前面的元素有关
  ]]></content></entry><entry><title>674.最长连续递增子序列</title><url>/post/674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄674.最长连续递增子序列
给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], &hellip;, nums[r - 1], nums[r]] 就是连续递增子序列。
思路基本思想只要当前元素比前一个元素大，那么最长连续递增子序列的长度就可以+1，其余的任何情况，当前元素对应的dp数组中的元素为1，因为破坏了最大连续递增中的连续，所以直接为1，遍历的过程中统计最大的结果即可
对应的判断逻辑为：
1 2 3 if(nuns[i]&gt;nums[i-1]){ dp[i]=dp[i-1]+1; } 执行流程初始化所有的dp数组为1，因为单独的一个元素也算连续递增 按照判断逻辑更新dp数组 统计dp数组中最大的元素，将其当成最终的结果返回 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) { if(nums.size()==1) return 1; vector&lt;int&gt; dp(nums.size(),1); int res=0; for(int i=1;i&lt;nums.size();++i){ if(nums[i]&gt;nums[i-1]){ dp[i]=dp[i-1]+1; } res=max(res,dp[i]); } return res; } }; 总结相比300题求最长递增子序列，本题中增加了连续的条件，使得问题变得简单，一旦前后元素破坏了连续递增的条件，就会回归到最小的递增长度1，一旦前后元素满足连续递增的条件，就会在前一个元素的基础上将系列长度+1
而300题是求最长递增子序列，需要在当前元素的前面所有元素中找出比当前元素小的组成递增子序列，所以遇到比当前元素小的元素就可能会更新dp，具体的分析见300题题解
  ]]></content></entry><entry><title>300.最长递增子序列</title><url>/post/300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄300.最长递增子序列
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
思路基本思想当前位置的最长递增子序列的长度肯定和之前的元素有关，所以考虑动态规划，主要是递推方程的确定，本题中dp[j]代表第j个元素之前有多少个元素比当前元素大，包括本身，因为单独一个元素，递增子序列长度为1，换句话说就是以nums[i]结尾的最长递增子序列长度
对当前元素来说，前面有很多元素，只要比其中的某一个元素大，都算是递增，此时递增子序列的长度就有可能增加，但是也不是肯定增加，举例来说，[4,3,5,6,2,8]中dp[8]=4而不是2，因为dp[8]取的是前面的元素中最长的递增子序列长度，而不是遇到一个比他小的就更新
最终的递推方程为： $$ dp[i]=max(dp[i],dp[j]+1) $$ 要看当前更新是不是能变大
不能直接使用一下判断语句更新dp，这个判断语句是连续递增时可以使用：
1 2 3 if(nums[i]&gt;nums[i-1]){ dp[i]=dp[i-1]+1; } 这样在例子[4,10,4,3,8,9]中会出错，元素9比元素8大，但是他们两个的dp是一样的，因为前面有一个元素10，导致他们不能随意的增加
在之前的元素中找出最长的递增子序列，当前元素之前的所有比当前元素小的元素组成了最长的递增子序列
执行流程初始化dp数组，初始值为1，因为[7,7,7,7]的最终结果为1
按照递推方程进行更新
对于每一个元素，找出以它结尾的最长递增子序列
返回最终结果
由于最后一个元素不一定是全局最大的元素，所以dp数组的最后一个元素保存的不是最终的结果，需要找出dp数组中最大的值作为最终的结果
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { if(nums.size()==1) return 1; vector&lt;int&gt; dp(nums.size(),1); int res=0; for(int i=1;i&lt;nums.size();++i){ for(int j=0;j&lt;i;++j){ //找到了比当前元素小的元素，dp可能更新 if(nums[i]&gt;nums[j]){ dp[i]=max(dp[i],dp[j]+1); } } //当前元素统计完成之后，统计最终结果 res=max(res,dp[i]); } return res; } }; 总结确定好递推方程，判断当前元素之前有几个比他小的，更新当前元素结尾的最长递增子序列，最终返回最大的序列长度作为最终的结果
对于每个元素都判断之前有几个元素比他小，从而更新自己的最长递增子序列
  ]]></content></entry><entry><title>213.打家劫舍II</title><url>/post/213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄213.打家劫舍II
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
思路基本思想相比于198题，本题只是多了一个限制条件，头尾也变成邻居，也就是第一个房屋被偷，最后一个房屋就不能被偷，每偷一个房间，至少隔一个房间才能继续偷
影响解题的因素就是头尾两个房间连起来了，所以我们将其分开，分情况讨论：
去掉头部元素 去掉尾部元素 去掉之后可以将其当成198题进行统计，由于统计的过程中情况1有可能不选择尾部元素，情况2有可能不选择头部元素，所以同时不选择头尾的元素这种情况已经被包含了，剩下的就是198题的逻辑
执行流程按照情况分开，分别对情况1和情况2进行统计，最终返回大的结果
初始化dp数组 集体处理只有一个和两个元素的情况 按照递推公式进行统计 返回最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { //这两句不能忘掉，否则会出现下标越界的情况 if (nums.size() == 1) return nums[0]; if (nums.size() == 2) return max(nums[0],nums[1]); //到这里至少三个元素 int result1 = robRange(nums, 0, nums.size() - 1); int result2 = robRange(nums, 1, nums.size() ); return max(result1, result2); } // 198.打家劫舍的逻辑 int robRange(vector&lt;int&gt;&amp; nums, int start, int end) { vector&lt;int&gt; dp(nums.size()); dp[start] = nums[start]; //如果start=1时，这句初始化应该有问题 //因为dp[i]代表的是下标为[o,start]的房屋中能够获取到的最大金额 //而start=1时，dp[start+1]代表房屋的范围为[0,2]一共三个房屋 dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt; end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end-1]; } }; 总结主要是将头尾相接的问题分情况讨论，注意同时去掉头尾的情况已经包含在了情况1和情况2中
本题中dp数组按照下标进行更新，而不是按照元素在第几进行更新是因为去掉尾部时，元素以0开头，去掉头部时元素以1开头，开头的元素下标不固定，所以只能按照下标去访问
按照下标去访问，可以将不同区间的元素统一处理
  ]]></content></entry><entry><title>198.打家劫舍</title><url>/post/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄198.打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
思路基本思想求一夜之间的最大金额，并且相邻的房屋不能同时访问，所以要考虑的问题就是如何遍历提供的nums数组
记录奇数和偶数的和，哪个大返回哪个？ 这个思路看起来可以，但是遇到[2,1,1,2]会出错，不一定要隔一次选一个，有可能隔两次，三次
当前房屋偷不偷，看偷之后形成的总金额有没有不偷高 $$ dp[j]=max(dp[j-2]+nums[j],dp[j-1]) $$
其中dp[i]代表下标为[0,i]的房屋中能够获得的最大金额是多少
当前房屋如果偷了，前一家就不能偷，主要是看相邻的两个房屋偷谁
核心思想就是当前房屋偷了之后性价比高不高，站在当前的角度看前面，先不管后面的情况
按照公式更新即可
执行流程初始化dp数组全为0，便于后面的统计 注意nums数组只有一个元素的情况，因为统计时考虑的是前后两个元素，所以一个元素的情况需要单独处理 按照递推公式统计 返回最终的结果 代码按照以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: //并不是简单的偷奇数或者偶数，有可能隔好几个房间才偷一次，例如[2,1,1,2] //核心理念就是相邻的两个房屋只能偷一个 int rob(vector&lt;int&gt;&amp; nums) { //只有一个房间，那么这个房间肯定要被偷 if(nums.size()==1) return nums[0]; //到这里至少两个房间 vector&lt;int&gt; dp(nums.size(),0); dp[0]=nums[0]; dp[1]=max(nums[1],nums[0]); for(int i=2;i&lt;nums.size();++i){ //偷当前房间划算还是偷当前房间的前一个房间划算 //dp[i]代表下标为[0,i]的房屋中能够得到的最大金额 //更新时，相当于邻居的邻居和自己的金额与邻居的金额作比较 dp[i]=max(dp[i-2]+nums[i],dp[i-1]); } return dp[nums.size()-1]; } }; 总结主要是要想到当前房屋和隔壁房屋的关系，只能偷一个，所以需要判断偷哪个性价比高，以此形成了递推公式，最终的结果累加到了dp数组的最后一个元素中
  ]]></content></entry><entry><title>139.单词拆分</title><url>/post/139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   🔠139.单词拆分
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
思路基本思想单词可以重复使用，也就意味着本题是一个完全背包问题，并且只要出现一种方案即可返回true
最简单的办法就是是由for循环嵌套，wordDict有多少元素就嵌套多少层for循环，但是会超时
不仅是完全背包，而且还是一个排列问题，因为applepenapple拆分之后一定要是apple+pen+apple，而不是apple+apple+pen或者pen+apple+apple，所以这三种情况不同，也就是排列问题
最后确定递推公式，这种分割字符串的问题没有正常的递推公式，而是判断当前单词是否在wordDict 中，并且当前单词之前的部分是否可以由wordDict 拼接成，那么当前的字符串可以返回bool，就这样一直向后，最终返回s的结果
执行流程初始化dp数组全为false，并且为了查找当前单词是否在wordDict 中，将wordDict 存储到set中 dp[0]=true 判断当前单词是否在wordDict 中，并且当前单词之前的部分是否可以由wordDict 中的单词拼接得到，如果可以的话当前字符串为true 最后返回s的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { set&lt;string&gt; wordSet(wordDict.begin(),wordDict.end()); vector&lt;bool&gt; dp(s.size()+1,false); dp[0]=true; for(int j=0;j&lt;=s.size();++j){//遍历背包容量，也就是字符串的 for(int i=0;i&lt;j;++i){//遍历单词，不断将当前字符串拆分成不同的单词 string word = s.substr(i,j-i); //当前单词在wordDict中，并且之前的部分可以由wordDict中的单词组成 if(wordSet.find(word)!=wordSet.end()&amp;&amp;dp[i]){ dp[j]=true; } } } return dp[s.size()]; } }; 总结主要是懂得如何将字符串拆分，只要当前拆分的部分在wordDict中，并且之前的部分也可以由wordDict中的部分组成，那么当前字符串就可以由wordDict中的单词组成，也就可以返回true
这样慢慢往后，后面的用到前面的结果，动态规划最终得到字符串s的结果
  ]]></content></entry><entry><title>279.完全平方数</title><url>/post/279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   2️⃣279.完全平方数
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
思路基本思想每个数都可以表示成完全平方数的和，并且至少有一种可能，例如3可以表示成3=1+1+1，而1就是完全平方数，本题的目的是求出最少的完全平方数
当前物品可以看做是数，并且数可以重复，也就是完全背包问题，确定递推公式最困难，当前数放进背包，也就代表着当前数要被拆分，被放进背包的数不好判断是不是完全平方数，可以直接让其成为完全平方数，也就是放进背包的数为i*i，此时一定是完全平方数，由此确定递推公式为： $$ dp[j]=min(dp[j],dp[j-i*i]+1) $$ i*i放进去之后，正整数多一个，其中dp[j]代表和为j的完全平方数的最少数量
根据以上分析，i*i不能超过n
执行流程初始化dp数组为当前范围的无穷大，便于更新到最小值 dp[0]=0 按照完全背包的流程更新dp数组 返回dp[n]作为最终的结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int numSquares(int n) { vector&lt;int&gt; dp(n+1,INT_MAX); dp[0]=0; for(int i=0;i*i&lt;=n;++i){//i*i超过n没有意义 for(int j=i*i;j&lt;=n;++j){//完全背包从前向后 if(dp[j-i*i]!=INT_MAX){//防止+1之后超过int的范围 dp[j]=min(dp[j],dp[j-i*i]+1); } } } return dp[n]; } }; 总结主要是转换思维，当前数不要直接放入，而是将其平方之后放入，这样就可以得到转移方程： $$ dp[j]=min(dp[j],dp[j-i*i]+1) $$ i*i放进去之后，还剩下j-i*i，此时正整数的个数加一，然后取最小的方案数
只要转换了思维，放进去的是i*i，而不是i再去判断是不是完全平方问题迎刃而解，因为这样每次放进去的都是完全平方数
  ]]></content></entry><entry><title>322.零钱兑换</title><url>/post/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   💷322.零钱兑换
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
你可以认为每种硬币的数量是无限的。
示例示例 1：
输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2：
输入：coins = [2], amount = 3 输出：-1 示例 3：
输入：coins = [1], amount = 0 输出：0 示例 4：
输入：coins = [1], amount = 1 输出：1 示例 5：
输入：coins = [1], amount = 2 输出：2 提示：
1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 2^31 - 1 0 &lt;= amount &lt;= 10^4 思路基本思想与518题不一样的是，本题中是从所有恰好凑成总金额的方案中选取一个硬币数最少的方案，并给出所用的硬币数，求什么就让dp数组的含义变成什么
本题中dp[j]的含义为：凑成总金额j所需要的最少硬币数
所以每次更新时都要选择最少的方案，形成的递推方程为： $$ dp[j]=min(dp[j],dp[j-coins[i]]+1) $$ dp[j-coins[i]]+1代表当前硬币加入组合中，所用的硬币数加一
执行流程初始化dp数组，为了让dp[j]统计到最少的硬币数，也就是说一旦出现更少的硬币数就更新，所以dp数组的初始全部设为int的最大值 dp[0]=0，按照示例3的要求 按照完全背包的流程进行统计 返回dp[amount]作为最终的结果，注意判断dp[amount]的大小，如果dp[amount]没有更新，代表没有组合可以组成总金额，此时返回-1 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int coinChange(vector&lt;int&gt; &amp;coins, int amount) { vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &lt; coins.size(); ++i) { for (int j = coins[i]; j &lt;= amount; ++j) { // 如果dp[j - coins[i]]是初始值则跳过 //这一步不可以省列，否则INT_MAX+1超过int的范围了 if (dp[j - coins[i]] != INT_MAX) { dp[j] = min(dp[j - coins[i]] + 1, dp[j]); } } } //当无法组成总金额时返回-1 return dp[amount] != INT_MAX ? dp[amount] : -1; } }; 总结主要是要学会改变惯性思维，求什么就让dp的含义指代什么，从而推导出递推方程
dp不是永远都代表背包所能装下的最大价值
并且要判断当前的数字相加之后会不会超过int的范围，防止出现思路对但是代码错
  ]]></content></entry><entry><title>377.组合总和IV</title><url>/post/377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Civ/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄377.组合总和IV
给你一个由不同整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。nums中的整数可以重复选取
题目数据保证答案符合 32 位整数范围。
思路基本思想选取几个整数组成一个target，相当于找出恰好装满背包的方案数，并且整数可以重复选择，所以是完全背包的组合问题，得到的递推方程为： $$ dp[j]+=d[j-nums[i]] $$ 其中dp[j]代表组成目标整数j的方案数，本问题是一个排列问题，因为(1, 1, 2)，(1, 2, 1)，(2, 1, 1)是三个不一样的情况，所以需要先遍历背包容量，再遍历物品
最后返回dp[target]即可
执行流程初始化dp数组，注意dp[0]=1 按照完全背包的流程进行统计 返回dp[target]作为最终的答案 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int combinationSum4(vector&lt;int&gt; &amp;nums, int target) { vector&lt;int&gt; dp(target + 1, 0); dp[0] = 1; for (int j = 0; j &lt;= target; ++j)//先遍历背包容量 { for (int i = 0; i &lt; nums.size(); ++i)//在遍历物品 { //可以装下物品并且方案数没有超过int的范围 if (j - nums[i] &gt;= 0 &amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]]) { dp[j] += dp[j - nums[i]]; } } } return dp[target]; } }; 总结主要有以下几点需要注意：
排列问题需要先遍历背包容量 求方案数需要累加 需要判断背包是否能装下，否则dp[j-nums[i]]中的j-nums[i]可能会是负数 要判断方案数是否还在int类型的范围内   ]]></content></entry><entry><title>518.零钱兑换II</title><url>/post/518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   💴518.零钱兑换II
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
假设每一种面额的硬币有无限个。
题目数据保证结果符合 32 位带符号整数。
思路基本思想典型的完全背包问题，并且求解的是恰能装满背包的方案数，而不是最大价值
所以有两点需要注意：
背包容量从小到大遍历，先更新小容量，大容量依赖于小容量，从而物品可以被放入任意次
递推方程不一样，采用累加的方式 $$ dp[j]+=d[j-weight[i]] $$ 代表加入不同的物品，背包的容量有不同的变化，从而有不同的方案，最终将所有的方案累加
执行流程初始化dp数组，注意dp[0]=1,代表总金额为0有一种方案就是什么都不加 按照完全背包的方式遍历 按照递推方程更新dp数组 返回最终结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int change(int amount, vector&lt;int&gt;&amp; coins) { vector&lt;int&gt; dp(amount+1,0); dp[0]=1; for(int i=0;i&lt;coins.size();++i){ for(int j=coins[i];j&lt;=amount;++j){ dp[j]+=dp[j-coins[i]]; } } return dp[amount]; } }; 总结有三点需要注意：
完全背包容量的遍历顺序从小到大，这样大容量才能依赖小容量，也就是物品可以重复加入 求解的是恰能装满背包的所有方案数，而不是最大价值，所以需要累加所有可能的方案 dp[0]=1，代表总金额为0时方案数为1，什么都不加   ]]></content></entry><entry><title>474.一和零</title><url>/post/474.%E4%B8%80%E5%92%8C%E9%9B%B6/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   1️⃣474.一和零
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。
思路基本思想每次选择集合中的元素时，选择0和1尽量少的元素。
背包的容量是m，n二维，放进一个字符串，背包的容量变成m-zeroNum，n-oneNum，所以需要统计每一个字符串的0,1数量，判断当前字符串加入到背包中价值是否更大
递推方程为： $$ dp[i][j]=max(dp[i][j],dp[i-zeroNum][j-oneNum]+1) $$ 判断当前字符串是否加入背包中，背包初始化全为0
执行流程dp[i][j]代表可以放i个0，j个1时背包最多可以装下多少个字符串元素
初始化背包，二维dp数组全为0 对于每一个字符串，统计出现的0,1数量 应用递推方程判断当前字符串是否加入 返回dp[m][n]作为最终结果 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { //初始化dp数组全为0 vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(auto s:strs){ int zeroNum=0; int oneNum=0; for(auto c:s){//统计字符串出现的0，1个数 if(c==&#39;0&#39;) ++zeroNum; else ++oneNum; } //对于每一个字符串，更新dp数组 for(int i=m;i&gt;=zeroNum;--i){//从后向前减小背包容量 for(int j=n;j&gt;=oneNum;--j){ dp[i][j]=max(dp[i][j],dp[i-zeroNum][j-oneNum]+1); } } } return dp[m][n]; } }; 总结主要是知道如何将问题转化为背包问题，知道m，n共同组成了背包的容量，然后应用背包问题的流程解决当前问题
当前物品依次加入背包中，对于当前物品来说，背包的容量逐渐减小，分别对应外层和内层循环
  ]]></content></entry><entry><title>494.目标和</title><url>/post/494.%E7%9B%AE%E6%A0%87%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   🎯494.目标和
给你一个整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 &amp;lsquo;+&amp;rsquo; 或 &amp;lsquo;-&amp;rsquo; ，然后串联起所有整数，可以构造一个 表达式 ：
例如，nums = [2, 1] ，可以在 2 之前添加 &amp;lsquo;+&amp;rsquo; ，在 1 之前添加 &amp;lsquo;-&amp;rsquo; ，然后串联起来得到表达式 &amp;ldquo;+2-1&amp;rdquo; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
思路基本思想由于需要最终获得target，肯定是一部分数为正一部分数为负，那么我们可以先将target拿出来，剩下的数等分成两半，一半为正一半为负，这样相加抵消肯定为0，对target没有影响
将target拿出来之后剩下的数记为sum-target，其中sum是nums求和得到的，之后将sum-target分成两半得到的数为： $$ capacity=\frac{sum-target}{2} $$ capacity作为背包的容量，然后看nums中有哪些方案可以将背包刚好填满，记录这些方案数即可
现在的问题就是如何记录所有的方案数，dp[j]代表和为j的方案数
已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包 将上面的情况累加，所以最终的公式为： $$ dp[j] += dp[j - nums[i]] $$ 可以理解为依次向当前背包中放入nums[i]，剩下的dp[j-nums[i]]继续求解方案数，不同的nums[i]形成了不同的方案数，所以需要累加
注意有两种情况问题无解
数组求和都小于target，肯定无法形成target 按照公式1求解的capacity不是整数，数组中的数组合都是整数，不符合要求 相当于找出那些数加负号，剩下的数都加正号，正负抵消之后就形成了最终的target
执行流程计算背 …  ]]></content></entry><entry><title>1049.最后一块石头的重量II</title><url>/post/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   🌑1049.最后一块石头的重量II
有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。
每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
思路基本思想两个石头进行粉碎，重量越相近，粉碎得到的结果越小，所以可以应用416题的思想，将石头的重量求和，然后对半分作为背包的容量，求背包最大能装下多少，之后剩下的就是抵消不了的
背包最终装下的石头就是一个分组，剩下的石头是另外的分组，两组互相抵消剩下的值就是最终的结果，计算两相抵消剩下结果的公式为： $$ sum - dp[target] - dp[target] $$ 其中sum是所有石头的重量，target是背包的容量
执行流程计算背包的容量 初始化dp数组 求背包最大的价值（01背包的流程） 求剩下的石头重量（套公式1） 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum=accumulate(stones.begin(),stones.end(),0); int target=sum/2; vector&lt;int&gt; dp(target+1,0); for(int i=0;i&lt;stones.size();++i){ for(int j=target;j&gt;=stones[i];--j){//装的下才有意义 dp[j]=max(dp[j],dp[j-stones[i]]+stones[i]); } } //计算抵消剩下的部分 return sum-dp[target]-dp[target]; } }; 总结主要是将问题如何转化成01背包，一旦转化成01背包问题，一切迎刃而解
石头相互抵消应该选尽可能接近的才能留下更小的结果
  ]]></content></entry><entry><title>416.分割等和子集</title><url>/post/416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄416.分割等和子集
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
示例示例 1：
输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2：
输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。
提示：
1 &amp;lt;= nums.length &amp;lt;= 200 1 &amp;lt;= nums[i] &amp;lt;= 100
思路基本思想既然要分割成两个子集，并且两个子集的和要相等，那么就先求出这个和sum是多少，直接将所有元素累加起来除以2即可
由于元素都是正整数，所以分成子集之后的和也是正整数，所以求出的和如果不是正整数那么肯定无法分割，只有是正整数才有可能可以分割
求出的sum当成背包的容量，集合中的元素当成物品，一旦有元素组合起来可以刚好把背包填满，就说明可以分割，因为背包的容量是评分的，所以剩下的元素组合起来肯定也可以将背包填满
现在要解决的问题就是如何判断元素的组合将背包刚好填满
什么叫刚好装满：容量为sum，装了sum，也就是dp[sum]=sum，也就是说要求的dp[sum]，求完之后判断dp[sum]==sum？即可
执行流程确定sum的值，如果sum不是正整数，直接返回false
sum是正整数，就让背包的容量为sum，此时正常执行01背包问题的流程
要的是dp[sum]，但是dp数组中其他的元素也得求出来，因为dp[sum]是由dp数组前面的值推导得到的
初始化dp数组为0
从前向后依次向背包中装填元素
背包容量从大到小防止元素重复装入
确定递推方程，本题中元素的值既是权值也是价值 $$ dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) $$ 重点是不放当前元素的时候，形成的价值是dp[j]，而不是dp[j-1]，因为dp[j]的含义是：容量为j的背包，所背的物品价值可以最大为dp[j]。
遍历完成判断dp[sum]==sum
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { …  ]]></content></entry><entry><title>解决背包问题的思路</title><url>/post/%E8%A7%A3%E5%86%B3%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag><tag>背包问题</tag></tags><content type="html"><![CDATA[   🎒解决0-1背包问题的思路
分析最基本的0-1背包的动态规划解题思路，基本步骤从最开始的初始化价值数组，确定递推方程到最后的更新价值数组得到最终答案
之后再引出完全背包的问题，唯一的区别就是物品可以装入任意次
总结来看除了排列问题需要先遍历背包容量，其余都先遍历物品
核心就是确定递推公式和初始化方案
引言0-1背包就是当前背包总容量为n，有一堆物品，每个物品的重量为weight[i]，每个物品的价值为value[i]，最终目的是为了让背包中的物品尽可能的价值大，某些性价比不高的物品可以丢弃不装入背包，选择性的装一些价值尽可能大，重量尽可能小的物品
当前背包容量下形成的最大价值与小容量下形成的最大价值有关
存放最终的背包价值的dp数组有两种，二维和一维，先分析二维再将二维降成一维
完全背包与01背包唯一的区别就是物品可以装入任意次
前期准备物品
二维dp数组初始化
一维dp数组初始化
0-1背包直接提供代码来进行分析
整个代码是针对每个物品，对于不同的背包容量来统计最后的价值，当所有物品都尝试过之后，返回最终的结果（dp数组最后的值）
二维dp1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void test_2_wei_bag_problem1() { vector&amp;lt;int&amp;gt; weight = {1, 3, 4}; vector&amp;lt;int&amp;gt; value = {15, 20, 30}; int bagweight = 4; // 二维数组 //dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(weight.size(), vector&amp;lt;int&amp;gt;(bagweight + 1, 0)); // 初始化，一旦能放下物品0，就先只放物品0 for (int j = weight[0]; j &amp;lt;= bagweight; j++) { dp[0][j] = value[0]; } // weight数组的大小 就是物品个数 for (int i = 1; i &amp;lt; weight.size(); i++) …  ]]></content></entry><entry><title>2196.根据描述创建二叉树</title><url>/post/2196.%E6%A0%B9%E6%8D%AE%E6%8F%8F%E8%BF%B0%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url><categories><category>leetcode</category></categories><tags><tag>每日一题</tag></tags><content type="html"> 🌳2196.根据描述创建二叉树
给你一个二维整数数组 descriptions ，其中 descriptions[i] = [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外：
如果 isLefti == 1 ，那么 childi 就是 parenti 的左子节点。 如果 isLefti == 0 ，那么 childi 就是 parenti 的右子节点。 请你根据 descriptions 的描述来构造二叉树并返回其 根节点 。
测试用例会保证可以构造出 有效 的二叉树。
示例
示例 1：
输入：descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] 输出：[50,20,80,15,17,19] 解释：根节点是值为 50 的节点，因为它没有父节点。 结果二叉树如上图所示。
示例 2：
输入：descriptions = [[1,2,1],[2,3,0],[3,4,1]] 输出：[1,2,null,null,3,4] 解释：根节点是值为 1 的节点，因为它没有父节点。 结果二叉树如上图所示。
思路
基本思想
每一个描述都会创建一个新子树，包含一个根节点和一个孩子节点，重点就是如何讲子树连接起来
建立一个哈希表，建立子树时如果哈希表中已经有了节点，那么这个节点肯定要被连接到子树中，如果还没有此节点，就创建此节点，这样就可以将所有的子树一一连接在一起
并且一旦某个节点被连接到其他的子树中，入度就需要加一，最终统计入度为零的节点就是根节点
执行流程
遍历描述数组，创建子树，在创建子树时如果父节点和孩子节点不存在就创建
如果存在的话就直接判断孩子节点是否已经被创建，如果已经被创建，那就意味着两个子树之间需要进行链接，并且被连接的节点入度需要增加
遍历完描述数组之后，所有的子树被链接成了一颗完整的子树，最后的工作就是找到根节点并返回，此时入度数组就排上用场了，只需要找到入度为0的节点就是根节点
代码
根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 …</content></entry><entry><title>96.不同的二叉搜索树</title><url>/post/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   🌴96.不同的二叉搜索树
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
示例1 2 输入：n = 3 输出：5 思路基本思想先从一个节点的树向后推导从而试图找出规律，可以发现n=3时，可以用1，2，3做根节点
以1做根节点时剩下两个节点全在右子树，两个节点的组合方式与n=2时的组合方式一样（不看节点上的值），以2做根节点时两个节点一左一右，组合方式与n=1的组合方式一样
所以节点数为n时形成的二叉搜索树最终搜索结果等于分别以1~n的节点为根节点，之后将序列分割成左右子树两部分之后，剩下的节点组成的结果
在代码中的的描述为：
1 2 3 4 5 6 7 8 //从前到后遍历最终形成n的结果 for (int i = 1; i &lt;= n; i++) { //对于i个节点，分别与1~i作为根节点 for (int j = 1; j &lt;= i; j++) { //将其分成左右子树两部分 dp[i] += dp[j - 1] * dp[i - j]; } } 执行流程从前到后遍历，为了最终统计n的结果提供参考
对于每个节点数i，都以1~i中的每一个节点作为根节点，从而将序列分割成左右两部分，最终节点数i的结果由所有的分割结果相加得到
最终遍历结束返回n的结果就是最终的答案
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int numTrees(int n) { vector&lt;int&gt; res(n+1,0); res[0]=1;//初始化 for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=i;++j){ //以j为根节点从而将i分割成两部分 res[i]+=res[j-1]*res[i-j]; } } return res[n]; } }; 总结本题中从前向后遍历，后面的节点数形成的二叉搜索树利用了前面的节点数形成的二叉搜索树，只要两个二叉搜索树的结构一样，不管节点上的数是什么，都算做相同的二叉搜索树
例如节点23，24形成的二叉搜索树与2，3形成的二叉搜索树结构一样，所以可以直接作为n=2形成的二叉搜索树，明白这个道理之后，就可以得到动态规划方程
每个数都可以成为根节点，并且成为根节点之后会把序列分成左右子树两部分
  ]]></content></entry><entry><title>343.整数拆分</title><url>/post/343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   0️⃣343.整数拆分
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
示例 :
输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 思路基本思想对于整数n拆分之后，形成的最大乘积可以由拆分得到的几个部分的最大乘积相乘得到，所以可以使用动态规划来做
对于一个数n，可以先拆分成两部分，x和n-x，其中x的范围从1一直到n-1，不能取n，否则拆分成n和0没有意义
所以可以从前向后一直拆分，一直拆分到n的时候，前面的数最大拆分结果都已经统计出来，n的拆分结果就是统计所有拆分情况，取最大的拆分结果即可
执行流程从前向后拆分每一个数，统计他的最大拆分结果
对于每一个数都有n-1种拆分方式，对于每一种拆分方式又可以分成两种情况：
将n拆分成x和n-x，并且n-x不再拆分，此时乘积为x*(n-x) 将n拆分成x和n-x，并且n-x继续拆分，此时乘积为x*dp[n-x] 为什么n-x不再拆分呢，如果n-x是2，此时不拆分的结果更大,所以每个数都判断是否拆分
为什么x不再拆分，看如下证明
因为j * dp[i - j]包含了dp[j] * dp[i - j]，这是可以证明的：
对j最优拆分：j = a1 + a2 +&amp;hellip;+an
对i - j 最优拆分：i - j = b1 + b2 +&amp;hellip;+bn
所以有 dp[j] = a1 * a2 &amp;hellip; an
dp[i - j] = b1 * b2 *&amp;hellip; bn
dp[j] * dp[i - j] = (a1 *a2 *&amp;hellip;an) * (b1 * b2 &amp;hellip; bn) = a1 * (a2 * &amp;hellip; * an * b1 * b2 &amp;hellip; bn)
令 k = a1，必有i - k = a2 + &amp;hellip; + an + b1 + b2 +&amp;hellip;+ bn(这就是对 i - k 的一种拆分)
如果以上这种对i - k的一种拆分是最优的，那么必有dp[j] * dp[i - j] = k * dp[i - k] 所以此时j * dp[i - j]包含dp[j] * dp[i - …  ]]></content></entry><entry><title>基于VSCode和CMake进行C++开发</title><url>/post/%E5%9F%BA%E4%BA%8Evscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc++%E5%BC%80%E5%8F%91/</url><categories><category>学习笔记</category></categories><tags><tag>VSCode</tag><tag>CMake</tag></tags><content type="html"> 😄基于VSCode和CMake进行C++开发
Linux介绍
linux中一切皆文件
目录结构
bin，含义是二进制，里面的文件都是可以被运行的， dev，存放的都是外接设备，例如光盘，到这个目录之后不能直接使用，需要挂载到某个目录中才能正常使用 etc，存放系统配置文件 home，除了root用户之外其他用户的家目录 proc，存储linux运行时的一些进程 root，root用户自己的家目录 sbin，存放一些可被执行的二进制文件，执行需要管理员权限 tmp，存放临时文件 usr，存放用户自己安装的软件 var，存放系统或者程序的日志文件 mnt，添加外部设备时，将外部设备挂载到mnt目录下指定的文件夹下 开发环境
安装GCC,GDB
1 2 3 4 5 6 sudo yum update#更新软件包管理工具 #sudo是为了使用root权限 sudo yum -y install gdb #调试程序的工具 yum -y install gcc-c++ #调用c++编译器的工具 yum -y install gcc #调用c编译器的工具 #安装完成之后可以使用gcc --version查看gcc的版本号 安装CMake
1 2 yum -y install cmake#安装cmake cmake --version #查看版本 GCC
对cpp文件进行编译，不再是使用IDE直接一键运行，而是使用命令控制cpp文件到最终的可执行文件的过程，并了解编译过程中发生了什么
编译过程
预处理，会将头文件的包含，宏定义以及内联函数展开，生成一个.i文件
1 2 #-E参数指示编译器对输入文件进行预处理 g++ -E test.cpp -o test.i 对test.cpp文件进行预处理，生成test.i文件
编译 生成.s文件
1 2 3 #-S参数指示g++在产生了汇编语言文件之后停止编译 #产生的文件默认扩展名是.s g++ -S test.i -o test.s 将预处理的test.i文件编译成test.s文件
**汇编 ** 生成.o文件
1 2 3 #-c参数指示g++将源代码汇编成机器语言的目标代码，c是小写 #产生的文件默认扩展名是.o g++ -c test.s -o test.o 将编译产生的test.s文件汇编成test.o
链接 生成.out文件
1 …</content></entry><entry><title>63.不同路径II</title><url>/post/63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84ii/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄63.不同路径II
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的**障碍物（1）和空位置（0）**分别用 1 和 0 来表示。
相比于62题，只是多了一个障碍物，相当于有的网格去不了
思路基本思想相比于62题，只是多了一个障碍物，所以在统计时需要注意，有两种情况需要单独处理：
如果当前网格有障碍物，那么就不用统计 如果当前网格的左边或者上边有障碍物，那么只需要统计没有障碍物的一方 其余的思路和62题一样，确定递归方程和初始化第一行和第一列，第一行和第一列有可能也有障碍
题中给定了一个二维容器vector，当容器中的元素为0代表没有障碍，容器中的元素为1代表有障碍
统计时遇到障碍，到达当前网格的路径数就是0，
执行流程由于题中给出一个二维容器，所以不需要再初始化一个二维vector，只需要将给定容器的第一行和第一列初始化即可，之后利用递推方程f(m,n)=f(m-1,n)+f(m,n-1)将每个网格的路径数进行统计即可
统计时需要判断当前网格是否有障碍
初始化第一行第一列时，由于有障碍，一旦出现障碍，后面的网格都无法到达，也就是路径数为0
左上角网格不可以初始化两次，需要单独判断
从第二行第二列开始统计，当前网格出现障碍，到达他的路径数就为0
当前网格没有障碍时，上方和左方不管有没有障碍直接统计，有障碍路径数为0也没有影响
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; obstacleGrid) { obstacleGrid[0][0]=obstacleGrid[0][0]==1?0:1; int row=obstacleGrid.size(); int …  ]]></content></entry><entry><title>62.不同路径</title><url>/post/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄62.不同路径
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
思路基本思想机器人只能向右下角走，只能向右或者向下走，到达某一网格的方式由其上方和左方的网格决定，也就是f(m,n)=f(m-1,n)+f(m,n-1)，其中f(m-1,n)代表左方的网格，f(m,n-1)代表上方的网格
所以只需要从头开始遍历，统计每一个到达每一个网格的路径数，当最终统计到finish时，就可以返回答案
主要是理解递归公式，并且需要初始化，
执行流程初始化一个二维vector，二维vector中的每一个元素都是一个一维vector，所以初始化的语句为： 1 2 //res中一共有m个匿名对象，每个匿名对象都是一个vector，初始化了n个0 vector&lt;vector&lt;int&gt;&gt; res( m, vector&lt;int&gt;(n, 0));//初始化的方式 学会这种初始化的方式
将第一行和第一列的路径数都初始化为1，因为他们要么只能向右，要么只能向下 从第二行第二列的网格开始进行统计，利用递推公式更新，最终返回结果 代码根据以上分析，得出一下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int uniquePaths(int m, int n) { //定义存放路径数的容器 vector&lt;vector&lt;int&gt;&gt; res( m, vector&lt;int&gt;(n, 0));//初始化的方式 //初始化第一行和第一列的路径数 for(int i=0;i&lt;m;++i){//列 res[i][0]=1;//只能向下 } //左上角网格被初始化了两次，但是没什么影响 for(int i=0;i&lt;n;++i){//行 res[0][i]=1;//只能向右 } for(int i=1;i&lt;m;++i){//行 for(int j=1;j&lt;n;++j){//列 //res[i-1][j]代表头顶，res[i][j-1]代表左边 res[i][j]=res[i-1][j]+res[i][j-1]; } } return res[m-1][n-1]; } }; 总结关键是推导出递推公式和第一行第一列的初始化，处理完之后就可以直接进行统计，暴力的将所有的网格路径数都统计出来，因为到达(M,N)的路径数需要依赖于前面的路径数
最终返回(m,n)的路径数就是最终的结果
  ]]></content></entry><entry><title>746.使用最小花费爬楼梯</title><url>/post/746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄746.使用最小花费爬楼梯
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。
示例示例 1：
输入：cost = [10,15,20] 输出：15 解释：你将从下标为 1 的台阶开始。
支付 15 ，向上爬两个台阶，到达楼梯顶部。 总花费为 15 。 示例 2： 输入：cost = [1,100,1,1,1,100,1,1,100,1] 输出：6 解释：你将从下标为 0 的台阶开始。
支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。 支付 1 ，向上爬一个台阶，到达楼梯顶部。 总花费为 6 。 提示：
2 &lt;= cost.length &lt;= 1000 0 &lt;= cost[i] &lt;= 999
思路基本思想假设到达最后的阶梯n的开销为f(n)，f(n)肯定是由n-1走一步或者n-2走两步，加上自身的开销，选取一个小的构成的，也就是:
1 f(n)=min(f(n-1)+cost[n-1],f(n-2)+cost[n-2]) 而选择了其中花费较小的阶梯之后，还需要从这个阶梯继续向前推导，也就是说从当前出发，看哪一步花销较小就走哪一步，一直模拟到起点，起点可以选择从0或者1开始意味着到这两点的开销为0
执行流程从前向后遍历，到达阶梯n的花销为取n-1和n-2为起点的花销较小的部分
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; res(cost.size()+1,0); //从这两点出发代价为0 int i=2;//从2开始统计 while(i&lt;=cost.size()){ //看从哪里出发花费最小 res[i]=min(res[i-1]+cost[i-1],res[i-2]+cost[i-2]); ++i; } return res.back(); } }; 总结遵循动态规划的步骤，先确定递推公式，之后再确定开始规划的元素初值，最后模拟规划的步骤即可
注意到达阶梯n的方法有两种，n-1走一步或者n-2走两步，本题中需要统计从n-1和n-2中那个出发花费较小，在每一个阶梯都是这么判断就可以获得最终结果
  ]]></content></entry><entry><title>70.爬楼梯</title><url>/post/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/</url><categories><category>leetcode</category></categories><tags><tag>动态规划</tag></tags><content type="html"><![CDATA[   😄70.爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 ：
输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 思路基本思想简单思想以某一个阶梯n为例，走到这个阶梯的方式有两种，从n-1走一步或者从n-2走两步，这是两种方案，所以需要将这两种方案相加
而到达n-1和n-2的方案也是如此推出，所以可以得到，f(n)=f(n-1)+f(n-2)，从前面的状态推导出后面的状态，我们采用从前向后推导的方式计算出f(n)的值即可
背包问题可以将阶梯数看作是背包的容量，然后一次走一步或者两步最终到达阶梯n可以看做使用1和2填充背包，最终恰好将背包填充满，求所有的方案数，这个方案数是排列的方案数，因为[1,2]和[2,1]不一样
执行流程简单思想从前向后遍历，由于n是一个正整数不为0，所以初始值有两个，res[1]=1,res[2]=2，从第三级阶梯开始统计，之后res[n]的值由res[n-1]和res[n-2]共同推导得到，最后返回res[n]的值就是最终结果
背包问题和其他背包问题一样，只不过此时物品只有两个，1和2
代码根据以上分析，得出以下代码：
简单思想1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int climbStairs(int n) { if(n==1){ return 1; } int left=1; int right=2; for(int i=3;i&lt;=n;++i){ int sum=right+left; left=right; right=sum; } return right; } }; 背包问题1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int climbStairs(int n) { //使用另一种思想 //背包容量为n，使用1和2填充背包，背包刚好填充满的方案数有多少 //1,2的顺序随意 vector&lt;int&gt; dp(n+1,0); vector&lt;int&gt;nums{1,2}; dp[0]=1; for(int j=0;j&lt;=n;++j){ for(int i=0;i&lt;nums.size();++i){ if(j-nums[i]&gt;=0){//当前物品可以装下 dp[j]+=dp[j-nums[i]]; } } } return dp[n]; } }; 总结简单思想中，主要是到达n的方法由到达n-1和到达n-2的方法推出，即f(n)=f(n-1)+f(n-2)
转化为背包问题之后，变成了完全背包的排列问题，直接按照流程进行判断即可
  ]]></content></entry><entry><title>关于zzzi</title><url>/about.html</url><categories/><tags/><content type="html"><![CDATA[  ## 👋👋👋Welcome to zzzi's blog! 🎉🎉🎉🏫 Studing at @HEU 🏡 Living at @HaErBin🌱 Repository at@zzziCode🧐 Try to find a good job 🤔 論文を出版したい 1 2 3 4 // Which came first: the chicken or the egg? console.log([&#39;🥚&#39;, &#39;🐣&#39;, &#39;🐥&#39;, &#39;🐔&#39;].sort()) &gt;&gt;&gt; [ &#39;🐔&#39;, &#39;🥚&#39;, &#39;🐣&#39;, &#39;🐥&#39; ]   ]]></content></entry><entry><title>968.监控二叉树</title><url>/post/968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"> 🌲968.监控二叉树
给定一个二叉树，我们在树的节点上安装摄像头。
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
计算监控树的所有节点所需的最小摄像头数量。
示例
示例 ：
输入：[0,0,null,0,0] 输出：1 解释：如图所示，一台摄像头足以监控所有节点。 提示：
给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。 思路
层次遍历
开始思路是层次遍历二叉树，然后看奇数层还是偶数层的节点少，将监控放在节点数少的层上即可，但是忽略了一点，能被监控到的节点不需要再进行监控，也就是隔一层监控一个不是最好的监控方案
所以需要三层一分组，一组中只需要中间的一层安装监控即可，不足三层的分成两种情况，所以一共有三种情况：
level%3=0，此时只需要统计余3得2的层中有多少节点即可 level%3=2，此时也只需要统计余3得2的层中有多少节点 level%3=1，分开讨论，看奇数层和偶数层那个节点少 所以层次遍历的过程中需要统计层数和每一层的节点数
执行流程
执行层次遍历，统计二叉树的层数和每层的节点数 判断level%3的余数，从而分成两种（1，2可以合并成一种）情况 余数为2或者0，直接统计统计余3得2的层中有多少节点 余数为1，直接判断奇偶层中那个节点数少 但是这样只能通过一部分，情况模拟不全
后序遍历
基本思想就是孩子节点中有未被覆盖的，那么当前节点就需要装摄像头
如果孩子节点都被覆盖，那么就当前节点的父节点就需要装摄像头
如果孩子节点装了摄像头，那么当前节点就被覆盖
叶子节点不能被装摄像头，因为二叉树越底层节点越多，所以叶子节点不能装摄像头，尽可能地将摄像头向上装
一个节点有摄像头，上下两层都不用装。一个节点只是被覆盖，那么上层就需要被覆盖（自己装摄像头或者父亲装摄像头）
最后单独处理根节点，因为根节点可能自成一组
执行流程
直接进行后序遍历，分成四种情况判断：
左右孩子都被覆盖，当前节点的父节点需要装摄像头 左右孩子任有一个为被覆盖，此时当前节点需要装摄像头 左右孩子任有一个有摄像头，当前节点被覆盖，父节点不用管它 注意2，3的顺序不能反，走到3默认两个孩子都被覆盖，就看是不是自带摄像头的覆盖
如果2，3顺序反过来，可能会出现一个孩子有摄像头，一个孩子不被覆盖，当前节点撒手不管的情况，因为当前节点没有排除任有一个为被覆盖，直接 …</content></entry><entry><title>738.单调递增的数字</title><url>/post/738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   🔺738.单调递增的数字
给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
示例 1:
输入: N = 1234 输出: 1234 示例 2:
输入: N = 332 输出: 299 思路基本思想某一个数字中的一部分出现92的情况，就不符合条件， 此时只需要将92变成89即可符合条件，变化的过程位2-&amp;gt;9，9-&amp;gt;8,也就是2从前面的9借了一位，让其变成最大的9，前面的9被借走一个变成8
每次只借走一个，并且被借走的那一位开始可能不小于前面，借走之后可能小于前面
例如992，开始9和9符合要求，结果中间的9被借走一位变成8，最后的2变成9，最终的数字变成989，不符合要求，所以被借走的那一位需要与前面的进行比较，防止不符合要求
这与135.分发糖果有点类似，因为统计左&amp;gt;右时，需要从后向前遍历，如果从前向后遍历，右边的更新之后，可能会造成分数少的糖果多，所以左边的需要后统计
本题也是一样的，由于当前位数被借走一个之后可能小于高一位，所以只能从后向前遍历
并且一旦当前位减小一个，后面的位数都可以变成9，这样既不会超过原来的数字又贪心的将其变成符合要求的最大数字
增加flag是因为如果有两位相等就不会借一位，此时就不会变成9，如果更高位出现了借一位变成9的情况，此时就会不符合要求，例如211，模拟一遍就知道是什么意思
借一位的思想很重要，从低位向高位遍历，一旦出现飞递增，就需要向高位借位，记录最高的借位的位置，后面的位置都可以变成9
执行流程遵循不符合要求就向高一位借一个变成9，高一位少一个的思想
从前向后遍历这个数 遇到不符合要求的就向高一位借一个变成9，高一位少一个 遍历到最高位结束 记录最后一个被借走一个的位，后面的位都可以变成9 代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int monotoneIncreasingDigits(int n) { string num=to_string(n); int flag=num.size(); for(int i=num.size()-1;i&amp;gt;0;--i){ // …  ]]></content></entry><entry><title>56.合并区间</title><url>/post/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   😄56.合并区间
给出一个区间的集合，请合并所有重叠的区间。
示例 1:
输入: intervals = [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:
输入: intervals = [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。 思路基本思想一旦两个区间出现重叠，就将其合并，合并之后的新区间与后面的区间进行比较
由于区间是乱序存放的，所以需要先进行排序，这样遍历时才会取出相邻的区间
与452与435思路类似
执行流程对集合进行排序 判断flag是否与当前区间重叠，重叠之后合并成新的flag 不重叠更新flag，直到遍历结束 代码根据以上分析，得出以下代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { //先进行排序 sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt;&amp; v1,vector&lt;int&gt;&amp; v2){ if(v1[0]==v2[0]) return v1[1]&lt;v2[1]; return v1[0]&lt;v2[0]; }); //从第一个区间开始判断 vector&lt;int&gt; flag=intervals[0]; //初始时结果容器为空 vector&lt;vector&lt;int&gt;&gt; res; for(int i=1;i&lt;intervals.size();++i){ //出现重叠更新 if(intervals[i][0]&lt;=flag[1]){ //更新右边界即可,取max是为了防止出现真子集的情况 flag[1]=max(intervals[i][1],flag[1]); } //没有出现重叠，需要更新flag和res else{ res.push_back(flag); flag=intervals[i]; } } //最后一个区间不要忘记，dan&#39;du&#39;c res.push_back(flag); return res; } }; 总结主要是模拟合并的过程，出现重叠就合并，没有重叠就把当前区间加入结果集
遍历到最后一个区间，不管是合并还是不合并，都需要单独将其合并到结果集，因为代码判断的逻辑是不重叠才加入结果集，然后才更新flag，所以最后一个flag无法加入结果集，需要单独处理
  ]]></content></entry><entry><title>Vscode文件夹配置</title><url>/post/vscode%E6%96%87%E4%BB%B6%E5%A4%B9%E9%85%8D%E7%BD%AE/</url><categories><category>教程</category></categories><tags><tag>vscode配置</tag></tags><content type="html"><![CDATA[   😄vscode文件夹配置
配置.vscode文件夹之后，实现cpp文件的编译和调试
配置方案第一种自行创建.vscode文件夹，添加tasks.json和launch.json文件，此时直接编译文件
第二种先创建英文cpp文件，之后ctrl+f5进行编译，选择GDB和G++
自动生成tasks.json和launch.json,自动跳转到launch.json文件中
改变program和externalConsole两个配置
改变tasks.json文件中的args配置
配置文件tasks.json
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { &#34;tasks&#34;: [ { &#34;type&#34;: &#34;cppbuild&#34;, &#34;label&#34;: &#34;C/C++: g++.exe 生成活动文件&#34;, &#34;command&#34;: &#34;E:\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\mingw64\\bin\\g++.exe&#34;,//自己的路径 &#34;args&#34;: [ &#34;-fdiagnostics-color=always&#34;, &#34;-g&#34;, //新增如下两项 &#34;-fexec-charset=GBK&#34;, // 处理mingw中文编码问题 &#34;-finput-charset=UTF-8&#34;,// 处理mingw中文编码问题 &#34;${file}&#34;, &#34;-o&#34;, //&#34;${fileDirname}\\${fileBasenameNoExtension}.exe&#34; &#34;${fileDirname}\\test.exe&#34;//更改这一项 ], &#34;options&#34;: { &#34;cwd&#34;: &#34;${fileDirname}&#34; }, &#34;problemMatcher&#34;: [ &#34;$gcc&#34; ], &#34;group&#34;: { &#34;kind&#34;: &#34;build&#34;, &#34;isDefault&#34;: true }, &#34;detail&#34;: &#34;调试器生成的任务。&#34; } ], &#34;version&#34;: &#34;2.0.0&#34; } launch.json
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &#34;version&#34;: &#34;0.2.0&#34;, &#34;configurations&#34;: [ { &#34;name&#34;: &#34;g++.exe - 生成和调试活动文件&#34;, &#34;type&#34;: &#34;cppdbg&#34;, &#34;request&#34;: &#34;launch&#34;, // &#34;program&#34;: &#34;${fileDirname}\\${fileBasenameNoExtension}.exe&#34; //指向项目生成的可执行文件才可以进行调试运行 &#34;program&#34;: &#34;${fileDirname}\\test.exe&#34;,//修改这一项 &#34;args&#34;: [], &#34;stopAtEntry&#34;: false, &#34;cwd&#34;: &#34;${fileDirname}&#34;, &#34;environment&#34;: [], //在窗口显示 &#34;externalConsole&#34;: true,//false改为true &#34;MIMode&#34;: &#34;gdb&#34;, &#34;miDebuggerPath&#34;: &#34;E:\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\mingw64\\bin\\gdb.exe&#34;, &#34;setupCommands&#34;: [ { &#34;description&#34;: &#34;为 gdb 启用整齐打印&#34;, &#34;text&#34;: &#34;-enable-pretty-printing&#34;, &#34;ignoreFailures&#34;: true } ], //在执行launch文件之前执行什么 &#34;preLaunchTask&#34;: &#34;C/C++: g++.exe 生成活动文件&#34; } ] } 总结确保编译器的路径正确，之后文件可以自动生成，并且可以运行中文文件，但是无法调试中文文件
如果控制台窗口一闪而过，自动关闭的话，在main函数最后return 0的前面加上一句systemctl(&quot;pause&quot;)即可
  ]]></content></entry><entry><title>763.划分字母区间</title><url>/post/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   🆎763.划分字母区间
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
示例：
输入：S = &ldquo;ababcbacadefegdehijhklij&rdquo; 输出：[9,7,8] 解释： 划分结果为 &ldquo;ababcbaca&rdquo;, &ldquo;defegde&rdquo;, &ldquo;hijhklij&rdquo;。 每个字母最多出现在一个片段中。 像 &ldquo;ababcbacadefegde&rdquo;, &ldquo;hijhklij&rdquo; 的划分是错误的，因为划分的片段数较少 思路基本思想同一个字母只能出现在一个片段中，所以需要记录字母结束位置，所以第一次遍历就记录当前字母的结束位置，第二次遍历就不断更新最远出现位置，一旦到了这个最远位置就形成一个分段
只要比最远位置大就更新最远位置
为什么到了这个最远位置就形成了一个分段，因为在到达这个最远位置的途中都没有超过这个最远位置的字母，说明这些字母都在最远位置的范围内，此时符合分段的条件，立马分段（因为要尽可能多的分段）
分段之后更新继续遍历，到达最远位置就可以分段
能成功到达最远位置就说明之前的字母都没有超过这个最远位置
执行流程统计字母出现的最后位置，需要进行一次遍历，遇到一个字母就将更新他的最远距离
第二次遍历容器，更新最远距离，到达最远距离的下标立马分段
既然能到达最远距离，之前的元素肯定没超过这个最远距离，因为最远距离实时更新
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector&lt;int&gt; partitionLabels(string S) { int hash[26] = {0}; // i为字符，hash[i]为字符出现的最后位置 for (int i = 0; i &lt; S.size(); i++) { // 统计每一个字符最后出现的位置 hash[S[i] - &#39;a&#39;] = i; } vector&lt;int&gt; result; int num = -1; int maxpos = 0;//默认最大位置是0，而不是pos[0]，这是从a开始 //下标必须从0开始，防止丢掉第一个字符自成一段的情况 for (int i = 0; i &lt; S.size(); i++) { // 找到字符出现的最远边界，并且必须先更新当前字符 if(hash[S[i] - &#39;a&#39;]&gt;maxpos){ maxpos=hash[S[i] - &#39;a&#39;]; } if (i == maxpos) { result.push_back(maxpos - num ); num = i ; } } return result; } }; 总结统计每一个字符出现的位置，之后遍历字符串s，判断每一个字符出现的最远位置，并实时更新这个最远位置，一旦到达最远位置，说明之前的字符都在最远位置的范围内，否则最远位置就会更新，此时可以进行一次分段，每次遍历到一个字符都需要更新最远距离
并且需要先更新最远距离再判断是否到达最远距离的位置，否则就是没考虑当前字符，结果会出错
  ]]></content></entry><entry><title>435.无重叠区间</title><url>/post/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   😄435.无重叠区间
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例示例 1:
输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2:
输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3:
输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 思路基本思想与452题思路类似，452题是需要找到所有的重叠区间，这里是需要去除所有的重叠区间，让所有的区间都没有重复，所以判断条件与452题类似，先排序，这样才能在遍历容器的时候方便的知道前后两个区间是否重叠
不排序的话就需要依次从每个区间出发，判断他与其他的区间是否重叠从而删除
执行流程对容器排序，初始flag为第一个区间
遍历容器，没有遇到交集flag就更新为当前区间，遇到交集就删除，在程序中不删除只计数
遇到有交集的两个区间，尽可能保留范围小（靠右）的区间，这样尽可能地保证区间之间的间隔增大
拿[10,16],[12,14],[15,18]举例，[10,16],[12,14]有交集，留下[12,14]之后就不会与[15,18]有交集，只需要删除一次
若留下[10,16]，那么与[15,18]还有交集，需要删除两次，所以尽可能留下范围小（贪心）的区间
没遇到交集就将当前flag更新为当前区间
两种更新，有交集更新为范围小的区间，没交集更新为当前区间
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { sort(intervals.begin(),intervals.end(), [](vector&lt;int&gt;&amp; v1,vector&lt;int&gt;&amp; v2)-&gt;bool{ //第一元素相等按第二元素升序排列 if(v1[0]==v2[0]) return v1[1]&lt;v2[1]; return v1[0]&lt;v2[0]; }); vector&lt;int&gt; flag=intervals[0]; int res=0; for(int i=1;i&lt;intervals.size();++i){ //与flag作比较,有交集 if(intervals[i][0]&lt;flag[1]){ ++res; flag=intervals[i][1]&lt;flag[1]?intervals[i]:flag; } //没有交集 else{ flag=intervals[i]; } } //返回结果 return res; } }; 总结与452题一样的思路，一个时统计有多少交集，本题是去除所有交集，由于需要尽可能少的去除交集，所以在两个区间有交集时尽可能的保留范围靠右的小区间（贪心），这样与下一个区间相比时就尽可能的拉开他们之间的举例
当两个区间没有交集时，直接更新flag，判断当前区间与下一个区间是否有交集
  ]]></content></entry><entry><title>452.用最少数量的箭引爆气球</title><url>/post/452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   💣452.用最少数量的箭引爆气球
在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
示例示例 1：
输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2：
输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 示例 3：
输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 示例 4：
输入：points = [[1,2]] 输出：1 示例 5：
输入：points = [[2,3],[2,3]] 输出：1 提示：
0 &amp;lt;= points.length &amp;lt;= 10^4 points[i].length == 2 -2^31 &amp;lt;= xstart &amp;lt; xend &amp;lt;= 2^31 - 1 思路基本思想只要气球所处的位置存在交集，就可以使用一只箭将其引爆，例如[10,16]和[7,12]存在交集[10,12]，所以这两个气球可以用同一只箭引爆，现在的目标就转换成了求气球之间的公共子集
也就是出现重叠的气球（有子集）就可以使用同一只箭将其引爆
为了尽可能（贪心）让气球挤在一起，这样就可以尽可能使用一只箭就将其引爆，所以做一个排序，
一旦出现没有交集，箭的数量就需要增加，并且这个位置就可以作为一个标志，用来与后面的气球进行比较看是否存在交集
执行流程对容器进行排序，按照第一元素进行排序，让气球尽可能向左边靠，之后判断是否有交 …  ]]></content></entry><entry><title>406.根据身高重建队列</title><url>/post/406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   📏406.根据身高重建队列
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
将给定的二维数组重新排列,使其符合 [hi, ki]的要求
示例示例 1：
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2：
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示：
1 &amp;lt;= people.length &amp;lt;= 2000 0 &amp;lt;= hi &amp;lt;= 10^6 0 &amp;lt;= ki &amp;lt; people.length 题目数据确保队列可以被重建
思路基本思想第i个人的属性ki是几,这个人在queue中的位置最小就是ki,也就是说这个人前面得至少有ki个人才有机会出现i前面有ki个比他高的
例如一个people数组为[[2,1],[1,1]]就不一个合 …  ]]></content></entry><entry><title>860.柠檬水找零</title><url>/post/860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"> 🍋860.柠檬水找零
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。
顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
注意，一开始你手头没有任何零钱。
如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
示例
示例 1：
输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2：
输入：[5,5,10] 输出：true 示例 3：
输入：[10,10] 输出：false 示例 4：
输入：[5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示：
0 &amp;amp;lt;= bills.length &amp;amp;lt;= 10000 bills[i] 不是 5 就是 10 或是 20 思路
基本思想
第一想法就是顾客之间进行组合，10美元的顾客需要先有一个5美元的顾客消费，20美元的顾客需要有一个10美元，一个5美元的顾客消费或者三个5美元的顾客消费
这样才能保证可以找零
但是看到示例4发现还需要知道每种金额的数量，虽然余额为20，但是因为是两张10美金，所以无法给20美金的顾客正确找零，也就是找不开
所以可以维护两个标志，分别是5美金和10美金的个数，遇到不同的顾客对应处理不同的标志
执行流程
遍历容器，设置两个标志记录5美金和10美金的数量
遇到5美金的顾客，直接将记录5的标志++
遇到10美金的顾客，判断是否还有5美金，没有返回false
遇到20美金的顾客，先判断是否还有10+5的组合，再判断是否还有3*5的组合，没有返回false …</content></entry><entry><title>135.分发糖果</title><url>/post/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"> 🍬135.分发糖果
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 相邻孩子评分相同是可以分配相同的糖果 那么这样下来，老师至少需要准备多少颗糖果呢？
示例
示例 1:
输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2:
输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 思路
基本思想
容器不能排序，否则最开始相邻的孩子可能不相邻，拆解规则二，相邻的孩子中分数高的糖果多
这个规则可以拆分成两个规则，分数比左边高，糖果比左边多，分数比右边高，糖果比右边多
初始状态下每个小孩都有一个糖果
右大于左，右边小孩糖果数=左边小孩糖果数+1 左大于右，左边小孩糖果数=右边小孩糖果数+1 所以需要经过两次统计，两次统计的结果综合起来才是最终的结果
执行流程
从前向后遍历，如果右边小孩的分数大于左边小孩，糖果数就比左边小孩多1，完成第一阶段的统计
接下来判断左边小孩是不是比右边小孩分数高，是的话糖果数也要变化，这里必须从后向前变化
并且统计左大于右的情况时，如果出现右边小孩的糖果+1还是小于当前左边小孩的糖果数，说明左边的左边限制了这个数目，直接选取大的即可，这个不好理解的话可以想象，当前这个左边小孩的糖果数已经被左边限制住了，右边的小孩也限制住了当前的糖果数，相当于两边都有限制，为了两边都满足条件，就取最大的结果
相当于宁可多发，也不能少发
因为统计的是左&amp;amp;gt;右的情况，右边的结果直接影响到左边的结果，所以右边的要先统计
想不明白可以拿[1,2,87,87,87,2,1]举例，如果从前向后统计左&amp;amp;gt;右的情况得到的糖果数组为
[1,2,3,1,2,2,1],而从后向前统计得到的糖果数组为[1,2,3,1,3,2,1]，原因就是从前向后统计最右边的2的影响无法传递给最右边的87，因为我们此时是统计左&amp;amp;gt;右，而最右边的87的糖果数需要依赖于最右边的2，所以需要从后往前统计
可以将统计和合并的工作放在一起，不用统计完成之后再合并
代码
根据以上分析， …</content></entry><entry><title>C++11-14新标准</title><url>/post/c++11-14%E6%96%B0%E6%A0%87%E5%87%86/</url><categories><category>学习笔记</category></categories><tags><tag>c++</tag><tag>新标准</tag></tags><content type="html"><![CDATA[   😄C++11-14新标准
记录C++11&amp;amp;14中出现的新特性，主要分为语言和标准库两部分
语言介绍C++11中新出现的语言特性
Variadic Templates总结来说就是可以接收变长参数，在标准库中的万用哈希函数hash_val以及tuple等知识都用到了Variadic Templates这个新特性，接收变长参数，将其一层一层的处理
举一个简单的例子：
函数print接收的参数个数不定，假设传递n个参数，print将n个参数分成1和n-1个，先输出一个
然后在函数体内调用自身，传递n-1个参数，print将n-1个参数分成1和n-2个，输出一个。。。
就这样一层一层的调用自身，每次调用之前先减少一个参数
最后一层剩下一个参数，调用自身传递0个参数，到了结束标志，整个打印结束
递归调用自身，调用过程中剥离参数进行处理，使得参数变得越来越少
总结一个变长参数的函数模板：
1 2 3 4 5 6 7 8 template&amp;lt;typename T,typename... Types&amp;gt; void func(T&amp;amp; firstArg,Types&amp;amp; otherArgs){ // 处理firstArg //递归调用自身,少传递一个参数 func(otherArgs...); } //处理边界条件 void func(){} 如果想要知道后面的n-1个参数的大小，可以使用sizeof...(otherArgs)
...是一个包，出现在不同参数的后面就是不同的包：
typename...，模板参数包 Types... otherArgs，函数参数类型包 otherArgs...，函数参数包 不仅仅是函数，tuple也借用了变长参数的理论来实现自身，tuple可以存放不同的元素，在调用构造函数时，将传递进来的参数分成1和n-1，然后剩下的n-1以继承的方式交给新的tuple
最后使用一个空tuple处理边界条件
获取tuple中的元素时，使用head和tail，head返回1，tail返回n-1形成的tuple，在代码中先返回this，再对this进行转型
具体的实现细节如图所示：
函数和类的处理思路是一样的，一个是调用自身，一个是继承自身，在这个过程中减少参数量
hash_val的处理方式也是这样，对于自定义类型的哈希，将自定义类型拆分成多 …  ]]></content></entry><entry><title>134.加油站</title><url>/post/134.%E5%8A%A0%E6%B2%B9%E7%AB%99/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"> ⛽134.加油站
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
要保证油箱中的油大于需要消耗的汽油
基本思想就是最开始要积累足够多的剩余汽油，才够后面消耗
示例
说明:
如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 输入:
gas = [1,2,3,4,5] cost = [3,4,5,1,2] 输出: 3 解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 示例 2: 输入:
gas = [2,3,4] cost = [3,4,3] 输出: -1 解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油。开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油。开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油。你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 思路
基本思想
暴力解法
依次从每一个加油站开始出发，定义一个变量记录油箱中的油量，看油量是不是大于等于消耗的油量，也就是剩余油量是不是大于零，是的话就可以到达下一加油站，加油之后（油量=剩余+新的）再走，主要关注如何判断是一个环
可以判断当前是不是走到了容器的末尾，是的话让下标直接截断到0，直接使用取余就可以截断
相当于使用了暴力解 …</content></entry><entry><title>1005.K次取反后最大化的数组和</title><url>/post/1005.k%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   😉1005.K次取反后最大化的数组和
给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）
以这种方式修改数组后，返回数组可能的最大和。
示例示例 1：
输入：A = [4,2,3], K = 1 输出：5 解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。 示例 2：
输入：A = [3,-1,0,2], K = 3 输出：6 解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。 示例 3：
输入：A = [2,-3,-1,5,-4], K = 2 输出：13 解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。 提示：
1 &amp;lt;= A.length &amp;lt;= 10000 1 &amp;lt;= K &amp;lt;= 10000 -100 &amp;lt;= A[i] &amp;lt;= 100 思路基本思想对数组反转k次时，尽可能将较大的负数先反转，使得数组中留下的负数越少越好，此时数组相加的和才会更大
主要需要分情况讨论：
k小于负数个数：挑小的负数先反转之后再相加
k大于负数个数：剩下的是奇数，则将最小的的正数反转，剩下的是偶数不用管
为什么剩下的偶数不用管，因为他可以分成两次两次的反转，由于可以选择任意一个元素，所以分别作用到每个正数上，正-&amp;gt;负-&amp;gt;正不会产生变化
但是奇数的话需要注意，两次两次的反转，会剩下一个单次反转，此时只需要挑一个最小的数反转，使其影响最小
k大于负数个数时需要分情况，正数需要选择真正最小的正数
执行流程为了将负数集中在一起，并且先反转绝对值较大的负数，我们将元素升序排序，所以绝对值最大的负数会出现在最前面，最小的正数在最后一个负数的后面
遍历数组，遍历的过程中将负数反转，遇到k==0的情况直接退出返回数组求和的结果
遇到正数元素，判断剩下的k是偶数还是奇数，奇数将当前正数元素反转后相加，偶数直接相加
可以想象成此时k全部作用到这个最小的正数上
注意不要把反转负数和反转正数的代码写在一起，负数反转之后也变成正数，如果放在一起负数会先反转成正数，然后再反转成负数，例如下面的代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 …  ]]></content></entry><entry><title>45.跳跃游戏II</title><url>/post/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   🚶‍♂️45.跳跃游戏II
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
示例:
输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置
思路基本思想在跳跃游戏的基础上增加条件，要求最短的步数内到达终点，只需要遍历容器，遍历的过程中一旦出现最大范围到达或者超过终点就直接结束，简单修改条跳跃游戏的代码即可
但是需要注意什么之后才增加步数，每走一步都尽量是最大的一步
所以走第一步时有一个最大范围，在最大范围内的节点进行测试，看谁跳得最远，第一步范围内的节点测试完毕的标志是当前节点的下标就是最大范围，此时走一步，并更新最大范围，如果到达或者超过终点，直接结束
每一步的最大范围都尽可能的最大
执行流程每走一步都更新下一步的最大范围，第一步走完之后（节点到达第一步的最大范围），走第二步，在第二步的最大范围内更新第三步的最大范围、、、也就是说每一步都找下一步能到达的最大步数
就这样遍历，每一步都走最大的步数，当出现最大范围超过或者等于终点时，可以结束
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int jump(vector&lt;int&gt;&amp; nums) { if(nums.size()==1) return 0; int curRange=0; int nextRange=0; int step=0; for(int i=0;i&lt;nums.size();++i){ //每一步都尝试更新下一步的最大范围 nextRange=nums[i]+i&gt;nextRange?nums[i]+i:nextRange; //走到当前步的范围终点，选择最大的一步走出去 //到了边界就走出下一步 if(i==curRange){ ++step; curRange=nextRange; if(curRange&gt;=nums.size()-1){ break; } } } return step; } }; 总结相比于跳跃游戏第一版本，只是判断终点是否可达，第二版本默认终点一定可达，只是要求解到达终点的最小步数，此时就需要尽量将每一步都走到最大
对于每一步来说，都有一个最大范围，先走第一步，在第一步的最大范围内找到能到达的最大范围，这就是第二步的最大范围，在第二步中找第三步。。。直到到达或者超越终点
可以看作是一个双层循环，外层循环走每一步，内存循环在每一步中找下一步的最大范围
  ]]></content></entry><entry><title>55.跳跃游戏</title><url>/post/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   🏃‍♂️55.跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例示例 1:
输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2:
输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 思路基本想法当前的元素代表的是跳跃的最大长度len，所以可以选择跳的长度范围为[0,len]，那么到了一个节点，选择跳几步呢
其实不管选择几步，都会有一个最大的范围，最大范围内的元素又可以跳，所以会越跳越远
重点就是最大范围内的元素可以跳，范围之外的元素不能跳，所以需要判断当前的元素是不是最大范围内的元素，也就是是不是可以由前面的元素跳到
相当于可以尽力跳出最远从而得出一个范围，范围之内的距离肯定都可以到达
执行流程遍历容器，对于每一个元素，判断他是不是在最大范围内（第一个元素除外），如果是的话他就可以跳，一旦出现不在最大范围内的元素，后面的元素肯定都不在最大范围内，可以直接结束遍历
遍历结束后，判断最后一个下标是不是在最大范围内，是的话就可以跳到， 返回true，不是的话就不可达，返回false
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: bool canJump(vector&lt;int&gt;&amp; nums) { //记录最大的范围 int maxRange=nums[0]; //直接从第一个元素开始 for(int i=1;i&lt;nums.size();++i){ //在最大范围内就可以跳 if(i&lt;=maxRange){ //更新maxRange maxRange=maxRange&gt;i+nums[i]?maxRange:i+nums[i]; } //出现元素在最大范围外跳不动了 //或者已经可以到最后了 if(i&gt;maxRange || maxRange&gt;=nums.size()-1){ break; } } //判断是跳不动了还是到了最大的范围 if(maxRange&gt;=nums.size()-1) return true; else return false; } }; 总结每个可达节点处都尽力而为，跳出最大的范围，如果终点在最大范围内，那么一定可达
如果出现某个节点不在最大范围内，说明这个节点不可达，剩下的节点也不可达（更远），所以停止跳跃，只有当节点在最大范围内是才可以继续跳跃
  ]]></content></entry><entry><title>121.买卖股票的最佳时机</title><url>/post/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag><tag>动态规划</tag></tags><content type="html"><![CDATA[   💰121.买卖股票的最佳时机
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
尽可能地在最低点买入，然后在之后的最高点卖出，只买卖一次
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例示例 1：
输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：
输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
提示：
1 &amp;lt;= prices.length &amp;lt;= 105 0 &amp;lt;= prices[i] &amp;lt;= 104
思路低就买入，高就卖出
贪心思路由于不知道什么时候是最低点，什么时候是最高点，所以我们默认当前值就是最低点，先进行买入，然后遇到比买入点低的我们就买入，继续向后遍历，总能找到最低的一个买入点
在买入之后，遇到比买入点低的我们就买入，遇到比买入点高的我们就卖出，卖出之后遇到更高利润就更新利润结果，当运行结束之后，就会知道当前股票的最高利润是多少
DP思路设置两个变量，一个记录买入的价格，一个记录卖出的价格，买入的价格之和前一天进行比较，如果当天买入价格更低，就在当天买入，如果前一天买入的价格更低，就记录这个更低的买入价格
卖出价格也与前一天进行比较，如果价格更高就卖出，价格没有前一天高就记录这个更高的卖出价格
整体的思路还是与贪心的思路一致，两个变量最后保存的都是自己的最值，由于卖出在买入的后面，所以不会出现先卖出再买入的情况，例如[9,2,4,1]，在9卖出，在1买入的情况
dp[i][0]代表第i天买入花费的金额
dp[i][1]代表第i天卖出得到的金额
贪心执行流程设置两个变量，一个存放买入价格，一个存放结果利润，买入价格的初值就是容器第一个元素的值，结果利润的初值是0
之后遍历容器，遇到低就买入，遇到高就卖出，这样设置之后，“最高 …  ]]></content></entry><entry><title>122.买卖股票的最佳时机II</title><url>/post/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag><tag>动态规划</tag></tags><content type="html"><![CDATA[   💰122.买卖股票的最佳时机II
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有 一股 股票。你也可以先购买，然后在同一天出售。
多次买卖，且买卖时间不能重合，但是卖和买可以在同一天，所以需要将多次买卖的利润求和
返回 你能获得的最大利润 。
示例示例 1:
输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:
输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:
输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：
1 &amp;lt;= prices.length &amp;lt;= 3 * 10 ^ 4 0 &amp;lt;= prices[i] &amp;lt;= 10 ^ 4 思路贪心思路如果只能买卖一次，那么就直接更低点买入，更高点卖出，有更大利润就更新，但是这里是可以买卖多次，也就是说卖出去之后还可以买卖，但是必须卖出去之后才能买入，也就是说卖卖的时间段不能交叉
这里借鉴一次卖出的思想，将当前的每一天都当作最高点进行卖出，然后在前一天进行买入，统计两天之间的利润，这样一段时间的利润就被分成了每两天之间的利润和
之后统计两天之间大于0的利润之和，也就是统计所有盈利的部分，去除亏损的部分，由于是两天之间的利润，为最小单位，所以不会出现重叠，符合题目要求
形成的利润数组如图所示：
不是一次买入的更低就买，更高就卖，而是两天一买卖，最后统计所有盈利的部分，防止出现重叠，且可以使得利润最大化
DP思路由于买入时手上不是一分钱都没有，而是有之前买卖股票盈利 …  ]]></content></entry><entry><title>STL标准库和泛型编程</title><url>/post/stl%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url><categories><category>学习笔记</category></categories><tags><tag>STL</tag><tag>泛型编程</tag></tags><content type="html"> 😶STL标准库和泛型编程
STL标准库和泛型编程的学习笔记，记录了STL中六大部件之间的关系和部件的实现细节，以及泛型编程的相关知识，逻辑稍微有点乱，后期再修改
引言
STL六大部件分别是：容器、算法、迭代器、仿函数、适配器、分配器
其中容器、算法、迭代器是最基本的，迭代器是算法和容器之间的桥梁
仿函数就是一个重载了()的类，使用该类生成的对象调用()方法，看起来就像函数调用，所以称为仿函数，仿函数主要与算法配合使用，作为参数传递，解锁算法高级用法
适配器可以作用在容器上，改造容器形成容器适配器。作用在仿函数上就形成了仿函数适配器，但是这个放仿函数必须
继承
一元或者二元谓词。作用在迭代器上就形成了迭代器适配器
适配器的作用就是对STL的基础部件进行改造，使其更加符合自己的需求
最后的分配器就是服务于容器，每个容器底层的内存分配就是分配器负责
六大部件具体的关系如下：
第一部分
相当于一个基本的介绍，介绍容器的使用
容器测试
总结：在泛型编程中，支持随机访问的容器不需要自定义sort，但是STL中的sort需要容器支持随机访问，所以不支持随机访问的迭代器需要自定义sort
vector
vector自身不存在sort函数， 需要使用c标准库中的qsort
因为vector可以随机访问，所以根据泛型编程的思想，需要将算法分离来，
也就是自身不存在sort
并且vector扩充空间时扩充的很多，如果没有用到就会造成内存浪费
list
list是一个双向链表，头部和尾部都可以操作，扩充内存时是一个一个扩充，使用指针进行连接
并且list容器自带sort函数
因为list不支持随机访问，所以无法使用STL中的sort，所以需要单独定义sort排序算法
forward_list
前向链表只可以在头部进行操作，并且没有size函数，只有max_size函数
容器自带sort函数
deque
双端队列可以在两端进行操作，相当于连续版的双向链表，并且扩充内存时是一块一块扩充，也就是外部看起来像是连续空间，但是内部并不是连续的，而是多个连续的小内存块组成deque的空间
容器自身不带sort函数
stack
stack默认是将deque进行改造形成的容器适配器，但是也可以指定使用其他容器改造
可以实现后进先出操作，具体的改造就是封闭push_front和pop_front函数，使其 …</content></entry><entry><title>53.最大子序和</title><url>/post/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   💫53.最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6 思路基本想法遍历容器，如果当前的元素大于零，就加到后面的元素中，然后记录相加之后的结果
如果相加小于零，说明会拉低连续子序列的大小，就不加到当前位置，但是需要尝试当前位置加到后面的序列中是不是正数
进行一遍遍历之后，最大的子序列一定会出现在容器的某个位置中，找出最大值即可
找最大值还需要排序之后找出容器开头或末尾的元素，消耗时间。
可以找一个标志记录每次都最大值，有最大值就更新，这样运行结束之后标志中就存放着最大值
一定要从大于零的位置开始累加，因为[-1,2,4,3,-1,7]和[2,4,3,-1,7]相比，肯定是从正数元素开始累加才会更大
总结：一旦出现负值，就需要放弃之前的累加，重新从当前的正值元素开始累加
执行流程遍历容器，从前向后累加元素，一旦出现小于零的累加，就放弃这段序列，重新从大于零的位置开始累加，原因参考[-1,2,4,3,-1,7]和[2,4,3,-1,7]，在累加的过程中，每走一步统计一下最大值，判断是否更新
而只要累加之后是正数，就可以对序列和起到增益效果
每一步累加之后都需要先统计是否更新最大值，之后再将负数截断，因为最大子序和可能是一个负数
这样即使出现最大值，然后后面出现一个负数将最大值拉低，那么也会记录这个最大值，代码搜索的过程如下：
代码根据以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { //记录最大值的标志 int res=INT32_MIN; //记录序列的累加和 int sum=0; //遍历容器 for(int i=0;i&lt;nums.size();++i){ sum+=nums[i]; //每走一步就统计一下最大值 //并且必须放在累加之后，因为有可能最大序列和是负数 //此时就会 if(sum&gt;res) res=sum; //小于零的序列和舍弃 if(sum&lt;0) sum=0; } return res; } }; 总结遍历容器，然后一步一步的累加，判断是否比最大值大，大的话就更新，之后判断如果子序和如果是负数的话就截断，因为只有正数才会对子序和产生增益效果
由于最大子序和有可能是负数，所以截断的操作必须放在统计最大值之后
并且每一步都会统计，所以即使最大值被负数拉低，程序中也有记录
尽可能的往后加，相加得出负数才会放弃当前子序列，因为负数对累加无法起到增益效果
程序运行结束，得到最大子序和
不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数
  ]]></content></entry><entry><title>455.分发饼干</title><url>/post/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url><categories><category>leetcode</category></categories><tags><tag>贪心算法</tag></tags><content type="html"><![CDATA[   👶455.分发饼干
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
示例示例 1:
输入: g = [1,2,3], s = [1,1] 输出: 1 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。 示例 2:
输入: g = [1,2], s = [1,2,3] 输出: 2 解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2. 提示：
1 &lt;= g.length &lt;= 3 * 10^4 0 &lt;= s.length &lt;= 3 * 10^4 1 &lt;= g[i], s[j] &lt;= 2^31 - 1 思路基本想法先将饼干的尺寸从大到小排序，再将孩子的胃口从大到小排序
然后依次取出一个饼干和一个孩子的胃口，匹配成功一此就将结果数加一
匹配到某一个地方饼干太小就找一个胃口更小的孩子，放在图中就是尺寸为9的饼干满足不了胃口为10的小孩，换一个胃口为7的小孩就好了
当这个饼干的尺寸满足不了所有孩子的胃口，就说明程序结束
执行流程按照上面的描述，有两个容器，需要先进性降序排序
然后进行匹配，匹配成功结果数加一，两个容器都向后移动
匹配失败只有孩子的胃口容器向后，当孩子的胃口容器遍历结束时直接返回结果集即可
代码按照以上分析，得出以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { //先将两个容器进行降序排序 sort(g.begin(),g.end(),greater&lt;int&gt;());//胃口容器 sort(s.begin(),s.end(),greater&lt;int&gt;());//饼干容器 vector&lt;int&gt;::iterator git=g.begin(); vector&lt;int&gt;::iterator sit=s.begin(); int res=0; if(s.size()==0) return res; //饼干没了或者孩子分完了都算结束 while(git != g.end()&amp;&amp; sit!= s.end()){ //饼干尺寸大于等于胃口 if((*sit)&gt;=(*git)){ ++sit; ++git; ++res; } //饼干尺寸满足不了孩子的胃口 //换一个小胃口的孩子 else{ ++git; } } //统计结束返回人数 return res; } }; 总结先将容器排序，之后对于胃口大的孩子先分大尺寸的饼干，然后依次向下分
因为饼干尺寸降序，所以当前饼干无法满足当前的小孩时，就换一个胃口更小的小孩
  ]]></content></entry><entry><title>Linux学习笔记</title><url>/post/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url><categories><category>学习笔记</category></categories><tags><tag>linux</tag></tags><content type="html"> linux学习笔记
linux系统的基本结构、编辑器、一些基本的配置以及linux的实操和扩展，包括文件管理、用户权限、磁盘管理、进程管理以及shell编程
linux安装
简单的东西只需要下一步即可，但是分区需要注意,以及安装时需要选择GUI的服务器，linux才带桌面，不能默认最小安装
分区
linux中磁盘分区称为挂载，一个分区就是一个挂载点
之后进入分区界面，然后设置启动分区和其他分区
启动分区：/boot
启动分区必须选择/boot挂载点，之后文件系统选择xfs，
交换分区：swap
当linux的内存占用率较高时，将内存中暂时不需要使用的应用程序移动到硬盘的交换区，然后将急需运行的程序调用到新空出来的空间
此时文件系统的格式直接指定为swap且不能修改
3.剩余分区：/
将硬盘剩余容量挂载到根上
配置完成之后，系统从/boot启动，文件存储在/下，内存容量不够时从swap中交换
基础篇
直接在终端中进行一系列操作，在/下有一系列的文件，文件中还有文件，形成一棵树状结构，linux中一切皆文件
系统结构
了解系统根目录下有哪些东西，都有什么用
切换到根目录：cd /
bin目录中存放的全是可执行的命令，比如cd ls等
lib中存放的全是系统运行所必须的文件，类似于win中的System32
usr中包含用户所有的应用程序和所需要的数据
etc中存放的是系统管理所需要的配置文件
opt是给应用程序留的空间
srv是给系统提供服务的信息
sys是系统文件夹
文本编辑器
当linux中需要修改文件时，需要使用文本编辑器取修改，也可以使用图形化界面编辑，但不够高效，linux中最著名的文本编辑器就是vim
切换输入法的快捷键：win+空格
输入时可以按tab自动补全
使用vim编辑文件：vim+文件名 退出编辑：：q vim的三种模式
一般模式：不能直接编辑文本，可以删除，复制，粘贴，按esc回到一般模式
num+yy：复制num行
y+$：复制从当前光标位置到行尾的内容
y+^：复制当前光标到行头的内容
^：到行头
$：到行尾
y+w：复制当前单词（光标到下一个空格之前）
num+p：将剪切板中的内容粘贴num次
num+dd：删除num行
u：撤销操作，可以不停u一直撤销
x：剪切当前光标的内容
gg：跳转到第一行
L或G：跳转到最后一行
num+G：跳转 …</content></entry><entry><title>37.解数独</title><url>/post/37.%E8%A7%A3%E6%95%B0%E7%8B%AC/</url><categories><category>leetcode</category></categories><tags><tag>回溯法</tag></tags><content type="html"><![CDATA[   😯37.解数独
编写一个程序，通过填充空格来解决数独问题。
一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 &amp;lsquo;.&amp;rsquo; 表示。
示例：
答案被标成红色。
提示：
给定的数独序列只包含数字 1-9 和字符 &amp;lsquo;.&amp;rsquo; 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的 思路基本想法题目的要求是在每一个3 * 3的小空间中填充九个数字，每个3 * 3的小空间中本身就填充了一部分元素，只有&amp;rsquo;.&amp;lsquo;的位置才需要填充元素
所以第一想法是使用回溯法，横向遍历取出一行中的一个空白位置，并且填入一个合法元素，之后再取出一行中的下一个空白位置填入一个合法元素，一行填充完成进行下一行，一旦遇到某一行冲突，就需要回溯一次，如果整个9 * 9的位置都被填满，说明找找到一个合法的数独，直接返回
也就是从左到右，从上到下，依次填充每一个空白位置，遇到非法的情况就换一个数字填充，9个数字都非法就说明前面的位置填充出错，需要返回并回退，上层尝试下一个合法数字之后再向下递归
就像是尝试着向下，遇到错误向上修正，修正出错再向上
代码随想录中是每层都从[0] [0]的位置开始搜索一个空白位置，我认为可以记录上一层的行列位置，下一次从这个位置的下一个位置开始搜索即可，因为前面的位置都被填充了，完全可以从上一层的下一个位置开始，但是还没想明白为什么这样写程序会报错😕
记住当前位置的行，搜索时从当前行出发是可以的，但是不能记住当前位置的列，否则两层for循环就变成了：
1 2 for (int i = row; i &amp;lt; board.size(); i++) { // 遍历行 for (int j = col; j &amp;lt; board[0].size(); j++) { // 遍历列 假如当前行搜索完成都没找到空白位置，想从下一行开始找，按照上述for循环，就会直接从col开始，不会从0开始，会漏掉一些情况，但是记住但其当前位置的行是没错的，因为行搜索到末尾从下一行开始找时，行不会减小，但是列会，所以只能记住当前位置的行，但是这样也可以剪枝加快速度
举例来说：
如果我们记住当前2的位 …  ]]></content></entry><entry><title>51.N皇后</title><url>/post/51.n%E7%9A%87%E5%90%8E/</url><categories><category>leetcode</category></categories><tags><tag>回溯法</tag></tags><content type="html"><![CDATA[   😱51.N皇后
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &amp;lsquo;Q&amp;rsquo; 和 &amp;lsquo;.&amp;rsquo; 分别代表了皇后和空位。
示例 ：
输入：n = 4 输出：[[&amp;quot;.Q..&amp;quot;,&amp;quot;&amp;hellip;Q&amp;quot;,&amp;ldquo;Q&amp;hellip;&amp;rdquo;,&amp;quot;..Q.&amp;quot;],[&amp;quot;..Q.&amp;quot;,&amp;ldquo;Q&amp;hellip;&amp;rdquo;,&amp;quot;&amp;hellip;Q&amp;quot;,&amp;quot;.Q..&amp;quot;]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 思想基本想法相当于一个n*n的二维数组，每当一个皇后占领一个位置，同行、同列和同斜线都不能再放皇后，主要问题我认为有两个：
如何求出所有可能：回溯法 如何判断皇后存在的行列位置不会引起冲突 回溯法解决以上问题，在一行中找到一个合法位置，然后再递归到下一行，再继续找，当递归到最后一行的下一行，说明找到一个完整的解法，此时加入结果集
至于如何判断皇后存在的行列位置不会引起冲突，直接分成三种情况，同列、同主对角线和同副对角线都没有皇后，那么当前位置就合法
为什么不用判断同行呢，因为递归的过程中一次只在一行中选一个位置就到了下一行，回溯的时候会进行回退再选择同一行中的下一个元素，所以行一定不会冲突
执行流程首先定义一个棋盘用来放置元素，初始情况下一行有n个&amp;rsquo;.&amp;rsquo;，一共有n行
然后走到棋盘中的一个位置就判断一次，看是否合法，合法的话就将当前位置放上皇后，不合法的话就换一个位置
当形成一个合法的皇后，或者一行中没有一个元素合法走到for循环的末尾时，都会回溯，在回溯之前，每一行中的所有位置都会被判断，除非遇到半途而废的情况，直接回溯，后面几行直接不搜索，三皇后形成的搜索树如下：
返回的情况不一样，有的半途而废，有的最后才发现不合法，有的最后满足条件加入结果集
判断当前位置是否合法只需要判断同列、同主对角线、同副对角线即可，因为递归每次只会在一行中选一个元素，并且回溯之后会手动回退，所以搜索判断的方向如图所 …  ]]></content></entry><entry><title>平衡二叉树和红黑树</title><url>/post/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/</url><categories><category>学习笔记</category></categories><tags><tag>平衡二叉树</tag><tag>红黑树</tag></tags><content type="html"> 😄平衡二叉树和红黑树
介绍平衡二叉树的插入和删除操作，红黑树的基础理论以及红黑树的插入和删除
平衡二叉树
插入
首先在树上进行搜索，找到要插入的位置，插入之后若出现不平衡则调整 插入的节点肯定是在叶子节点上，从当前插入节点自底向上找到第一棵不平衡子树的根节点root 当前节点到根节点有一条路径，从这条路径自顶向下找到从root开始的三个节点 三个节点形成一个平衡二叉树x，然后将不平衡子树的剩余节点直接插入x中即可，插入时需要保留原来的父子和兄弟关系 以上方法是通法，不再需要考虑LL,LR,RR,RL分类的情况
举例：
插入63,出现不平衡情况：
从63向上找到第一个不平衡子树的根节点为50，50到63的路径为：[50,68,66,60,63]，前三个节点为[50,68,66]，组成一个二叉树：
之后将剩下的[21,26,30,60,63,67,70,90]直接插入即可，插入时原来的父子和兄弟关系需要保留：
删除
按照二叉搜索树的方式进行删除，最复杂的情况就是待删除节点左右子树都不为空，此时将此节点的左子树接入右子树的最左边节点，
参考
判断整棵树是否平衡，不平衡的话借鉴插入的思想，自底向上找到最小的不平衡二叉树进行调整，调整的思路与插入时一样 将最小不平衡子树的最底层叶子节点当作终点找到一条路径，然后调整，如果最底层叶子节点有多个，那么就任选一个，但是推荐选靠右的27 举例，删除2：
删除之后不平衡，最小不平衡子树的根节点为11，最底层叶子节点为17和27，任选一条路径调整即可，这里推荐选择靠右的27：
调整之后为：
AVL总结
平衡二叉树的调整时插入和删除的基础，插入和删除参考二叉搜索树的插入和删除，之后就是将插入和删除之后的树调整成平衡二叉树，主要步骤如下：
自底向上找到最小的不平衡二叉树的根节点root 从root出发找一条到最底层节点的路径，取出前三个节点形成平衡二叉树x 剩下的节点在不改变父子和兄弟关系的前提下插入x即可 插入只用调整一次，删除可能需要调整多次 二叉排序树的插入和删除+平衡二叉树的调整
红黑树
为了提高系统的查询效率，引入红黑树，那么为什么不使用平衡二叉树呢，因为平衡二叉树的调整太消耗时间，一旦节点变化，那么就要调整，导致平衡二叉树花费了大量的时间进行调整，所以出现频繁的插入和删除时，平衡二叉树性能并不是很好
基于以上分析引入了红黑树，他 …</content></entry><entry><title>332.重新安排行程</title><url>/post/332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/</url><categories><category>leetcode</category></categories><tags><tag>回溯法</tag></tags><content type="html"><![CDATA[   😭332.重新安排行程
给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。
示例提示：
如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [&amp;ldquo;JFK&amp;rdquo;, &amp;ldquo;LGA&amp;rdquo;] 与 [&amp;ldquo;JFK&amp;rdquo;, &amp;ldquo;LGB&amp;rdquo;] 相比就更小，排序更靠前 所有的机场都用三个大写字母表示（机场代码）。 假定所有机票至少存在一种合理的行程。 所有的机票必须都用一次 且 只能用一次。 示例 ：
输入：[[&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;],[&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;],[&amp;ldquo;SFO&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;],[&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;JFK&amp;rdquo;],[&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;]] 输出：[&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;] 解释：另一种有效的行程是 [&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;]。但是它自然排序更大更靠后。 思路基本想法需要明确以下问题：
如何搜索：从出发机场x开始搜索，判断x可以到哪些y，进行统计。之后再从y出发，判断y可以到哪些z。。。
如何排序：
题中要求对于同一个出发机场的不同到达机场，字母排序在前面的到达机场需要先选择
一定要理解这一句，所以在记录一个出发机场的所有到达机场时，需要将到达机场排序，可以使用map，因为他自动给元素排序
何时终止：给定一个tickets的集合，一共有ticketNum种行程，最终形成的行程序列长度一定 …  ]]></content></entry><entry><title>Git学习笔记</title><url>/post/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url><categories><category>学习笔记</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[   😄Git学习笔记
Git的基本理论和使用
版本控制开发过程中项目不断更新迭代，此时使用Git就可以进行版本控制
版本控制总共分为三种：
本地版本控制：个人用户在本地控制自己的项目 集中版本控制（SVN）：多人协同开发一个项目，更新历史存放在服务器上 分布式版本控制(Git)：版本信息同步到每个用户，本地可以看到所有的版本历史，理解为用户也相当于一个服务器，拥有所有版本信息 常用的版本控制器目前使用最广泛的是Git与SVN。
他们主要的区别:
SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就完蛋了。 Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 Git配置安装无脑下一步
Git连接GitHub1 2 3 4 git config --global user.name &amp;#34; GitHub 用户名 &amp;#34; 例如：git config --global user.name &amp;#34;zzziCode&amp;#34; git config --global user.email &amp;#34;github用户的邮箱&amp;#34; 例如：git config --global user.email &amp;#34;1980136696@qq.com&amp;#34; 运行之后Git就连接到了GitHub
系统配置文件在：E:\Program Files\Git\etc\gitconfig
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [diff &amp;#34;astextplain&amp;#34;] textconv = astextplain [filter &amp;#34;lfs&amp;#34;] …  ]]></content></entry><entry><title>47.全排列II</title><url>/post/47.%E5%85%A8%E6%8E%92%E5%88%97ii/</url><categories><category>leetcode</category></categories><tags><tag>回溯法</tag></tags><content type="html"><![CDATA[   😏47.全排列II
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
示例示例 1：
输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2：
输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示：
1 &amp;lt;= nums.length &amp;lt;= 8 -10 &amp;lt;= nums[i] &amp;lt;= 10 思路基本想法基本思想与无重复元素的全排列一样，都需要每次取出集合中的一个未使用元素，将其标记为已使用，并进行递归，但是本题中是可重复元素，所以需要考虑去重
去重并不是直接将集合中的重复元素去除掉在进行全排列，而是在搜索时，每一层中同样的元素只可以使用一次，但是不同层可以使用值相同的元素
如何理解：例如[1,1,2,2]，第一层取一个1，剩下的集合为[1,2,2]，第二层还是可以取一个1，剩下[2,2]，第三层取2，剩下[2]，第四层取一个2，剩下[]，此时形成一个全排列，达到递归返回的条件，并且for循环也结束，直接退回到第三层，此时剩下元素[2]，但是这个2不能使用，与红色的2值相同，并且处于同一层，这样一直搜索下去，形成一个搜索树：
总结来说，由于元素经过排序，所以在同一层中，出现当前元素与前一个元素重复，并且前一个元素被使用，那么当前元素就不能被使用了
执行流程主要需要考虑的就是如何去重，与之前子集的去重思路一样，但是增加了一个判断条件，由于之前的子集问题使用startIndex直接缩小集合的大小，进入下一层之前就可以将上一层使用的元素剔除掉，而排列问题不行，所以增加一个判断条件，很巧妙。
增加的条件：flag[i-1]==false，当flag为true时说明纵向遍历中元素被使用过，当flag为false说明横向遍历中元素被使用，为什么。因为同一层元素横向便利时，必然是遇到了回溯，也就是说flag[i]=false,在进行下一个元素的判断，所以此处是flag[i-1]==false
所以去重条件为：
1 2 if(i&amp;gt;0&amp;amp;&amp;amp;nums[i]==nums[i-1]&amp;amp;&amp;amp;flag[i-1]==false) continue; 当前元素与上一 …  ]]></content></entry><entry><title>46.全排列</title><url>/post/46.%E5%85%A8%E6%8E%92%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>回溯法</tag></tags><content type="html"><![CDATA[   😍46.全排列
给定一个 没有重复数字的序列，返回其所有可能的全排列。
示例示例:
输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 思路基本想法拿[1,2,3]举例，首先从1开始，先取2，再取3，形成[1,2,3]，之后取3，再去2，形成[1,3,2],
之后从2开始，取1，3形成[2,1,3]，取3，1形成[2,3,1]，最后从3开始，对剩下两个元素进行排列
总结来说就是取一个元素，再对剩下的元素进行全排列，依次取遍集合中的所有元素，剩下的元素全排列即可。
对于剩下的元素是一样的处理逻辑，从剩下的元素中取一个，依次取遍剩余集合中的所有元素，每次取一个剩下的元素，形成一个更小的集合。。。
由此形成一个搜索树：
相对于组合来说，排列可以每次都从头开始取元素，但是上层已经使用过的元素不能再用
执行流程从之前的子集问题思路开始，确定递归结束的条件，for循环的范围
递归结束的条件：由于是全排列，所以当path中的元素个数等于nums中的元素个数时就形成了一个全排列，此时加入res结果集中并进行返回
for循环的范围：由于每次取一个元素，再把剩下的元素进行全排列，所以不能简单的通过for循环的范围进行限制，而是需要使用一个标志记录当前哪个元素被使用
并且由于需要进行多层递归，所以只能使用一个标志数组来记录每一层被使用过的元素
剩下的过程与子集问题完全一样
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: //全局变量存放结果和子集合 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { if(nums.size()==0) return res; vector&lt;bool&gt; flag(nums.size(),false); backtrack(nums,flag); return res; } void backtrack(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; flag){ //当形成一个排列时才加入res并返回 if(path.size()==nums.size()){ res.push_back(path); return; } //进行横向遍历，依次取一个元素 for(int i=0;i&lt;nums.size();++i){ //当前元素没有在上一层和当前层被使用才进行全排列 //flag数组中记录的是当前排列已经有哪些元素了 if(flag[i]==false){ path.push_back(nums[i]); //当前元素被使用，对应标志位变化 flag[i]=true; backtrack(nums,flag); //回溯 path.pop_back(); //当前元素退出path，对应标志位也要变化 flag[i]=false; } //当前元素被使用 else{ continue; } } } }; 总结在子集的基础上放开限制，[1,2]和[2,1]在排列问题中是不一样的，在子集问题中是一样的，除了此处不同，在for循环判断条件上也有不同，子集问题有一个startIndex，而排列问题每次都是遍历整个集合，使用一个标志数组来记录哪些元素被使用过，所以在回溯时，不仅仅时path.pop_back(),还有flag[i]=false。
每一次从当前元素重新出发，但是需要注意的是，已经遍历过的元素不能再遍历了
  ]]></content></entry><entry><title>491.递增子序列</title><url>/post/491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url><categories><category>leetcode</category></categories><tags><tag>回溯法</tag></tags><content type="html"><![CDATA[   😴 491.递增子序列
给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。
示例示例:
输入: [4, 6, 7, 7] 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 说明:
给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。 自己的想法思路基本想法是求数组幂集的改进，先求数组的幂集，然后将幂集中的所有递增子序列找出来，并且数组中的元素可能重复，所以需要进行两次判断：
递增子序列 元素没重复使用 形成新的搜索树：
执行流程首先需要从头开始遍历，当子数组元素个数大于一才符合第一个要求，此时还需判断当前子数组中的元素是否是递增序列，最后还需判断数组中的元素是否重复使用。
并且由于求的是数组中自然递增的子序列，所以不能使用排序，不然所求结果就不是自然递增的子序列，判断元素重复的方法就不能简单的使用前一个元素等于当前元素，也就是：
1 2 3 if(i&amp;gt;index&amp;amp;&amp;amp;nums[i]==nums[i-1]){ continue; } 而是需要判断从index开始到当前位置的前一个元素有没有与当前元素重复的元素nums[index ~ i-1]==nums[i]??
总结来说，在求幂集的思路上，代码中还需要使用三个判断逻辑：
元素个数是否大于一 子数组是否是递增序列 是否使用重复元素 代码根据以上分析，得出以下代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solution { public: //定义全局变量存放结果和子数组 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;int&amp;gt; path; …  ]]></content></entry><entry><title>VSCode无法编译C++中文文件解决办法</title><url>/post/vscode%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91c++%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url><categories><category>教程</category></categories><tags><tag>VSCode</tag><tag>中文编码</tag></tags><content type="html"> 😄VSCode无法编译C++中文文件解决办法
更新.vscode文件夹中的配置文件
直接更换launch.json和tasks.json文件中的配置
改变launch.json：
改变tasks.json：</content></entry><entry><title>90.子集II</title><url>/post/90.%E5%AD%90%E9%9B%86ii/</url><categories><category>leetcode</category></categories><tags><tag>回溯法</tag></tags><content type="html"><![CDATA[   90.子集II
给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例:
输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路基本想法相比于70题，只是多了一个可能包含重复元素，只需要在递归之前检查当前元素是否重复即可，所以形成的搜索树会有一些树枝被剪掉
但是给定的nums可能是无序的，所以需要先进行排序，让重复的元素挨在一起，才可以执行去重操作，避免出现重复子集。
执行流程也是分为横向遍历和纵向遍历，只不过在每次横向遍历的过程中需要增加条件进行筛选，重复元素不能选取，否则会出现多次从同一个x开始进行搜索的情况
例如[1,2,2,3]，不加筛选条件可能会出现两次从2开始形成子集的情况，筛选条件如下：
1 2 3 4 //当不是当前层横向遍历的第一个元素时，就可能出现重复子集的情况 if(index==nums.size()){ return; } 代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: //全局变量存放结果 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { if(nums.size()==0){ return res; } //vector自身没有sort函数 //因为它可以随机访问，没必要增加自带sort函数 sort(nums.begin(),nums.end()); backtrack(nums,0); return res; } void backtrack(vector&lt;int&gt;&amp; nums,int index){ res.push_back(path); if(index==nums.size()){ return; } //进行横向搜索 for(int i=index;i&lt;nums.size();++i){ //需要增加筛选条件 //之前从x开始搜索过，之后就不必再从x开始搜索 if(i&gt;index&amp;&amp;nums[i]==nums[i-1]){ continue; } //元素没有重复 path.push_back(nums[i]); //进行递归纵向遍历 backtrack(nums,i+1); //回溯 path.pop_back(); } } }; 总结出现重复元素求幂集，可能会出现重复元素的搜索，从而出现重复的子集，所以需要去重，基本思路是排序+筛选，当横向遍历的不是当前层的第一个元素时就需要筛选
  ]]></content></entry><entry><title>78.子集</title><url>/post/78.%E5%AD%90%E9%9B%86/</url><categories><category>leetcode</category></categories><tags><tag>回溯法</tag></tags><content type="html"><![CDATA[   78.子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例: 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]
思路基本想法使用回溯法，将子集的搜索过程分成横向搜索和纵向搜索
横向搜索每次拿nums中的一个元素x去组成子集、
纵向搜索每次从x开始向后开始求出不同的组合，具体的搜索过程形成了一个树的结构
执行流程回溯的地方有两处，第一处在从x出发递归到触发结束条件时，第二处在for循环结束时
以上图举例就是得到子集[1,2,3]之后，触发递归返回条件，此时回溯将pop_back(3)，下标为2
回到for循环之内时，发现访问到了元素3（下标为2），是nums的最后一个元素，此时触发for循环退出条件（++i==nums.size()），i本身为2，本层递归结束
回到了[1,2]这一层，执行pop_back(2)，下标为1，继续for循环，不满足for循环退出条件
执行两次回溯之后，子集中的元素变成了[1]，此时横向遍历，取出元素3，形成[1,3]，之后再次触发两次回溯
一次递归扫描到了nums的末尾，一次for循环扫描到了nums的末尾，此时子集中为[null]，横向遍历选择[2]。。。
区别
触发递归返回条件之后，先回到上层再pop_back()，之后进行for循环，可能触发for循环结束条件，此时是本层程序走到末尾返回，回到上层pop_back()之后，继续for循环。。。
代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: //全局变量存放结果和子集 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { backtrack(nums,0); return res; } void backtrack(vector&lt;int&gt;&amp; nums,int index){ res.push_back(path);//进入当前递归就保存一次结果 if(index==nums.size()){ return; } //进入横向搜索 for(int i=index;i&lt;nums.size();++i){ //没有重复元素，不需要判断是否遍历到了重复元素 path.push_back(nums[i]); //纵向遍历 backtrack(nums,i+1); //遇到递归结束或者for循环结束返回上层 path.pop_back(); } } }; 总结明确代码执行的流程，何时返回，以及搜索形成的集合什么时候加入结果集。
  ]]></content></entry><entry><title>Typora PicGo GitHub无痛使用</title><url>/post/typora-picgo-github%E6%97%A0%E7%97%9B%E4%BD%BF%E7%94%A8/</url><categories><category>教程</category></categories><tags><tag>图床配置</tag></tags><content type="html"> Typora-PicGo-GitHub无痛使用
PicGo
: 一个用于快速上传图片并获取图片 URL 链接的工具
使用PicGo解决了Typora书写md文档时插入本地图片之后，部署到GitHub中图片无法显示的问题
安装PicGo
在GitHub仓库中进行安装，
安装链接点这里
，其中选择2.3.1稳定版
安装完成之后，打开PicGo
配置GitHub
创建仓库
设置仓库名，选公开
设置token
找到头像，点击settings，之后翻到最下面，找到Developer settings
选择classic的Tokens，然后创建，我选择永不到期，记住这个tokens
配置PicGo
图床设置
设置图床时，主要是分支的问题，查看自己图床仓库的分支是什么就填什么
我的是master，所以我填master
之后就是token，填写刚才生成的token
最后是设置自定义域名，我的设置为：
1 2 https://cdn.jsdelivr.net/gh/zzziCode/PicGoImg@master //将gh之后的部分改成自己的仓库名和分支即可 PicGo设置
主要是设置快捷键，触发快捷键会将剪切板中的最新图像上传到图床中
之后的配置按需求配置
此时PicGo与GitHub的配置基本结束，如果出现上传失败的情况，可以修改hosts文件
打开之后在最后加上，保存即可
如果出现保存失败，将hosts中所有数据复制一份，存储到其他路径下的hosts文件中，覆盖当前目录下的hosts即可
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 140.82.113.3 github.com 140.82.114.20 gist.github.com 151.101.184.133 assets-cdn.github.com 151.101.184.133 raw.githubusercontent.com 151.101.184.133 gist.githubusercontent.com 151.101.184.133 cloud.githubusercontent.com 151.101.184.133 camo.githubusercontent.com 151.101.184.133 …</content></entry><entry><title>不从零开始搭建博客</title><url>/post/%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</url><categories><category>教程</category></categories><tags><tag>搭博客</tag></tags><content type="html"><![CDATA[   不从零开始搭建自己的博客
重点是本地博客与GitHub进行连接，主要逻辑是cloneGitHub仓库中的博客源码，然后进行自己的配置，并且明白本地书写博客与发布博客的步骤，最后执行脚本发布即可
博客搭建步骤本地搭建前面需要安装Git，nodejs
并且node配置node_global以及node_cache文件夹时，不可以将这两个文件夹存放在nodejs的安装目录下
安装hugo注意需要下载的是extended版本，下载完成之后将压缩包解压到含有bin目录的空文件夹下
安装go需要配置环境变量
此时基本环境安装完毕，进入hugo博客项目的创建
创建博客项目准备选择一个空文件夹存放博客，我选择Bolg，此时Bolg文件夹下为空
创建存放博客的仓库
后面的GitHub Pages不用管，只需要创建空仓库，此时会得到一个仓库地址，类似于：
1 https://github.com/zzziCode/zzziCode.github.io 准备工作到此完成
clone博客文件进入GitHub项目，点击Code，复制地址
在Bolg文件夹下右键，选择Git Bash Here,出现Git命令窗口
之后输入：
1 $ git clone https://github.com/zzziCode/myblog.git 博客项目clone完毕
出现错误，如果是第一次连接仓库，需要在Git Bash窗口中执行以下命令：
1 2 3 4 5 6 7 8 1. git init 2. git config --global user.name &amp;#34; GitHub 用户名 &amp;#34; 例如：git config --global user.name &amp;#34;zzziCode&amp;#34; 3. git config --global user.email &amp;#34;github用户的邮箱&amp;#34; 例如：git config --global user.email &amp;#34;1980136696@qq.com&amp;#34; 4. git remote add origin &amp;#34;GitHub仓库地址，也就是刚才创建的新仓库地址&amp;#34; 例如：git remote add origin …  ]]></content></entry><entry><title>站点示例</title><url>/flinks.html</url><categories/><tags/><content type="html"> 如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
1 2 3 4 - name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org</content></entry></search>