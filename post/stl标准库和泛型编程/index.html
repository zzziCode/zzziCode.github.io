<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.111.3"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon_next.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon_next.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon_next.png><meta itemprop=name content="STL标准库和泛型编程"><meta itemprop=description content="STL标准库和泛型编程"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://zzzicode.github.io/imgs/avatar.png"><meta itemprop=keywords content="STL,泛型编程"><meta property="og:type" content="article"><meta property="og:title" content="STL标准库和泛型编程"><meta property="og:description" content="STL标准库和泛型编程"><meta property="og:image" content="/imgs/avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://zzzicode.github.io/post/stl%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="zzzi的小站"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="zzzi"><meta property="article:published_time" content="2023-05-31 18:07:27 +0800 CST"><meta property="article:modified_time" content="2023-05-31 18:07:27 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4b7f3d9c4ef8db1505229a7dcd2c4e3ab17cd4960dd8a78b503c013770ad56a6.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"stl%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B","permalink":"https://zzzicode.github.io/post/stl%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/","title":"STL标准库和泛型编程"}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>STL标准库和泛型编程 - zzzi的小站</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>zzzi的小站</h1><i class=logo-line></i></a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>217</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#第一部分>第一部分</a><ul><li><a href=#容器测试>容器测试</a><ul><li><a href=#vector>vector</a></li><li><a href=#list>list</a></li><li><a href=#forward_list>forward_list</a></li><li><a href=#deque>deque</a></li><li><a href=#multi_set>multi_set</a></li><li><a href=#multi_map>multi_map</a></li><li><a href=#unordered_multiset>unordered_multiset</a></li><li><a href=#unordered_multimap>unordered_multimap</a></li><li><a href=#set>set</a></li><li><a href=#map>map</a></li><li><a href=#unordered_set>unordered_set</a></li><li><a href=#unordered_map>unordered_map</a></li></ul></li><li><a href=#分配器测试>分配器测试</a></li></ul></li><li><a href=#第二部分>第二部分</a><ul><li><a href=#泛型编程>泛型编程</a></li><li><a href=#分配器>分配器</a><ul><li><a href=#malloc的缺点>malloc的缺点</a></li></ul></li><li><a href=#容器之间的关系>容器之间的关系</a></li><li><a href=#容器适配器>容器适配器</a></li><li><a href=#list深度探索>List深度探索</a></li><li><a href=#vector深度探索>vector深度探索</a><ul><li><a href=#基本属性>基本属性</a></li><li><a href=#动态增长>动态增长</a></li></ul></li><li><a href=#array深度探索>array深度探索</a></li><li><a href=#deque深度探索>deque深度探索</a></li><li><a href=#rbtree深度探索>RBTree深度探索</a><ul><li><a href=#红黑树的底层原理>红黑树的底层原理</a></li></ul></li><li><a href=#set深度探索>set深度探索</a></li><li><a href=#map深度探索>map深度探索</a></li><li><a href=#set和map都可以使用rb-tree的原因>set和map都可以使用RB-tree的原因</a></li><li><a href=#hashtable深度探索>hashtable深度探索</a></li></ul></li><li><a href=#第三部分>第三部分</a><ul><li><a href=#迭代器的分类>迭代器的分类</a></li><li><a href=#迭代器适配器>迭代器适配器</a></li><li><a href=#各种算法>各种算法</a><ul><li><a href=#count>count</a></li><li><a href=#sort>sort</a></li><li><a href=#find>find</a></li></ul></li><li><a href=#仿函数>仿函数</a></li><li><a href=#仿函数适配器>仿函数适配器</a></li><li><a href=#适配器>适配器</a><ul><li><a href=#仿函数适配器-1>仿函数适配器</a></li><li><a href=#容器适配器-1>容器适配器</a></li><li><a href=#迭代器适配器-1>迭代器适配器</a></li></ul></li></ul></li><li><a href=#第四部分>第四部分</a><ul><li><a href=#哈希函数>哈希函数</a><ul><li><a href=#变长参数>变长参数</a></li></ul></li><li><a href=#tuple>Tuple</a><ul><li><a href=#变长参数-1>变长参数</a></li></ul></li><li><a href=#type-traits>type traits</a><ul><li><a href=#使用>使用</a></li><li><a href=#实现>实现</a></li></ul></li><li><a href=#iterator包含的五个typedef>iterator包含的五个typedef</a></li><li><a href=#补充萃取器-iterator-traits>补充萃取器 Iterator Traits</a></li><li><a href=#补充重载运算符>补充重载运算符</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=zzzi src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.png><p class=site-author-name itemprop=name>zzzi</p><div class=site-description itemprop=description>make_tuple("工作","论文")</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>217</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>5</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>46</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/zzziCode title="Github → https://github.com/zzziCode" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://zzzicode.github.io/post/stl%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.png"><meta itemprop=name content="zzzi"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="zzzi"><meta itemprop=description content="make_tuple(&#34;工作&#34;,&#34;论文&#34;)"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="STL标准库和泛型编程"><meta itemprop=description content="STL标准库和泛型编程"></span><header class=post-header><h1 class=post-title itemprop="name headline">STL标准库和泛型编程</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text title=发表于>发表于：</span>
<time title="创建时间：2023-05-31 18:07:27 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-05-31 18:07:27 +0800 CST">2023-05-31</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text title=分类于>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0 itemprop=url rel=index><span itemprop=name>学习笔记</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span>
<span>18549</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>38分钟</span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><blockquote><p>😶STL标准库和泛型编程</p></blockquote><p>STL标准库和泛型编程的学习笔记，记录了STL中六大部件之间的关系和部件的实现细节，以及泛型编程的相关知识，逻辑稍微有点乱，后期再修改</p><h2 id=引言>引言
<a class=header-anchor href=#%e5%bc%95%e8%a8%80></a></h2><p>STL六大部件分别是：容器、算法、迭代器、仿函数、适配器、分配器</p><p>其中容器、算法、迭代器是最基本的，迭代器是算法和容器之间的桥梁</p><p>仿函数就是一个重载了()的类，使用该类生成的对象调用()方法，看起来就像函数调用，所以称为仿函数，仿函数主要与算法配合使用，作为参数传递，解锁算法高级用法</p><p>适配器可以作用在容器上，改造容器形成容器适配器。作用在仿函数上就形成了仿函数适配器，但是这个放仿函数必须
<a href=https://blog.csdn.net/zishuijing_dd/article/details/109299497 title=继承 rel="noopener external nofollow noreferrer" target=_blank class=exturl>继承
<i class="fa fa-external-link-alt"></i>
</a>一元或者二元谓词。作用在迭代器上就形成了迭代器适配器</p><p>适配器的作用就是对STL的基础部件进行改造，使其更加符合自己的需求</p><p>最后的分配器就是服务于容器，每个容器底层的内存分配就是分配器负责</p><p>六大部件具体的关系如下：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306121237943.png alt=在这里插入图片描述 style=zoom:75%><h2 id=第一部分>第一部分
<a class=header-anchor href=#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86></a></h2><p>相当于一个基本的介绍，介绍容器的使用</p><h3 id=容器测试>容器测试
<a class=header-anchor href=#%e5%ae%b9%e5%99%a8%e6%b5%8b%e8%af%95></a></h3><p><strong>总结</strong>：在泛型编程中，支持随机访问的容器不需要自定义sort，但是STL中的sort需要容器支持随机访问，所以不支持随机访问的迭代器需要自定义sort</p><h4 id=vector>vector
<a class=header-anchor href=#vector></a></h4><p>vector<strong>自身不存在</strong>sort函数， 需要使用c标准库中的qsort</p><p>因为vector可以随机访问，所以根据泛型编程的思想，需要将算法分离来，</p><p>也就是自身不存在sort</p><p>并且vector扩充空间时扩充的很多，如果没有用到就会造成内存浪费</p><h4 id=list>list
<a class=header-anchor href=#list></a></h4><p>list是一个双向链表，头部和尾部都可以操作，扩充内存时是<strong>一个一个</strong>扩充，使用指针进行连接</p><p>并且list容器<strong>自带</strong>sort函数</p><p>因为list不支持随机访问，所以无法使用STL中的sort，所以需要单独定义sort排序算法</p><h4 id=forward_list>forward_list
<a class=header-anchor href=#forward_list></a></h4><p>前向链表只可以在头部进行操作，并且没有size函数，只有max_size函数</p><p>容器<strong>自带</strong>sort函数</p><h4 id=deque>deque
<a class=header-anchor href=#deque></a></h4><p>双端队列可以在两端进行操作，相当于连续版的双向链表，并且扩充内存时是<strong>一块一块</strong>扩充，也就是外部看起来像是连续空间，但是内部并不是连续的，而是多个连续的小内存块组成deque的空间</p><p>容器<strong>自身不带s</strong>ort函数</p><h5 id=stack>stack
<a class=header-anchor href=#stack></a></h5><p>stack默认是将deque进行改造形成的容器适配器，但是也可以指定使用其他容器改造</p><p>可以实现后进先出操作，具体的改造就是封闭push_front和pop_front函数，使其只能在deque尾部操作，实现后进先出的效果</p><p>底层并没有自己的数据结构实现，而是借用了其他的容器，所以称为容器适配器</p><p>不支持随机访问，没有迭代器</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span>stack<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> s1;<span style=color:#75715e>//默认底层使用deque实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>stack<span style=color:#f92672>&lt;</span>string, list<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> s2;<span style=color:#75715e>//底层指定使用list实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>stack<span style=color:#f92672>&lt;</span>string, vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> s3;<span style=color:#75715e>//底层指定使用vector实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>stack<span style=color:#f92672>&lt;</span>string, set<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> s4;<span style=color:#75715e>//底层指定使用set实现
</span></span></span></code></pre></td></tr></table></div></div><h5 id=queue>queue
<a class=header-anchor href=#queue></a></h5><p>queue底层默认使用deque进行改造，但是也可以指定其他的容器进行改造</p><p>改造之后实现了容器的先进先出，也就是头部只可以出队，尾部只可以入队</p><p>底层并没有自己的数据结构实现，而是借用了其他的容器，所以称为容器适配器</p><p>不支持随机访问，没有迭代器</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span>queue<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> q1;<span style=color:#75715e>//默认底层使用deque实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>queue<span style=color:#f92672>&lt;</span>string, list<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> s2;<span style=color:#75715e>//底层指定使用list实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>queue<span style=color:#f92672>&lt;</span>string, vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> s3;<span style=color:#75715e>//底层指定使用vector实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>queue<span style=color:#f92672>&lt;</span>string, set<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> s4;<span style=color:#75715e>//底层指定使用set实现
</span></span></span></code></pre></td></tr></table></div></div><h4 id=multi_set>multi_set
<a class=header-anchor href=#multi_set></a></h4><p>关联式容器，底层使用红黑树实现，并且可以存放相同的元素，元素存入时会进行排序</p><p>插入元素不使用push，而是使用insert，插入元素时会找到元素对应的位置，使其有序</p><p>顺序容器和关联容器区别就是在插入和查找上，顺序容器的插入相对很快，查找相对很慢</p><p>关联容器的插入相对很慢，但是查找相对很快</p><h4 id=multi_map>multi_map
<a class=header-anchor href=#multi_map></a></h4><p>关联式容器map，容器中的元素是一个对组pair，键值对，multi_map的key可以重复，但是map的key不允许重复</p><p>插入时，multi_map不允许使用重载运算符[]进行插入，因为根据一个key可能找到多个对组，不知道对那个对组进行操作，会造成歧义，但是map就可以使用[]</p><h4 id=unordered_multiset>unordered_multiset
<a class=header-anchor href=#unordered_multiset></a></h4><p>使用哈希表做实现，元素无序</p><p>哈希表使用链地址法解决冲突</p><h4 id=unordered_multimap>unordered_multimap
<a class=header-anchor href=#unordered_multimap></a></h4><p>就是存储一些无序的key_value对组，并且使用<strong>哈希表</strong>进行管理</p><p>插入时需要注意的与multimap一样，不可以使用重载运算符[]操作元素，因为multimap可以允许重复的key，所以使用[]可能找到多个对组，会出现歧义</p><h4 id=set>set
<a class=header-anchor href=#set></a></h4><p>重复的元素无法插入，自带find函数</p><h4 id=map>map
<a class=header-anchor href=#map></a></h4><p>重复的key所对应的对组无法插入，并且可以使用重载运算符[]操作对组，因为重复的key无法插入</p><p>所以使用[]操作对组是唯一的，不会产生歧义，但是如果map中不存在以key为键的对组，就会创建一个新的对组，例如：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>string, string<span style=color:#f92672>&gt;</span> m1;
</span></span><span style=display:flex><span><span style=color:#75715e>//  修改关键码为LiXing的值
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  注意，这里的关键码在map里面并不存在，所以会创建一个新的对组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (m1[<span style=color:#e6db74>&#34; LiXing &#34;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34; 13913131313 &#34;</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    m1[<span style=color:#e6db74>&#34; LiXing &#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; 13513131313 &#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//  输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; The cellhone number of LiXing is:  &#34;</span> <span style=color:#f92672>&lt;&lt;</span> m1[<span style=color:#e6db74>&#34; LiXing &#34;</span>] <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span></code></pre></td></tr></table></div></div><p>由于不存在以Lixing为key的对组，所以会创建一个对组</p><p>新的对组<code>key="Lixing"</code>，<code>value=""</code>，因为string的默认值为""</p><h4 id=unordered_set>unordered_set
<a class=header-anchor href=#unordered_set></a></h4><p>不可以存放相同的元素，元素不有序</p><h4 id=unordered_map>unordered_map
<a class=header-anchor href=#unordered_map></a></h4><p>不可以存放相同的元素，元素不有序</p><h3 id=分配器测试>分配器测试
<a class=header-anchor href=#%e5%88%86%e9%85%8d%e5%99%a8%e6%b5%8b%e8%af%95></a></h3><p>容器的背后需要分配器（allocator）的支持来实现内存的使用</p><p>分配器在定义容器时，第二个参数就可以指定分配器</p><p>每一次push_back都会使用分配器</p><p>分配器也可以单独使用，不搭配容器</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p;
</span></span><span style=display:flex><span>allocator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> alloc1;
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> alloc1.allocate(<span style=color:#ae81ff>1</span>);<span style=color:#75715e>//分配空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>alloc1.deallocate(p, <span style=color:#ae81ff>1</span>);<span style=color:#75715e>//归还空间，并且需要记住归还几个单元
</span></span></span></code></pre></td></tr></table></div></div><p>分配器分配一个单元，那么最后归还就需要归还一个单元</p><p>相比于new搭配delete，malloc搭配free来说，分配器单独使用并不好用</p><h2 id=第二部分>第二部分
<a class=header-anchor href=#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86></a></h2><p>相当与更加详细的介绍，介绍容器底层的实现，迭代器是如何工作，以及适配器是如何工作</p><p>每个容器都有自己的迭代器，但是由于性质不同，所以迭代器的操作也不同，这也造成了迭代器的定义不同，但是都有五个属性，有萃取器提供这五个属性，有了迭代器和容器以及适配器，就可以对容器和适配器操作了，具体的操作称为函数，在第三部分</p><p>所有的容器都有一个迭代器，迭代器返回容器的五个属性，算法获取这五个属性操作容器，对于迭代器来说，分为类类型的迭代器和指针类型的迭代器，为了返回五个属性，同时兼容指针迭代器的情况，提供了一个萃取器，不论迭代器是什么类型，都可以返回五个属性</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202305261510972.png alt=image-20230526151026897 style=zoom:67%><h3 id=泛型编程>泛型编程
<a class=header-anchor href=#%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b></a></h3><p>泛型编程与面对对象编程的区别：</p><p><strong>泛型编程</strong>将对象与算法分离开，对于容器来说，也就是将容器与算法分离开，中间使用迭代器联系</p><p>这样可以减少代码量，一次定义多次使用，如果将算法全部定义到容器内部时，容器的代码就会变得很庞大，并且冗余度很高，部分容器中的算法完全一样，所以没必要重复编写，这也是算法和容器分开的一个原因</p><p><strong>面对对象编程</strong>变成是将对象与算法全部封装到类内</p><p><strong>函数模板</strong>调用时可以不指定类型，编译器自动推导，也可以使用显式指定</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span><span style=color:#75715e>//告诉编译器T是一个通用的数据类型，
</span></span></span><span style=display:flex><span><span style=color:#75715e>//使用通用数据类型创建交换函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Myswap(T<span style=color:#f92672>&amp;</span> a, T<span style=color:#f92672>&amp;</span> b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	T temp <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>	a <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>	b <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;c&#39;</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>//利用函数模板交换数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//第一种方式：自动推导
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	Myswap(a, b);<span style=color:#75715e>//自动推导时，T推导的参数必须一致才可以使用函数模板
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;b=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> b <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span><span style=color:#75715e>//第二种方式：显示指定类型，告诉编译器传入的数据是什么类型,这个时候相当于一个普通函数，可以发生隐式类型转换
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	Myswap<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(a, c);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;b=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> b <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><strong>类模板</strong>调用<strong>必须</strong>指定类型，类模板主要是类中的成员使用模板</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NameType</span>,<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AgeType</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	NameType Name;
</span></span><span style=display:flex><span>	AgeType Age;
</span></span><span style=display:flex><span>	Person(NameType name,AgeType age)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Name <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Age <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Show</span>()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;name:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Name <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;age:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Age <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test1</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>//使用书写的类模板创建类对象，必须指定类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	Person<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p1(<span style=color:#e6db74>&#34;张三&#34;</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>	Person<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p2(<span style=color:#e6db74>&#34;李四&#34;</span>, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>	p1.Show();
</span></span><span style=display:flex><span>	p2.Show();
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>类模板的泛化和特化：</p><p>也就是将模板参数进行指定，全部指定叫做全特化，部分指定叫做偏特化</p><h3 id=分配器>分配器
<a class=header-anchor href=#%e5%88%86%e9%85%8d%e5%99%a8></a></h3><h4 id=malloc的缺点>malloc的缺点
<a class=header-anchor href=#malloc%e7%9a%84%e7%bc%ba%e7%82%b9></a></h4><p>malloc要求分配内存的大小是<strong>size</strong>，但是malloc不仅分配了size大小的内存块，前后还有各种调试信息，填充和cookie，增加了内存开销，也就是说，每一次malloc，都会额外使用这些内存存储不想要的信息</p><p>如果想要的空间很少，那么无用的信息所占空间比例就会很大，相当于无用开销很多</p><p>对于分配器分配内存来说，最终到了底层都会调用new，new内部调用malloc</p><p>对于分配器回收内存来说，最终到了底层都会调用delete，delete内部调用free</p><p>没有任何新东西，底层就是调用c的函数对内存进行操作</p><p>后期使用的分配器不再直接调用malloc，新的分配器叫做<strong>alloc</strong>，这样的好处是减少了malloc的调用，也就是减少了无用空间的开销，一个节点中的内存块是一次malloc得来的，无用信息占用的内存就会变少</p><p>链表中的节点使用malloc一次分配，所以携带的cookie很少，不像是每次都是用malloc，然后每次申请的内存都携带cookie，浪费很多内存</p><p>先在这16个节点的链表中找到内存块，每一个链表节点负责的内存块大小不一样，0号节点负责八字节的内存块，一号节点负责16字节的内存块，15号节点负责128字节的内存块</p><p>如果这个链表中没有想要的内存块，此时再去malloc</p><p>后期新版本也不再使用这种版本，这种版本变成了扩充的分配器，可以在使用容器中<strong>指定分配器</strong>的版本</p><h3 id=容器之间的关系>容器之间的关系
<a class=header-anchor href=#%e5%ae%b9%e5%99%a8%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb></a></h3><p>缩进关系表示衍生的关系，例如<code>stack</code>和<code>queue</code>底层使用<code>deu qe</code>实现</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202305241103426.png alt=image-20230524110330304 style=zoom:67%><h3 id=容器适配器>容器适配器
<a class=header-anchor href=#%e5%ae%b9%e5%99%a8%e9%80%82%e9%85%8d%e5%99%a8></a></h3><p>适配器作用在容器中形成了不同的容器适配器，例如：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011322353.png alt=image-20230531170251172 style=zoom:50%><h3 id=list深度探索>List深度探索
<a class=header-anchor href=#list%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2></a></h3><p><code>STL</code>中的<code>list</code>是一个双向链表，在尾部添加了一个<strong>空白节点</strong>，这样就能符合<code>end()</code>指向空的特点，分配内存时，不止分配自身元素所占的内存，还会分配指针域的内存</p><p>链表内部使用的迭代器是经过 <code>typedef</code>的，主要有iterator，const_iterator，const_reverse_iterator，reverse_iterator，不同的迭代器有不同用法，迭代器的实现在容器的内部</p><p>list的定义如下:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> _Tp, <span style=color:#66d9ef>typename</span> _Alloc <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>allocator<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>list</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>protected</span> _List_base<span style=color:#f92672>&lt;</span>_Tp, _Alloc<span style=color:#f92672>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>使用了函数模板，所以使用list时必须指定类型，不能自动推导，并且list的迭代器<code>iterator</code>是一个类</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> _List_iterator<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span>			 iterator;
</span></span></code></pre></td></tr></table></div></div><p>传递进来的_Tp会用来命名三个参数，为了模拟指针的行为，内部实现了大量的运算符重载，运算符重载时是对里面的node指针进行操作，但是返回值是整个iterator</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>typedef _Tp				value_type;
</span></span><span style=display:flex><span>typedef _Tp*				pointer;
</span></span><span style=display:flex><span>typedef _Tp&amp;				reference;
</span></span></code></pre></td></tr></table></div></div><h3 id=vector深度探索>vector深度探索
<a class=header-anchor href=#vector%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2></a></h3><p>vector可以理解为一个动态扩充内存的数组，正常的数组定义完成之后无法扩充内存，因为他是连续空间，无法知道数组最后的空间是否被使用</p><p>vector之所以可以动态扩充是因为它可以重新申请一块连续的内存空间，新空间的大小是原空间的两倍，也就是二倍增长</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202305261311423.png alt=image-20230526131154331 style=zoom:50%><h4 id=基本属性>基本属性
<a class=header-anchor href=#%e5%9f%ba%e6%9c%ac%e5%b1%9e%e6%80%a7></a></h4><p>size是vector中实际元素的个数，capacity是vector的最大容量</p><p>使用三个迭代器就可以得到容器的各种属性</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>iterator start//容器第一个元素的位置
</span></span><span style=display:flex><span>iterator finish//容器最后一个元素的下一的位置
</span></span><span style=display:flex><span>iterator end_of_storage//容器所占空间的最后一个位置
</span></span></code></pre></td></tr></table></div></div><p>size属性可以通过finish-start获得</p><p>capacity属性可以通过end_of_storage-start获得</p><p>empty属性可以通过finish==start获得</p><p>[n]运算符重载可以通过start+n获得</p><p>front可以通过start获得</p><p>back可以通过finish-1获得</p><p>。。。。</p><h4 id=动态增长>动态增长
<a class=header-anchor href=#%e5%8a%a8%e6%80%81%e5%a2%9e%e9%95%bf></a></h4><p>插入元素时判断vector是否有剩余空间，如果没有的话就调用扩充空间的函数进行动态增长，</p><p>扩充空间的函数首先需要判断是否还有剩余空间，没有备用空间就会进行增长</p><p>增长时如果容器一个元素都没有，就先扩充成一个元素的空间大小，如果有空间，那么就扩充成原来的两倍，计算出需要扩充空间的大小之后，就可以使用分配器分配内存，之后将原有元素移动过来，形成新的vector</p><p>扩充的过程中，会调用拷贝构造函数复制原来的元素到新的内存中，并且原有空间的元素需要调用析构函数删除</p><p>获取五个属性使用迭代器，迭代器又实用萃取器判断迭代器的类型是类还是指针，从而间接获得五个属性</p><h3 id=array深度探索>array深度探索
<a class=header-anchor href=#array%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2></a></h3><p>容器在初始化时必须指定大小，因为他无法扩充内存，其余实现与上面类似，使用萃取器得到五个属性，返回给迭代器，外部使用迭代器就可以访问五个属性</p><h3 id=deque深度探索>deque深度探索
<a class=header-anchor href=#deque%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2></a></h3><p>deque对外号称连续，其实内部是分段连续的，使用vector存储每一段的指针，扩充内存时，前面不够就在前面申请一块新的连续空间，并将指向这块内存的指针加入中控器，后面不够就在后面申请一块连续的空间，并将指向这块内存的指针加入中控器,具体的中控器是由map实现的，每一个map中的节点指向一块缓存区，也就是一块连续空间</p><p>其中开始和结束迭代器有九个属性，五个是最开始介绍的其余容器也有的五个，剩下四个分别是cur、first、last、node。node指向存放所有分段的vector，node移动说明访问的分段不同，而first和last指向node所指分段的开始和接触，cur指向当前的元素</p><p>分段中的每一段称为一个缓冲区，那么deque是如何将这些分段的缓冲区联系起来，让人以为他是连续的呢</p><p>将node进行移动，就可以在不同的分段之间移动</p><p>主要是元素的移动，cur移动一次，看是不是到了当前分段的末尾，是的话就将node移动一次，切换到下一分段，之后让cur指向下一分段的first，就可以实现连续的访问，其余的访问逻辑相似，实际上是在分段的连续空间中移动</p><p>以自增和自减为例，可以清楚的看到迭代器的移动</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202305261632364.png alt=image-20230526163238262 style=zoom:67%><p>将分段连续的空间变得看起来一致连续，主要是node的移动和cur的移动在起作用</p><blockquote><p>stack和queue底层的实现都是deque，只不过对于deque做了一定限制</p></blockquote><p>所以stack和queue底层也是分段连续，只不过 node和cur的巧妙移动，使得外部看起来像是一致连续的</p><p>stack和queue的操作函数就是简单的调用deque的操作函数，并且对于deque的某些操作函数封闭，例如stack只能push_back和pop_back，queue只能push_back和pop_front</p><p>对deque进行限制就是对他的迭代器进行了限制，进行限制之后形成的东西称为容器适配器，satck和queue就是容器适配器</p><p>需要注意的是，stack和queue都不支持遍历，所以没有提供迭代器，或者说deque的迭代器他们无法使用，这是他们的数据结构特性决定的</p><h3 id=rbtree深度探索>RBTree深度探索
<a class=header-anchor href=#rbtree%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2></a></h3><h4 id=红黑树的底层原理>红黑树的底层原理
<a class=header-anchor href=#%e7%ba%a2%e9%bb%91%e6%a0%91%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86></a></h4><p>红黑树可以看作是一个平衡二叉树，但是他不是用平衡因子衡量此树是否平衡，而是使用黑色节点的数量，从任意节点出发，到达任意叶子节点的路径上，黑色节点的数量都是一样的，这是最主要的平衡性质，其余的几条性质加起来一起约束，形成了红黑树</p><p>把红黑树中所有的红色节点删除之后，剩下的黑色节点形成了一个满二叉树，是平衡的</p><p>红黑树就是一个高度平衡的二叉树，并且提供迭代器进行中序遍历，红黑树不应该修改节点的值， 否则会破坏红黑树的结构，但是在编程层面是可以修改的，因为红黑树是给set和map提供服务的，所以应该提供修改的服务</p><p>红黑树在插入时提供两种版本，第一种是不允许重复，对应set和map，第二种是允许重复，对应multiset和multimap</p><p>使用红黑树的迭代器访问得到的序列是一个有序序列，也就是说迭代器的访问是中序遍历</p><p>当map使用红黑树实现时，使用key创建红黑树，并且key不能被修改，而value由key链接，value可以修改，相当于使用key当作节点的身份，节点内部是value</p><p>红黑树在STL中就是一个容器，但是STL中并没有提供使用方法，红黑树创建来是给关联式容器使用的，他们的底层实现就是红黑树</p><p>相当于queue、stack和deque的关系，queue、stack底层实现就是deque，只不过对deque进行了一定的修改</p><p>map和set底层实现是红黑树，也对其做了一定修改，使其符合自己的需求</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202305281515308.png alt=image-20230528151540239></p><p>红黑树有五个属性，第一个属性是key，第二个属性是value，是key和data合成在一起形成的树，第三个属性是keyofvalue，告诉用户如何从value中取出data，之后是一个比较函数</p><p>有了这些属性才能更好的操作红黑树</p><h3 id=set深度探索>set深度探索
<a class=header-anchor href=#set%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2></a></h3><p>set底层就是使用了红黑树，如果使用insert_unique插入元素，形成的就是set，如果使用insert_equal插入元素，那么形成的就是multiset，也就是从是否可以存储相同元素区分</p><p>对于set来说，不允许更改元素，因为set只存储一个元素，相当于key就是value，那么在底层红黑树中如何限制set不能修改呢：要修改肯定需要拿到set的迭代器，红黑树提供给set的红黑树是一个const类型，所以不允许修改，这样限制之后就符合规定了</p><p>相当于红黑树套壳，set的操作底层全都调用了红黑树的操作</p><p>类似于queue和stack一样，所以set也可以理解为一个容器适配器</p><p>对于set来说，key和vaue一样，因为他没有data，所以<strong>key直接形成了value</strong>，keyofvalue告诉用户，直接将key拿到就是对应的data</p><p>由于红黑树插入元素时会将元素排序，所以set中的元素也是有序的</p><h3 id=map深度探索>map深度探索
<a class=header-anchor href=#map%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2></a></h3><p>map底层也使用了红黑树 ，所以插入元素时也是默认有序的，并且map有两个元素，其中key无法修改，允许修改data，那么是如何做到的呢</p><p>并且map中的key不允许重复，data允许重复</p><p>multimap中key和data都允许重复，这些是如何做到的</p><p>首先。定义map时会指定key和data的类型，底层红黑树为了实现map，将map的key作为自己的key，然后将ket和data组合在一起形成一个对组，之后作为自己的value，然后告诉用户，如何取出map的key和data，取出的第一个元素是key，返回的迭代器是一个const类型，取出的第二个元素是data，返回的是普通的迭代器，也就是说可以修改</p><p>红黑树将map的key和data组合在一起形成一个对组，取key时返回的迭代器为const，取value时返回的迭代器是一个普通类型</p><p>插入时map需要把元素包装成一个对组传毒给红黑树，红黑树将其存放在value中</p><p>由于map不允许key重复，所以允许进行下标访问，和数组一样</p><p>而multimap允许key重复，所以不能使用下标访问，不然就会造成冲突</p><blockquote><p>value是key和data的融合，map知道如何将value中的data取出来</p></blockquote><p>map<strong>插入</strong>时的返回值是一个pair，<code>pair.first</code>返回map的迭代器，<code>pair.second</code>返回插入的状态，代表是否插入成功：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>auto</span> ret<span style=color:#f92672>=</span>map.insert(make_pair(<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#34;张三&#34;</span>));
</span></span><span style=display:flex><span><span style=color:#75715e>//等价于
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>pair<span style=color:#f92672>&lt;</span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,string<span style=color:#f92672>&gt;::</span>iterator,<span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> ret<span style=color:#f92672>=</span>map.insert(make_pair(<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#34;张三&#34;</span>));
</span></span></code></pre></td></tr></table></div></div><p>从代码中可以清晰的知道返回值是一个<code>pair</code>，并且<code>first</code>和<code>second</code>的值也很清楚</p><p>map使用下标运算符时，当元素不存在时会自动添加，所以只想查找不想添加时，就不能使用下标运算符，而是使用find函数</p><h3 id=set和map都可以使用rb-tree的原因>set和map都可以使用RB-tree的原因
<a class=header-anchor href=#set%e5%92%8cmap%e9%83%bd%e5%8f%af%e4%bb%a5%e4%bd%bf%e7%94%a8rb-tree%e7%9a%84%e5%8e%9f%e5%9b%a0></a></h3><p>set是一个单key的容器，map是key-value形式的容器，他们为什么可以使用同一个RB-tree呢</p><p>在set和map的源码中，set将key重复了两次传递给RB-tree分别作为key_type和value_type，map将key传递给RB-tree作为key_type，然后将队组pair作为value_type传递给RB-tree，具体看图：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306201443378.png alt=img></p><blockquote><p>RB-tree插入时，不管是单独的一个元素，还是一个复合的对组，<strong>都</strong>当做一个<code>value_type</code>处理</p></blockquote><p>所以set和map都可以将RB-tree当成自己的底层容器</p><p>map的源码</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306201458862.png alt=image-20230620145843789 style=zoom:50%><p>set的源码</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306201500550.png alt=image-20230620150036436 style=zoom:50%><h3 id=hashtable深度探索>hashtable深度探索
<a class=header-anchor href=#hashtable%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2></a></h3><p>c++中 哈希表存入元素时，使用链地址法解决冲突，哈希表的好处就是可以利用闲散的空间</p><p>哈希表中有一个bucket的概念，也就是散列表的长度，当元素的个数超过了bucket的长度，系统就认为出现危险情况，此时就再哈希，扩大bucket的大小（每次扩到的容量都是一个质数，因为质数除了自己和1没有因子），所有的元素重新计算哈希地址</p><p>也就是说bucket的个数永远大于元素的个数</p><p>与红黑树一样，哈希表中存储的元素有一个key和value，value是由key和data组合而成的，所以还需要在提供方法告诉用户如何拿到哈希表中的key和data，之后还需要给定一个比较函数，有了key之后，如何比较是否匹配，才能找到key对应的位置，因为key可能不是系统内置的类型</p><p>使用哈希表定义之时指定的哈希函数确定元素放在哪个位置，</p><p>哈希表和红黑树，deque一样，更像红黑树，都是给其他容器提供底层操作，哈希表给无序容器unordered_set（multi）和unordered_map（multi）提供底层支持，而红黑树给关联容器map和set提供底层支持</p><p>unordered_set底层的操作全部是调用hashtable的操作，因为底层是使用hashtable实现的</p><h2 id=第三部分>第三部分
<a class=header-anchor href=#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86></a></h2><p>有了上面提到的容器、适配器以及操作他们的迭代器，第三部分就介绍使用迭代器进行花式操作容器以及适配器的方法，也就是建立在容器和适配器之上的算法</p><p>在语言的层面上，容器和适配器都是一个类模板，传入不同的参数实现不同数据的存储，而算法是一个函数模板，传入不同的容器和迭代器就对不同的容器进行处理</p><p>因为一个函数可以操作很多容器，所以传递的参数形式不同，但是定义一个函数模板，当传递不同的参数时，就会形成不同的特化版本，从而实现对容器的操作</p><p>并且有的算法还支持传入一个仿函数，这个仿函数就是重载了()运算符的类，比如排序算法需要比较大小，此时就可以传入一个仿函数作为排序算法的参数</p><p>而谓词就是返回值为bool类型的全局函数或者仿函数，所以这是他们的区别</p><p>算法看不到操作的容器，只能通过迭代器提供的权限去操作容器，也就是说，迭代器不同，所提供的权限也不同</p><h3 id=迭代器的分类>迭代器的分类
<a class=header-anchor href=#%e8%bf%ad%e4%bb%a3%e5%99%a8%e7%9a%84%e5%88%86%e7%b1%bb></a></h3><p>由萃取器得到迭代器的种类，从而知道可以使用迭代器进行什么样的操作</p><ol><li>输入迭代器</li><li>输出迭代器</li><li>前向迭代器</li><li>双向迭代器</li><li>随机访问迭代器</li></ol><p>分类对于算法的影响很大，比如随机访问的迭代器在查找时可以通过二分法（前提需要有序），而不支持随机访问的迭代器只能顺序查找，如果目标元素在末尾，就需要遍历整个容器</p><p>算法内部根据迭代器的种类决定调用哪种特化版本的算法</p><p>基本步骤就是调用萃取器获得当前传入的迭代器是什么种类，之后再调用另一个函数</p><p>举例：</p><p>distance计算迭代器之间的举例，distance内部先获得迭代器的分类，之后调用一个_distance函数，增加一个迭代器分类的参数，不同的分类调用不同的 _distance函数</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011322354.png alt=image-20230529145243324 style=zoom:67%><p>最下面的distance函数暴力给外部，用户调用此distance就可以得到举例，并不用关系内部的实现，但是内部是先调用了萃取器获得了迭代器的分类，之后再将分类信息和迭代器一起传入_distance函数，对于不同的种类会有不同的处理方式,之后distance返回 _disnatce的返回值，这样外部使用起来无感，不知道内部其实调用了其他的函数，但是不同的迭代器效率不同</p><p>所以说迭代器的分类会对算法产生很大的影响，算法必须判断出当前迭代器的种类，之后采取适合当前迭代器的最高效的操作</p><p>并且对于输出迭代器而言，他无法想普通的迭代器一样读元素，所以如果传递进来的迭代器版本是输出迭代器，那么还需要单独设计一个函数，例如单独设计一个_distance函数来对容器进行操作，这里进一步体现出容器的种类对于算法的影响</p><p>并且由于有的算法只能再特定类型的迭代器上运行，例如sort函数只能在随机访问的迭代器上操作，所以一旦传入不支持随机访问的迭代器就会出现问题，但是语法检查并不检查这个错误，所以只能尽可能避免</p><h3 id=迭代器适配器>迭代器适配器
<a class=header-anchor href=#%e8%bf%ad%e4%bb%a3%e5%99%a8%e9%80%82%e9%85%8d%e5%99%a8></a></h3><p>迭代器适配器对迭代器进行一系列的改造，使其符合自己的需求，最终形成了不同的迭代器适配器</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011322355.png alt=image-20230531170405521 style=zoom:50%><h3 id=各种算法>各种算法
<a class=header-anchor href=#%e5%90%84%e7%a7%8d%e7%ae%97%e6%b3%95></a></h3><p>STL中的算法肯定是先接收迭代器，之后的参数可能是多个，也可能没有，有了迭代器和可能的附加参数之后对容器进行操作</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//常用的拷贝替换算法
</span></span></span><span style=display:flex><span><span style=color:#75715e>//copy，容器之间的拷贝，拷贝之前记得声明容器的大小
</span></span></span><span style=display:flex><span><span style=color:#75715e>//replace，容器中指定元素替换成新元素,
</span></span></span><span style=display:flex><span><span style=color:#75715e>//如果是自定义数据类型，需要重载运算符==，才能判断何时找到了指定需要替换的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e>//replace_if 满足条件的所有元素替换成新元素
</span></span></span><span style=display:flex><span><span style=color:#75715e>//swap 交换两个容器中的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>////常见的排序算法
</span></span></span><span style=display:flex><span><span style=color:#75715e>////sort
</span></span></span><span style=display:flex><span><span style=color:#75715e>////random——shuffle
</span></span></span><span style=display:flex><span><span style=color:#75715e>////merge
</span></span></span><span style=display:flex><span><span style=color:#75715e>////reverse，与容器预先申请容量的reserve不同
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>////常用查找算法：
</span></span></span><span style=display:flex><span><span style=color:#75715e>////find：查找元素，返回迭代器，找不到返回end()
</span></span></span><span style=display:flex><span><span style=color:#75715e>////find_if：按条件查找元素
</span></span></span><span style=display:flex><span><span style=color:#75715e>////adjacent_find:查找相邻重复元素
</span></span></span><span style=display:flex><span><span style=color:#75715e>////binary_find：二分查找
</span></span></span><span style=display:flex><span><span style=color:#75715e>////count：统计元素个数
</span></span></span><span style=display:flex><span><span style=color:#75715e>////count_if：按条件统计元素个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>////accumulate,将容器范围内的值相加并返回，但是需要传递一个参数用来存储累加和
</span></span></span><span style=display:flex><span><span style=color:#75715e>////fill算法，将容器中指定范围内填充成指定元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>////常用集合算法，常见的注意事项
</span></span></span><span style=display:flex><span><span style=color:#75715e>//// 1.两个集合必须有序
</span></span></span><span style=display:flex><span><span style=color:#75715e>//// 2.目标容器的大小是两个集合中较小的
</span></span></span><span style=display:flex><span><span style=color:#75715e>//// 3.集合运算结束返回的是实际元素的下一个位置的迭代器，使用这个迭代器当作遍历的尾
</span></span></span><span style=display:flex><span><span style=color:#75715e>////set_intersection:交集
</span></span></span><span style=display:flex><span><span style=color:#75715e>////set_union:并集
</span></span></span><span style=display:flex><span><span style=color:#75715e>////set_difference:差集
</span></span></span></code></pre></td></tr></table></div></div><p>由于部分容器的迭代器属性不同，所以STL算法有可能无法作用到某些容器中，但是该容器又想拥有这些功能，所以会在容器的内部定义一个与STL中同名的算法，这样也可以实现相同的功能，但是在调用时，STL中的算法相当于全局函数，直接可以调用，容器内部的同名算法需要使用对象调用，这是一个区别，例如list由于其特性就无法使用STL中的sort函数，所以他内部自己是实现了一个sort，调用时的语法也和STL中不一样</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;list&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v1 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>};
</span></span><span style=display:flex><span>    list<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> l1 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>};
</span></span><span style=display:flex><span>    <span style=color:#75715e>//两个容器都需要sort，但是调用sort函数的方式不同
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//vector调用STL中的sort
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sort(v1.begin(), v1.end(),greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>//由于list不支持随机访问，所以sort函数不能在list上运行，但是语法检查上不会出现错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//只会在编译阶段出现错误，所以list排序只能通过自身的sort函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//list调用自身的sort
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    l1.sort();
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>所以当容器自身有同名算法时，优先调用同名算法，</p><h4 id=count>count
<a class=header-anchor href=#count></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011322356.png alt=image-20230529161230266></p><h4 id=sort>sort
<a class=header-anchor href=#sort></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011322357.png alt=image-20230529161720647></p><h4 id=find>find
<a class=header-anchor href=#find></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011322359.png alt=image-20230529161328503></p><p>。。。还有很多算法，但是基本结构与上述几个算法类似，算法不是每个容器中都带有</p><h3 id=仿函数>仿函数
<a class=header-anchor href=#%e4%bb%bf%e5%87%bd%e6%95%b0></a></h3><p>仿函数只为算法服务，在调用时和函数一样，但是他不是函数，所以起名仿函数</p><p>仿函数是一个重载了<code>()</code>运算符的类，传递参数时传递类生成的对象，之后就可以使用类对象调用重载的<code>()</code>运算符</p><p>STL中内置了一些仿函数（函数对象），主要有三种：算术仿函数，关系仿函数，逻辑仿函数</p><p>算术仿函数就是加减乘除之类的仿函数，关系仿函数就是大于小于之类的。逻辑仿函数就是与或非</p><p>举一个使用仿函数的例子</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v;
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>30</span>);
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>50</span>);
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>40</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> v.begin(); it <span style=color:#f92672>!=</span> v.end(); <span style=color:#f92672>++</span>it)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#f92672>*</span>it) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//使用内置的关系仿函数实现vector中元素的降序排列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//大于才返回真，相当于降序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//greater中就是判断大于
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//greater&lt;&gt;相当于一个内置的使用类模板的类，创建一个函数对象 greater&lt;int&gt;()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	sort(v.begin(), v.end(), greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;--------&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> v.begin(); it <span style=color:#f92672>!=</span> v.end(); <span style=color:#f92672>++</span>it)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#f92672>*</span>it) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>仿函数和谓词之间还有一定的联系</p><p>谓词就是返回值为bool类型的函数或者仿函数，所以当仿函数返回值类型为bool时，就可以将其当成一个谓词使用，拿上面的例子举例来说，就是将<code>greater&lt;>()</code>改成自定义的仿函数即可</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//定义一个仿函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Comp</span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//将较大的值放前面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span>()(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a<span style=color:#f92672>&gt;</span>b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v;
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>30</span>);
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>50</span>);
</span></span><span style=display:flex><span>	v.push_back(<span style=color:#ae81ff>40</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> v.begin(); it <span style=color:#f92672>!=</span> v.end(); <span style=color:#f92672>++</span>it)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#f92672>*</span>it) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//使用自定义的仿函数进行元素的降序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	sort(v.begin(), v.end(), Comp());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;--------&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> v.begin(); it <span style=color:#f92672>!=</span> v.end(); <span style=color:#f92672>++</span>it)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#f92672>*</span>it) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>STL中的仿函数继承了 binary_function(二元谓词)或者unary_function（一元谓词）这个类</p><p>继承这个类之后就拥有了相应的属性,每次调用这个仿函数时，就会多出这几个属性，有了这几个属性，就可以被配接形成仿函数适配器，例如下面的less</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// less的定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> _Tp<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>less</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> binary_function<span style=color:#f92672>&lt;</span>_Tp, _Tp, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> _Tp<span style=color:#f92672>&amp;</span> __x, <span style=color:#66d9ef>const</span> _Tp<span style=color:#f92672>&amp;</span> __y) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>      { <span style=color:#66d9ef>return</span> __x <span style=color:#f92672>&lt;</span> __y; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><p>继承binary_function之后，就会有三个属性，第一参数类型，第二参数类型，返回值类型</p><p>这些属性是为了后期给适配器使用，只有适配器知道了less的参数类型和返回值，才能知道怎么改造</p><p>所以说没有继承下面这两个类的仿函数无法被适配器改造</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011322360.png alt=image-20230531165019209 style=zoom:50%><p>其中binary_function三个属性，unary_function两个属性，对应一元谓词和二元谓词</p><p>如果希望自己定义的仿函数有配接能力，就需要继承二者之一，提供一些属性，仿函数适配器才知道怎么改造</p><h3 id=仿函数适配器>仿函数适配器
<a class=header-anchor href=#%e4%bb%bf%e5%87%bd%e6%95%b0%e9%80%82%e9%85%8d%e5%99%a8></a></h3><p>将仿函数进行一定的改造，使其符合自己的需求，例如将两个仿函数组合形成一个新的仿函数等适配操作</p><h3 id=适配器>适配器
<a class=header-anchor href=#%e9%80%82%e9%85%8d%e5%99%a8></a></h3><p>适配器内含一个仿函数成为了仿函数适配器，内含了一个迭代器成为了迭代器适配器，内含了一个容器变成了容器适配器</p><h4 id=仿函数适配器-1>仿函数适配器
<a class=header-anchor href=#%e4%bb%bf%e5%87%bd%e6%95%b0%e9%80%82%e9%85%8d%e5%99%a8-1></a></h4><p>当仿函数继承了一元谓词或者二元谓词这个类时，就会拥有他们的属性</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011322360.png alt=image-20230531165019209 style=zoom:50%><p>有了这些属性之后，仿函数适配器内含一个仿函数，通过调用他们的属性对仿函数进行改造</p><p>仿函数适配器对于仿函数的改造之后，最终的操作还是需要仿函数实现</p><ol><li><p><font color=red>bind2nd</font></p><p>代表着将仿函数的第二实参进行绑定 ，举一个例子：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306061452816.png alt=image-20230601150145619 style=zoom:67%><p>bind2nd将less的第二参数变成了固定的四十，本来countif中不能直接使用less，因为less需要传递两个参数，countif的目的就是传递一个参数，如果满足条件结果数就加一</p><p>所以bind2nd对less进行改造，将less的第二参数进行绑定，现在less就可以只传递一个参数</p><p>bind2nd内部调用了binder2nd这个类，将传递进来的less和绑定的第二参数进行保存，保存之前要校验类型是否匹配或者可以转化</p><p>之后countif内部调用的pred其实是调用的改造后的less</p><p>所以调用顺序是：countif->operator()->less()</p><p>这里count调用pred（仿函数当谓词）时，其实是调用了一个操作符重载，然后再操作符重载的内部调用less，第一参数就是pred传递的参数，第二参数就是绑定的参数，这个参数记录在binder2nd类中</p><p>而内部对于less的改造的顺序是</p><p><strong>bind2nd将传递进来的仿函数less和value传递给binder2nd，binder2nd记录这个仿函数less和value，并重载()运算符，接收一个参数x，内部调用记录的仿函数less，less传递的两个参数一个是接受的参数x，一个是记录的绑定参数value，暴露在外部时只用传递一个参数就可以实现对less的调用</strong></p><blockquote><p>bind2nd作为countif的参数就是一个类对象，因为他是inline，再加上返回值类型是个类对象，之后向类对象传递参数就是调用重载运算符()</p></blockquote><hr><p>正常的仿函数适配器的改造流程就是定义一个类模板，里面将传递进来的仿函数和一系列参数进行记录，之后重载()运算符，内部调用记录的仿函数，对参数进行修改，或者对结果进行修改</p><p>将这个类封装好之后，<strong>由于参数类型推导的问题，定义一个辅助函数，推导出参数的类型之后，内部调用这个类模板</strong></p><p>想要使用仿函数适配器时直接调用这个辅助函数即可</p><blockquote><p>辅助函数的模板中的参数与传递进来的仿函数类型保持一致，外部看来辅助函数就是这个仿函数的一个别名,外部调用时会直接调用重载运算符()</p></blockquote><blockquote><p>改造仿函数的过程中涉及到参数的类型，此时继承的那两个类就起了作用</p><p>知道了less的两个参数的类型，以及返回值的类型，改造的过程中就不会出现类型冲突</p></blockquote></li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// less的定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> _Tp<span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>less</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> binary_function<span style=color:#f92672>&lt;</span>_Tp, _Tp, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> _Tp<span style=color:#f92672>&amp;</span> __x, <span style=color:#66d9ef>const</span> _Tp<span style=color:#f92672>&amp;</span> __y) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>      { <span style=color:#66d9ef>return</span> __x <span style=color:#f92672>&lt;</span> __y; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><p>因为仿函数适配器内部重载了()运算符，所以外部看起来也像是一个仿函数</p><p>这个binder2nd本身又继承了unary_function，相当于他也可以被配接</p><ol start=2><li><p><font color=red>not1</font></p><p>这个仿函数适配器就是将仿函数（谓词）的结果取反，具体的运行逻辑与bind2nd一样，定义的not1也是一个辅助函数，真正的仿函数类叫做unary_nagate，not1的作用就是推导出传递而来的谓词的类型，并将其传递给unary-negate,在unary_negate中，由于知道了仿函数（谓词）的参数类型，在重载（）运算符时，直接调用此仿函数（谓词），将返回结果取反再返回即可</p></li><li><p><font color=red>bind</font></p><p>bind就是加强版的bind2nd，可以绑定函数，仿函数，成员函数，使用占位符（_1、 _2、 _3）表示当前的参数不绑定，给一个确定的参数就表示这个参数绑定给对应的函数，可以是普通函数，仿函数，成员函数等</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306061452647.png alt=image-20230601153621570 style=zoom:67%><p>bind可以绑定很多东西，绑定的第一参数返回什么就返回什么</p><p>bind可以代替bind2nd，代码的可读性更好，使用占位符表示哪些参数没被绑定。后期调用时就需要填补</p><p>对于最后一行，bind将less的第二参数绑定为50，第一参数不绑定使用占位符防止语法错误，</p><p>countif内部调用会调用这个bind函数，传递一个参数，填补第一参数，与绑定的第二参数作比较</p></li></ol><h4 id=容器适配器-1>容器适配器
<a class=header-anchor href=#%e5%ae%b9%e5%99%a8%e9%80%82%e9%85%8d%e5%99%a8-1></a></h4><p>适配器内涵一个容器，然后将容器的部分方法封闭或者加以改造，就形成了自己独有的方法，</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306061452648.png alt=image-20230601132533305 style=zoom:50%><p>可以看出stack底层的实现就是deque，但是他将deque的部分函数舍弃，部分函数改名，删除和插入都是在尾部，去掉了头部的操作。。。</p><h4 id=迭代器适配器-1>迭代器适配器
<a class=header-anchor href=#%e8%bf%ad%e4%bb%a3%e5%99%a8%e9%80%82%e9%85%8d%e5%99%a8-1></a></h4><p>迭代器适配器一般都是对= ++ &ndash;运算符重载，然后实现在内部调用其他的迭代器实现相应的功能</p><p>因为迭代器适配器一般都与copy函数连用，改变copy中的这三个操作，就可以实现特殊的功能</p><p>而仿函数迭代器一般都是对()运算符重载，然后再内部调用其他的仿函数实现相应的功能</p><ol><li><p><font color=red>reverse_iterator</font></p><p>定义一个reverse_iterator类，其中对iterator进行操作，将头尾互换，从容器的尾部向头部移动，所以++和&ndash;的操作也会相反</p><p>逆向迭代器和普通的迭代器一样，也有五个属性，由萃取器提供，</p></li></ol><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306061452649.png alt=image-20230601160000790 style=zoom:50%><ol start=2><li><p><font color=red>inserter</font></p><p>inserter也是一个辅助函数，内部调用insert_iterator迭代器类，辅助函数的作用也是为了推导出容器和迭代器的类型，之后调用调用insert_iterator迭代器类，和bind2nd的思想类似</p><p>但是重载的不再是()运算符，而是=运算符，目的就是将copy中的=进行重写</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306061452650.png alt=image-20230601163103539></p><p>foo的it迭代器进行插入时有两次++，第一次++在=操作符重载内，为了指向新元素，第二次++在copy内，为了移动到下一个位置，插入的时候在当前位置的前面插入</p><p>整体流程就是调用copy函数，第三个参数传递的是一个使用inserter处理过的迭代器，类型与普通迭代器一样，只是重载了=运算符</p><p>copy内部执行到赋值=时，调用迭代器重载的=运算符，内部将传递来的容器进行插入，插入之后移动迭代器，返回这个插入类型的迭代器，看起来就像是普通的赋值，其实上是插入</p><blockquote><p>就是重载=运算符，类似于仿函数迭代器中重载()运算符一样</p></blockquote></li><li><p><font color=red>ostream_iterator</font></p><p>将迭代器中的内容输出到屏幕</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306061452651.png alt=image-20230601164747141></p><p>调用copy函数，然后copy的第三参数是一个迭代器适配器，类型与普通迭代器一样，只是重载了=运算符，copy内部运行到*result=*first时,自动调用重载的=运算符版本，从而实现对元素的打印，将first中的值传递给result，result中传递给输出流对象实现打印</p><p>这都是写好的东西，可以直接用，主要是运算符进行了重载</p></li><li><p><font color=red>istream_iterator</font></p><p>将输入的内容传递给迭代器，然后取出迭代器的内容就可以得到输入值</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011821556.png alt=image-20230601182152433></p><p>执行流程是定义两个istream_iterator迭代器，之后调用对应的构造函数，无参构造将迭代器变成一个eos标志，有参构造函数将其变成一个接受输入的迭代器，调用++实现接受输入，将输入存放在this中，也就是迭代器中，将这个迭代器的值取出来放到value1中，之后++再调用++运算符重载函数，再次接受输入</p><p>相当与调用了两次++，第一次在构造函数中调用，第二次是主动调用</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306011841502.png alt=image-20230601184118385 style=zoom:67%><p>这个结合inserter一起，使用istream_iterator接收输入，使用inserter将输入插入到容器c中</p><p>inserter因为内部重载了=，所以在copy时，调用重载运算符=，内部将调用容器的插入函数，将值插入到容器中</p><p>istream_iterator重载了++，可以接收输入，将输入通过*取出来之后，进行插入</p><blockquote><p>核心就是while代码中的三个运算符重载，使得copy的功能变得强大</p><p>将copy改头换面 接受输入，插入到容器c中</p></blockquote></li></ol><h2 id=第四部分>第四部分
<a class=header-anchor href=#%e7%ac%ac%e5%9b%9b%e9%83%a8%e5%88%86></a></h2><p>前三部分介绍了STL的六大部分，第四部分介绍除此之外剩下的部分</p><h3 id=哈希函数>哈希函数
<a class=header-anchor href=#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0></a></h3><blockquote><p>如何对自定义类型进行哈希</p></blockquote><p>当使用unordered_map和unordered_set时，底层会调用哈希表来对元素进行哈希确定存储的位置，这就涉及到一个问题，系统可能对整数，字符已经定义了哈希函数，但是对自定义的类型肯定是没有给出哈希函数的，此时就需要我们指定</p><p>就像是对元素进行排序一样，系统对整型或者字符串给出了比较的函数，从而可以直接进行排序，但是对于自定义的数据类型是没有给定的，此时就需要自定义一个比较函数</p><p>此时这个比较函数可以使用全局函数，也可以使用仿函数，只要可以比较大小并且返回值是bool即可</p><hr><p>类比排序自定义类型时的操作，对自定义数据类型进行哈希也可以使用
<a href=https://blog.csdn.net/qq_45311905/article/details/121488048 title=四种 rel="noopener external nofollow noreferrer" target=_blank class=exturl>四种
<i class="fa fa-external-link-alt"></i>
</a>方式定义哈希函数：</p><ol><li>全局函数做哈希</li><li>仿函数做哈希</li><li>自定义哈希函数</li><li>特化hash函数</li></ol><p>对于前三种，在使用时将哈希函数当成一个参数传递给对应的容器即可，假设定义的哈希类名叫做Hasher，并且使用unordered_set存储Person自定义类型，此时传递的格式为：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span>unordered_set<span style=color:#f92672>&lt;</span>Person,Hasher<span style=color:#f92672>&gt;</span> uset;
</span></span></code></pre></td></tr></table></div></div><p>在参数列表指定哈希函数</p><p>对于第四种，相当于不传递哈希函数，在容器调用哈希函数时，传递的元素类型时Person，所以会调用偏特化版本的hash函数，实现自定义数据类型的哈希</p><h4 id=变长参数>变长参数
<a class=header-anchor href=#%e5%8f%98%e9%95%bf%e5%8f%82%e6%95%b0></a></h4><p><strong>系统给我们提供了一个万用的哈希函数</strong></p><p>系统认为自定义的数据类型也是由普通数据类型拼接而成，例如人这种类型由年龄（int），姓名（string）等基本类型组成</p><p>基于这个原理，系统提供了三种不同的万用哈希函数</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306031456647.png alt=image-20230603145604538 style=zoom:67%><p>上图的执行流程如下：</p><ol><li><p>首先调用哈希函数1，传递三个参数，哈希函数1创建一个seed</p><p>将seed和三个参数传递给哈希函数2，</p></li><li><p>哈希函数2首先接收到哈希函数1传来的seed和三个参数，将三个参数拿出来一个，也就是val</p><p>拿seed和val做combine，得到一个新的seed，传递的是引用，不需要返回值，</p><p>有了新的seed，调用自身，将这个seed和剩下的两个参数传递给自己</p><p>然后从两个参数中拿一个，与seed再次combine，得到新的seed</p><p>此时只剩下一个参数，调用哈希函数3，在哈希函数3中调用combine，将seed和最后一个参数combine，形成最终的seed</p></li><li><p>处理完参数之后，哈希函数1将seed返回当作hashcode</p></li></ol><p>总结：外层调用哈希函数1，内层调用哈希函数2，每次拿一个参数和seed做combine，内部调用hash函数单独处理这个参数，参数越来越少，剩下一个参数时与哈希函数3做combine，最终的hashcode保存在seed中，由哈希函数1返回</p><blockquote><p>对于参数列表的处理由哈希函数2完成，哈希函数3做收尾工作</p></blockquote><p>当需要自定义哈希函数时，内部将自定义属性拆分成单个的系统属性传递给<code>hash_val</code>函数即可</p><p>使用容器是将哈希函数作为参数传递，系统就知道如何进行哈希</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306031511822.png alt=image-20230603151152762 style=zoom:80%><p>这样就可以使用哈希表实现的容器对自定义类型数据进行存放</p><h3 id=tuple>Tuple
<a class=header-anchor href=#tuple></a></h3><p>tuple可以存放任意类型的数据， 只要指定好数据类型即可</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306031539170.png alt=image-20230603153906110></p><p>存放三个元素，使用get&lt;i> 容器名获得其中的某个元素</p><p>tuple之间可以比较大小，赋值，取元素（tie(int,float,string)可以一次性将t1中的三个元素取出来）</p><p>实现存放不同元素的原理就是指定元素的类型，由于类型个数可能会变化，所以这里使用参数可变的模板，处理可变的参数时，借鉴哈希函数中的思想，<code>hash_val1</code>对外提供接口，hash_val2处理参数，<code>hash_val3</code>善后</p><h4 id=变长参数-1>变长参数
<a class=header-anchor href=#%e5%8f%98%e9%95%bf%e5%8f%82%e6%95%b0-1></a></h4><p>tuple处理变长参数关键就是<strong>递归继承</strong>自己，哈希函数处理变长参数关键是<code>hash_val2</code><strong>递归调用</strong>自己</p><p>tuple每继承一次自己都减少一个参数，减少的参数存放在head中，当tuple为空是不再继承，定义一个空的tuple作为终止条件</p><p>相当于tuple中有一个小一级的tuple，小一级的tuple中有一个更小一级的tuple</p><p>取出tuple的头部就是第一参数的值，取出tuple的尾部就是少一个参数的新tuple</p><p>在程序中返回的是this指针。this原本应该代表没有减少参数的tuple，为什么最后会代表减少一个参数的tuple呢，因为做了类型转换</p><p>返回值类型inherited是一个去掉了头部的tuple类型，所以this会被强制类型转换，变成减少一个参数的tuple</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306031620066.png alt=image-20230603161959925 style=zoom:67%><blockquote><p>传递进来一系列参数，自动将其分成head和tail</p></blockquote><h3 id=type-traits>type traits
<a class=header-anchor href=#type-traits></a></h3><p>可以提取到类型的各个属性，使用该属性时有需要的话就可以使用type traits得到他的一些属性，与迭代器的traits类似</p><h4 id=使用>使用
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8></a></h4><p>将其理解为一个类型的萃取器，决定了类型的属性是否重要，主要有五个属性：</p><ol><li>默认构造是否重要</li><li>拷贝构造是否重要</li><li>赋值运算符是否重要</li><li>析构函数是否重要</li><li>是不是兼容c的类型</li></ol><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306031633426.png alt=image-20230603163313486 style=zoom:67%><p>每个类型都可以对<code> </code>进行特化，决定五个属性哪些是重要的</p><p>基本上不是指针的类型这些属性都是不重要的</p><p>在算法中，使用<code>type_traits</code>得到类型的这些属性是否重要，从而进行不同的操作</p><p><strong>后期还出现了更多的<code>type traits</code></strong>，都是为了得到类型的不同属性</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306031641869.png alt=image-20230603164104784 style=zoom:67%><p>调用<font color=blue>蓝色</font>的这些函数就可以得到类型的属性</p><h4 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h4><p>当想要知道某一个类型的某些属性时，外部直接调用上述中的一个<font color=blue>蓝色</font>的函数，并将这个类型作为一个参数传递即可，底层收到这个参数，将可能存在的 const属性去掉，之后调用helper函数，满足条件就返回true，其余的一律返回false，如下图所示：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306032047927.png alt=image-20230603204731854></p><ol><li>参数传递给helper函数</li><li>去除掉影响判断的部分</li><li>符合要求的返回true，其余的一律返回false</li></ol><p>编译器在对这些类型编译时，肯定知道这些类型都有哪些属性，所以有时候获得属性的方法就是交给编译器</p><h3 id=iterator包含的五个typedef>iterator包含的五个typedef
<a class=header-anchor href=#iterator%e5%8c%85%e5%90%ab%e7%9a%84%e4%ba%94%e4%b8%aatypedef></a></h3><p>容器中的每一个迭代器都带有这五种属性，算法使用迭代器操作容器时，不同的容器由于属性不同，所以操作的方式不同，例如vector支持随机访问，就可以使用STL自带的sort函数，而list不支持随机访问，所以自身需要增加一个sort函数</p><ol><li>iterator_category：迭代器的种类，可随机访问还是顺序访问</li><li>difference_type：迭代器之间的距离</li><li>value_type：迭代器中元素的类型，int还是string</li></ol><p>后面的两种预留在后面使用</p><ol><li>reference：</li><li>pointer:</li></ol><h3 id=补充萃取器-iterator-traits>补充萃取器 Iterator Traits
<a class=header-anchor href=#%e8%a1%a5%e5%85%85%e8%90%83%e5%8f%96%e5%99%a8-iterator-traits></a></h3><p>主要为了得到容器中的几个属性，传递给算法之后才能进行一系列的操作</p><p>当iterator是一个类时，算法可以很轻易的得到上述的五个属性，但是如果iterator是一个指针呢，此时就需要使用iterator traits，他可以区分迭代器是一个类还是一个指针</p><hr><p>当想要使用容器中的几个属性，例如存储元素的类型，如果直接使用*it得到的是元素的值，并不是元素的地址，所以想到了封装一层参数，参数传递时编译器帮我们推导出类型，但是函数的返回值也无法推导，所以又想到了内嵌类型，应用之后发现如果迭代器是一个原生指针，又会出现无法定义内嵌类型的情况根据以上分析，最终设计出了萃取器</p><blockquote><p>以上参考了侯捷STL源码剖析P84中3.3和P85中3.4的分析</p></blockquote><hr><p>可以想象成一个函数，传递进去一个迭代器，返回迭代器的类型，区分的方式就是通过<strong>函数重载</strong>，不同的参数列表调用不同的traits，得到不同的结果</p><p>上面说的<strong>函数重载</strong>，类比使用模板定义的traits中被称为<strong>偏特化</strong></p><p>总结来说，就是增加一个中间层，如果迭代器是类，直接使用类名加<code>::</code>的方式得到五个属性，如果是指针，就不能使用类名加<code>::</code>的方式得到五个属性，此时traits直接返回五个属性</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202305251414509.png alt=image-20230525141449364 style=zoom:67%><h3 id=补充重载运算符>补充重载运算符
<a class=header-anchor href=#%e8%a1%a5%e5%85%85%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e7%ac%a6></a></h3><p>前置运算符++和后置运算符++重载的区别：例如i=3，<code>++i</code>之后i=4,此时直接使用i得到的结果为4，而i=3，<code>i++</code>之后需要分为两步，第一步使用i得到的结果为3，使用完成之后i才会变成4，这也导致了<code>++i</code>得到的结果是一个左值，<code>i++</code>的结果是一个右值，使用完成之后才会完成自增</p><p>重载运算符时，前置自增没有参数列表，且返回值是一个当前对象的引用，后置自增有参数列表，返回值是一个右值，调用后置递增时，编译器自动提供一个为0的实参，没有任何作用，只是为了区分前置和后置，所以看到后置运算有一个<code>int</code>类型的形参</p><p>显式调用时需要加上这个实参进行区分：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span>p.<span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>();			<span style=color:#75715e>//等价于++p
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>p.<span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#ae81ff>0</span>);		<span style=color:#75715e>//等价于p++，需要显式指定实参才能区分
</span></span></span></code></pre></td></tr></table></div></div><p>示例代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    string Name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> Age;
</span></span><span style=display:flex><span>    Person(){}
</span></span><span style=display:flex><span>    Person(string name,<span style=color:#66d9ef>int</span> age)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Name<span style=color:#f92672>=</span>name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Age<span style=color:#f92672>=</span>age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//拷贝构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Person(<span style=color:#66d9ef>const</span> Person <span style=color:#f92672>&amp;</span>p)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Name<span style=color:#f92672>=</span>p.Name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Age<span style=color:#f92672>=</span>p.Age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Person <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Age<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//增加一个参数为了区分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Person <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Person <span style=color:#a6e22e>temp</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Name,<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Age);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Age<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> temp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Person p1(<span style=color:#e6db74>&#34;aaa&#34;</span>,<span style=color:#ae81ff>13</span>);
</span></span><span style=display:flex><span>    Person p2(<span style=color:#e6db74>&#34;bbb&#34;</span>,<span style=color:#ae81ff>13</span>);
</span></span><span style=display:flex><span>    Person p11(<span style=color:#f92672>++</span>p1);
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>p11.Age<span style=color:#f92672>&lt;&lt;</span>endl;<span style=color:#75715e>//14
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Person p22(p2<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>p22.Age<span style=color:#f92672>&lt;&lt;</span>endl;<span style=color:#75715e>//13
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    system(<span style=color:#e6db74>&#34;pause&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>具体list中的++运算符重载如图所示：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202305241620193.png alt=image-20230524162038127></p><p>由于c++操作符的右结合性，所以后置递增两次是不被允许的</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span>i<span style=color:#f92672>++++</span><span style=color:#75715e>//非法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>++++</span>i<span style=color:#75715e>//合法
</span></span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/stl>STL</a>
<a href=/tags/%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b>泛型编程</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/ rel=next title=122.买卖股票的最佳时机II><i class="fa fa-chevron-left"></i> 122.买卖股票的最佳时机II</a></div><div class="post-nav-prev post-nav-item"><a href=/post/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/ rel=prev title=53.最大子序和>53.最大子序和
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2024</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>zzzi提供技术支持</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://zzzicode.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":null,"views":null},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"right","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.b0e26367f0461fb41ac6f947dc2af3620375dc44aa8945e6c2b1480d342c65d1.js defer></script>
<script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>