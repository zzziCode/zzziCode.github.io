<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.111.3"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon_next.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon_next.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon_next.png><meta itemprop=name content="C++11-14新标准"><meta itemprop=description content="C++11-14新标准"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://zzzicode.github.io/imgs/avatar.png"><meta itemprop=keywords content="c++,新标准"><meta property="og:type" content="article"><meta property="og:title" content="C++11-14新标准"><meta property="og:description" content="C++11-14新标准"><meta property="og:image" content="/imgs/avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://zzzicode.github.io/post/c++11-14%E6%96%B0%E6%A0%87%E5%87%86/"><meta property="og:site_name" content="zzzi的小站"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="zzzi"><meta property="article:published_time" content="2023-06-04 09:15:23 +0800 CST"><meta property="article:modified_time" content="2023-06-04 09:15:23 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4b7f3d9c4ef8db1505229a7dcd2c4e3ab17cd4960dd8a78b503c013770ad56a6.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"c++11-14%E6%96%B0%E6%A0%87%E5%87%86","permalink":"https://zzzicode.github.io/post/c++11-14%E6%96%B0%E6%A0%87%E5%87%86/","title":"C++11-14新标准"}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>C++11-14新标准 - zzzi的小站</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>zzzi的小站</h1><i class=logo-line></i></a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>228</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#语言>语言</a><ul><li><a href=#variadic-templates>Variadic Templates</a></li><li><a href=#测试例子>测试例子</a></li><li><a href=#容器嵌套容器>容器嵌套容器</a></li><li><a href=#auto>auto</a></li><li><a href=#统一初始化>统一初始化</a></li><li><a href=#initializer-lists>Initializer Lists</a></li><li><a href=#小总结>小总结</a></li><li><a href=#explicit>explicit</a></li><li><a href=#emplace>emplace</a></li><li><a href=#range-for>range for</a></li><li><a href=#defaultdelete>=default，=delete</a><ul><li><a href=#深拷贝和浅拷贝>深拷贝和浅拷贝</a></li></ul></li><li><a href=#alias-template>Alias Template</a></li><li><a href=#模板模板参数>模板模板参数</a></li><li><a href=#小总结-1>小总结</a></li><li><a href=#type-alias>Type Alias</a></li><li><a href=#using>using</a></li><li><a href=#noexcept>noexcept</a></li><li><a href=#override>override</a></li><li><a href=#final>final</a></li><li><a href=#decltype>decltype</a></li><li><a href=#lambdas>lambdas</a></li><li><a href=#typename>typename</a></li><li><a href=#string类型转换>string类型转换</a></li></ul></li><li><a href=#标准库>标准库</a><ul><li><a href=#右值引用httpszhuanlanzhihucomp335994370><a href=https://zhuanlan.zhihu.com/p/335994370>右值引用</a></a><ul><li><a href=#基础>基础</a></li><li><a href=#move>move</a></li><li><a href=#forward>forward</a></li><li><a href=#对容器的影响>对容器的影响</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#新增容器>新增容器</a><ul><li><a href=#array>array</a></li><li><a href=#hashtable>HashTable</a></li></ul></li></ul></li><li><a href=#总结-1>总结</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=zzzi src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.png><p class=site-author-name itemprop=name>zzzi</p><div class=site-description itemprop=description>make_tuple("工作","论文")</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>228</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>5</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>54</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/zzziCode title="Github → https://github.com/zzziCode" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://zzzicode.github.io/post/c++11-14%E6%96%B0%E6%A0%87%E5%87%86/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.png"><meta itemprop=name content="zzzi"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="zzzi"><meta itemprop=description content="make_tuple(&#34;工作&#34;,&#34;论文&#34;)"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="C++11-14新标准"><meta itemprop=description content="C++11-14新标准"></span><header class=post-header><h1 class=post-title itemprop="name headline">C++11-14新标准</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text title=发表于>发表于：</span>
<time title="创建时间：2023-06-04 09:15:23 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-06-04 09:15:23 +0800 CST">2023-06-04</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text title=分类于>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0 itemprop=url rel=index><span itemprop=name>学习笔记</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span>
<span>9200</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>19分钟</span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><blockquote><p>😄C++11-14新标准</p></blockquote><p>记录C++11&amp;14中出现的新特性，主要分为语言和标准库两部分</p><h2 id=语言>语言
<a class=header-anchor href=#%e8%af%ad%e8%a8%80></a></h2><p>介绍C++11中新出现的语言特性</p><h3 id=variadic-templates>Variadic Templates
<a class=header-anchor href=#variadic-templates></a></h3><p>总结来说就是可以接收变长参数，在标准库中的万用哈希函数<code>hash_val</code>以及<code>tuple</code>等知识都用到了<code>Variadic Templates</code>这个新特性，接收变长参数，将其一层一层的处理</p><p>举一个简单的例子：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306041019807.png alt></p><p>函数print接收的参数个数不定，假设传递<code>n</code>个参数，print将<code>n</code>个参数分成<code>1</code>和<code>n-1</code>个，先输出一个</p><p>然后在函数体内调用自身，传递<code>n-1</code>个参数，print将<code>n-1</code>个参数分成<code>1</code>和<code>n-2</code>个，输出一个。。。</p><p>就这样一层一层的调用自身，每次调用之前先减少一个参数</p><p>最后一层剩下一个参数，调用自身传递0个参数，到了结束标志，整个打印结束</p><blockquote><p>递归调用自身，调用过程中剥离参数进行处理，使得参数变得越来越少</p></blockquote><p>总结一个变长参数的函数模板：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T,<span style=color:#66d9ef>typename</span>... Types<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> func(T<span style=color:#f92672>&amp;</span> firstArg,Types<span style=color:#f92672>&amp;</span> otherArgs){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理firstArg
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//递归调用自身,少传递一个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    func(otherArgs...);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//处理边界条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(){}
</span></span></code></pre></td></tr></table></div></div><p>如果想要知道后面的n-1个参数的大小，可以使用<code>sizeof...(otherArgs)</code></p><p><code>...</code>是一个包，出现在不同参数的后面就是不同的包：</p><ol><li><code>typename..</code>.，模板参数包</li><li><code>Types... otherArgs</code>，函数参数类型包</li><li><code>otherArgs...</code>，函数参数包</li></ol><hr><p>不仅仅是函数，tuple也借用了变长参数的理论来实现自身，tuple可以存放不同的元素，在调用构造函数时，将传递进来的参数分成1和n-1，然后剩下的n-1以继承的方式交给新的tuple</p><p>最后使用一个空tuple处理边界条件</p><p>获取tuple中的元素时，使用head和tail，head返回<code>1</code>，tail返回<code>n-1</code>形成的tuple，在代码中先返回<code>this</code>，再对<code>this</code>进行转型</p><p>具体的实现细节如图所示：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306041029210.png alt=image-20230604102943163 style=zoom:67%><blockquote><p>函数和类的处理思路是一样的，一个是调用自身，一个是继承自身，在这个过程中减少参数量</p></blockquote><p>hash_val的处理方式也是这样，对于自定义类型的哈希，将自定义类型拆分成多个系统内置类型，之后使用hash_val将这些拆分类型传递过去进行处理</p><p>由于不同自定义类型使用的系统内置类型的个数不定，所以使用了variadic templates的思想接收变长参数，可以实现万用性</p><h3 id=测试例子>测试例子
<a class=header-anchor href=#%e6%b5%8b%e8%af%95%e4%be%8b%e5%ad%90></a></h3><p>一共有三个地方需要使用<code>...</code></p><ol><li>typaname&mldr; Types</li><li>const Types&&mldr; otherAgrs</li><li>otherArgs&mldr;</li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//定义边界条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printX</span>() {}
</span></span><span style=display:flex><span><span style=color:#75715e>//测试万用打印函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Types<span style=color:#f92672>&gt;</span><span style=color:#75715e>//1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> printX(<span style=color:#66d9ef>const</span> T <span style=color:#f92672>&amp;</span>firstArg, <span style=color:#66d9ef>const</span> Types <span style=color:#f92672>&amp;</span>...otherArgs)<span style=color:#75715e>//2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//处理第一个元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> firstArg <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//递归处理剩下的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printX(otherArgs...);<span style=color:#75715e>//3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//定义一个人类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    string Name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> Age;
</span></span><span style=display:flex><span>    Person(string name, <span style=color:#66d9ef>int</span> age)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Name <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        Age <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//因为使用的格式为cout&lt;&lt;person，所以是cout调用，不能定义成成员函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>friend</span> ostream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(ostream <span style=color:#f92672>&amp;</span>output, <span style=color:#66d9ef>const</span> Person <span style=color:#f92672>&amp;</span>p)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        output <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;person : &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p.Name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p.Age <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//一个printX实现任意类型，任意长度的打印
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printX(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2.2</span>, <span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#e6db74>&#39;c&#39;</span>, Person(<span style=color:#e6db74>&#34;张三&#34;</span>, <span style=color:#ae81ff>20</span>));
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;-------&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    printX(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2.2</span>, <span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#e6db74>&#39;c&#39;</span>, Person(<span style=color:#e6db74>&#34;张三&#34;</span>, <span style=color:#ae81ff>20</span>),Person(<span style=color:#e6db74>&#34;李四&#34;</span>,<span style=color:#ae81ff>30</span>));
</span></span><span style=display:flex><span>    system(<span style=color:#e6db74>&#34;pause&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=容器嵌套容器>容器嵌套容器
<a class=header-anchor href=#%e5%ae%b9%e5%99%a8%e5%b5%8c%e5%a5%97%e5%ae%b9%e5%99%a8></a></h3><p>最开始c++容器嵌套容器时，需要使用空格区分是容器还是输出运算符，但是c++11新标准之后，编译器已经可以智能的区分了，所以不用加空格</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>list<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> <span style=color:#75715e>//c++11之前需要加一个空格
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>list<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>  <span style=color:#75715e>//c++11之后不需要加空格
</span></span></span></code></pre></td></tr></table></div></div><h3 id=auto>auto
<a class=header-anchor href=#auto></a></h3><p>编译器可以自动推导变量的类型，和模板或者函数重载一样，可以自动推导出参数的类型</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>auto</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>42</span><span style=color:#75715e>//i是int类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> f();
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> d<span style=color:#f92672>=</span>f();<span style=color:#75715e>//d是double类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>v1;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> it<span style=color:#f92672>=</span>v1.begin()<span style=color:#75715e>//it是vector&lt;int&gt;::iterator类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> num;<span style=color:#75715e>//编译失败    
</span></span></span></code></pre></td></tr></table></div></div><p>当参数的类型名很长，例如迭代器，或者参数的类型实在想不起来的时候，就可以使用auto，但是不推荐任何地方都是用auto，这样会降低代码的可读性</p><h3 id=统一初始化>统一初始化
<a class=header-anchor href=#%e7%bb%9f%e4%b8%80%e5%88%9d%e5%a7%8b%e5%8c%96></a></h3><p>c++11之前对于初始化的操作有多种不统一的方式，<code>()</code>、<code>{}</code>、<code>=</code>都可以用来初始化，并且每个变量支持初始化的方式不同，这就导致了初始化时会造成一些不必要的错误</p><p>基于这个原因，c++11提出了一个统一初始化，规定任何变量都可以使用<code>{}</code>初始化，当然以前的方式都保留，只是给一些没有<code>{}</code>赋值的变量增加了这种方式</p><blockquote><p>不知道怎么初始化就用{}</p></blockquote><p>背后的原理就是将{}中的内容传递给一个<code>initializer_list</code>，之后<code>initializer_list</code>将元素传递给<code>array</code>，<code>array</code>会判断变量的构造函数能否接受<code>initializer_list</code>这种类型，可以的话直接初始化，不可以的话就将<code>{}</code>中的元素依次取出传递给要初始化的变量</p><blockquote><p>能接受initializer_list就传递initializer_list,接受不了就依次取出进行初始化</p></blockquote><h3 id=initializer-lists>Initializer Lists
<a class=header-anchor href=#initializer-lists></a></h3><p>使用initializer lists可以对变量进行统一初始化，底层使用array</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> i;<span style=color:#75715e>//i未定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> j{};<span style=color:#75715e>//j有初值0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p;<span style=color:#75715e>//p未定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> d1<span style=color:#f92672>=</span>{<span style=color:#ae81ff>2.2</span>};<span style=color:#75715e>//d1有初值2.2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>q{};<span style=color:#75715e>//q有初值nullptr
</span></span></span><span style=display:flex><span><span style=color:#75715e>//相当于调用构造函数时生成了一个initializer_list&lt;&gt;
</span></span></span></code></pre></td></tr></table></div></div><p>为了实现统一初始化，规定可以使用<code>{}</code>，编译器将{}中的内容转化成一个<code>initializer_list&lt;></code>类型的容器，其中存放初始化的值</p><p>相比与<code>variadic templates</code>，这个容器只能存放类型一样的元素，但是元素的个数不定</p><p>使用<code>initializer_list</code>初始化时，如果构造函数能接受<code>initializer_list&lt;></code>就直接调用这个版本的构造函数</p><p>如果没有的话需要将<code>initializer_list</code>拆分，拆分出来n个元素，但是<strong>没有</strong>接收n个元素的构造函数，此时初始化就<strong>失败</strong>了</p><p>底层使用一个迭代器</p><blockquote><p>没有匹配的initializer_list就拆分之后有没有匹配的构造函数</p></blockquote><p>容器可以接受任意数量的参数就是因为构造函数可以接受<code>initializer_list&lt;></code>,并且有的参数可以接收变长参数也是因为重载了接收<code>initializer_list&lt;></code>的版本，例如<code>max</code>和<code>min</code></p><hr><h3 id=小总结>小总结
<a class=header-anchor href=#%e5%b0%8f%e6%80%bb%e7%bb%93></a></h3><p>c++11提供两种处理变长参数的方式：</p><ol><li>variadic templates：接收的参数不定，类型任意</li><li>initializer_list：接受的参数不定类型一致</li></ol><h3 id=explicit>explicit
<a class=header-anchor href=#explicit></a></h3><p>如果使用<code>explicit</code>修饰构造函数，那么编译器就不会隐式的将一些动作转化成对构造函数的调用，只有显式的声明需要调用构造函数时才会调用</p><p>c++11之前只有单个参数的非<code>explicit</code>构造函数有时才会提供<code>explicit</code>的修饰，但是c++11之后，一个以上参数的构造函数也可以使用<code>explicit</code>修饰</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306041402780.png alt=image-20230604140224719 style=zoom:67%><blockquote><p>使用explicit修饰的构造函数只能显式调用</p></blockquote><h3 id=emplace>emplace
<a class=header-anchor href=#emplace></a></h3><p>使用<code>emplace</code>来将元素存入容器中时，容器直接在底层创建对象并将其存入，而不是像<code>push_back</code>一样，先创建一个临时对象，之后使用临时对象接收传入的参数，举例如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>Test</span>( <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string <span style=color:#f92672>&amp;</span>name)<span style=color:#f92672>:</span>name(std<span style=color:#f92672>::</span>move(name))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;I am being constructed.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Test(<span style=color:#66d9ef>const</span> Test <span style=color:#f92672>&amp;</span>other)<span style=color:#f92672>:</span>name(std<span style=color:#f92672>::</span>move(other.name))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>         std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;I am being copy constructed.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//右值引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Test( Test <span style=color:#f92672>&amp;&amp;</span>other)<span style=color:#f92672>:</span>name(std<span style=color:#f92672>::</span>move(other.name))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;I am being moved.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>//1&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;emplace_back:&#34;</span><span style=color:#f92672>&lt;&lt;</span>std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Test<span style=color:#f92672>&gt;</span>T1;
</span></span><span style=display:flex><span>    T1.emplace_back(<span style=color:#e6db74>&#34;yang&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>//输出 	I am being constructed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//2&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;emplace_back2:&#34;</span><span style=color:#f92672>&lt;&lt;</span>std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Test<span style=color:#f92672>&gt;</span>T2;
</span></span><span style=display:flex><span>    T2.emplace_back(Test(<span style=color:#e6db74>&#34;aaaa&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#75715e>//输出 	I am being constructed   表面调用构造函数，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//		I am being moved         底层调用构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//3&gt;为什么和emplace一样
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;push_back1:&#34;</span><span style=color:#f92672>&lt;&lt;</span>std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Test<span style=color:#f92672>&gt;</span>T3;
</span></span><span style=display:flex><span>    T3.push_back(Test(<span style=color:#e6db74>&#34;a&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#75715e>//输出 	I am being constructed   表面调用构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//		I am being moved		  表面调用构造函数创建临时对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></td></tr></table></div></div><ol><li><p>在底层直接调用Test的构造函数创建一个Test对象，将其存入容器中，即使构造函数有explicit修饰也可以运行，因为这是在底层<del>显式</del>的调用构造函数，不会发生转换</p></li><li><p>先在局部创建一个临时对象，底层容器收到临时对象之后，创建一个新的对象接收临时对象，调用move函数进行初始化，之后存储这个新的对象，临时对象被销毁</p><blockquote><p>存储的对象与传入的对象之间只是值相同</p></blockquote></li><li><p>先在局部创建一个局部对象，之后创建一个新的对象接收这个临时对象，二者只是值相同</p></li></ol><h3 id=range-for>range for
<a class=header-anchor href=#range-for></a></h3><p>范围for循环，可以遍历容器，语法如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> elem:coll){
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>elem<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//或者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> elem:coll){
</span></span><span style=display:flex><span>    elem<span style=color:#f92672>+=</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>第一种拷贝方式无法修改元素，第二种引用方式读取到的elem可以修改，并且可以影响到原容器</p><p>底层编译器还是使用普通的for循环实现，将容器中的元素依次取出来交给elem</p><p><strong>范围for循环和explicit关键字：</strong></p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306041411183.png alt=image-20230604141101113 style=zoom:50%><p>原本vs中的string类型的元素可以隐式的调用C的构造函数，从而将string转化成C，但是增加了explicit关键字修饰之后，就无法转换</p><h3 id=defaultdelete>=default，=delete
<a class=header-anchor href=#defaultdelete></a></h3><p>如果想让编译器提供默认的构造函数（包括有参和无参），只需要在对应的构造函数后加上一个=default即可，但是如果有自定义的构造函数，就不能使用=default再让编译器给一个默认的，不然会出现二义性</p><p>=delete使用的较少，因为不想要可以直接不写，没有必要写出来又告诉编译器我不要</p><p>对于同一个函数，=default和=delete不能并存</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306041431247.png alt=image-20230604143155171 style=zoom:67%><p>主要就是使用=default告诉编译器提供一个默认版本的函数</p><hr><p>如果只定义了一个空类，编译器会自动地提供一些构造函数和析构函数，这些函数都是<code>inline</code>的，所以在调用这些函数时，会在调用处直接展开，而不是一层一层的递归调用，减少递归的开销</p><p>如果想要其他成员不能拷贝自己的内容，就需要将拷贝构造和赋值函数定义为私有，c++11中提供了一个<code>noncopyable</code>类，这个类中的拷贝构造和赋值函数都是私有的，继承这个类就可以不倍拷贝</p><p><strong>哪些类需要自定义上述构造函数？</strong></p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306041440211.png alt=image-20230604144047168></p><p>若类中有指针成员，就需要自定义上述几个函数，若没有指针成员，基本上就不需要自定义这些函数</p><p>因为指针的拷贝设计到<strong>深拷贝和浅拷贝</strong>的问题，所以需要自定义这些函数</p><h4 id=深拷贝和浅拷贝>深拷贝和浅拷贝
<a class=header-anchor href=#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e5%92%8c%e6%b5%85%e6%8b%b7%e8%b4%9d></a></h4><p>简单来说浅拷贝只是对指针的拷贝，拷贝完成之后两个指针指向同一块内存，此时还不会出现问题，一旦调用析构函数，由于存在两个指针，会调用两次析构函数去释放堆区的内存，但是两个指针指向同一块内存，所以会造成同一块内存的二次释放问题</p><p>深拷贝就是新创建一个指针，将指针中的值拷贝过来放到新指针中，两个指针除了值一样，指向的内存是不一样的，所以调用析构函数时不会出现问题</p><h3 id=alias-template>Alias Template
<a class=header-anchor href=#alias-template></a></h3><p>化名模板，也就是说给模板一个别名，后期在使用时就可以使用这个别名从而间接使用这个模板，当模板的名称太长时就可以使用简短的别名</p><p>但是特化是还是需要使用最初的模板进行特化，不能使用别名</p><p>例如：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Vec <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T,MyAlloc<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//后期可以直接使用Vec作为别名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> coll;
</span></span><span style=display:flex><span><span style=color:#75715e>//等价于
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,MyAlloc<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> coll;
</span></span></code></pre></td></tr></table></div></div><p>化名模板并不单单是为了使用模板时少写几个字母</p><p>当希望一个函数可以接受不同的参数具有通用性时，第一想法是使用函数模板，接受不同的参数就可以实现通用性，但是对于容器来说，传递不同的容器，想要插入时，还需要使用萃取器得到他能插入什么类型的元素，并不能直接传元素</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306051349658.png alt=image-20230605134936481 style=zoom:50%><p>想要插入元素需要先使用萃取器得到能插入什么元素，才能插入，所以插入元素的步骤很繁琐，并且插入的元素已经固定，不能动态指定</p><p>容器->迭代器->迭代器类型->插入元素类型</p><p>那么有没有一种模板，接收一个参数，这个参数也是一个模板，并且能够取出这个模板的参数</p><p>例如模板接受<code>vector\&lt;string></code>，而<code>vector\&lt;string></code>本身也是一个模板，可以取出其中的<code>string</code>，这就是<code>template template parameter</code></p><h3 id=模板模板参数>模板模板参数
<a class=header-anchor href=#%e6%a8%a1%e6%9d%bf%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0></a></h3><p>模板模板参数<code>template template parameter</code>，也就是说，模板中的参数又是模板,例如：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T,
</span></span><span style=display:flex><span>		<span style=color:#75715e>//模板的参数又是模板
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#f92672>&gt;</span> <span style=color:#75715e>//用来修饰下面的class Container
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Container</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>此时就可以直接传递容器名就可以进行测试，并且可以动态的指定容器插入什么元素</p><p>不用像上面一样传递一个容器对象，插入的元素已经固定，具体的使用例子如下：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306051414161.png alt=image-20230605141436064 style=zoom:50%><p>但是直接传递容器名又会出现问题，因为容器有两个参数，我们只希望传递一个模板即可，所以需要使用化名模板<code>alias template</code>来解决这个问题</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306051424411.png style=zoom:50%><p>此时就可以实现不直接传递容器对象，而是传递一个容器名，在函数内部创建容器对象，并且可以动态指定容器插入的元素类型，不用再使用萃取器一层一层获得元素的类型</p><h3 id=小总结-1>小总结
<a class=header-anchor href=#%e5%b0%8f%e6%80%bb%e7%bb%93-1></a></h3><ol><li><p>化名模板Alias Template可以给模板取一个别名</p></li><li><p>模板模板参数<code>template template parameter</code>可以让模板中接收的参数也是一个模板</p></li><li><p>综上，模板模板参数可以接受化名模板作为参数</p></li></ol><h3 id=type-alias>Type Alias
<a class=header-anchor href=#type-alias></a></h3><p>类似于<code> typedef</code>，给类型取一个别名，使用<code>using</code>取别名</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//指明func是一个接受两个int参数的函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e>//使用typedef
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span> (<span style=color:#f92672>*</span>func)(<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//使用type alias
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> func<span style=color:#f92672>=</span><span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//例如
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> add(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b)   {<span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;}
</span></span><span style=display:flex><span>func<span style=color:#f92672>=</span>add;<span style=color:#75715e>//使用函数指针指向add函数
</span></span></span></code></pre></td></tr></table></div></div><h3 id=using>using
<a class=header-anchor href=#using></a></h3><p>使用<code>using</code>可以定义化名模板<code>alias template</code>、化名类型<code>type alias</code>、命名空间<code>namespace</code>、某个类的某个函数</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//化名模板
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Vec<span style=color:#f92672>=</span>vector<span style=color:#f92672>&lt;</span>T,allocator<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//化名类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> func<span style=color:#f92672>=</span><span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//命名空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#75715e>//某个类的某个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> Person<span style=color:#f92672>::</span>ShowPerson();
</span></span></code></pre></td></tr></table></div></div><h3 id=noexcept>noexcept
<a class=header-anchor href=#noexcept></a></h3><p>在某一个函数后面加上<code>noexcept</code>关键字，这个函数就不会丢出异常</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> foo() <span style=color:#66d9ef>noexcept</span>
</span></span></code></pre></td></tr></table></div></div><p>由于程序的调用是一层一层调用，如果执行<code>foo</code>的过程中出现了异常，会在出现错误这一层尝试处理，如果这一层没有处理这个异常，那么就向上抛出异常，如果上层还没有处理，就继续向上，一直到foo这一层，由于<code>foo</code>增加了<code>noexcept</code>关键字，所以这一层也不会处理</p><p>由于<code>foo</code>这一层是最外层，所以再向上就是<code>std::terminate()</code>,会默认调用<code>std::abort()</code>,程序中断</p><blockquote><p>如果类中有move function，就需要使用noexcept关键字修饰这两个函数</p></blockquote><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306051539028.png alt=image-20230605153918892 style=zoom:50%><h3 id=override>override
<a class=header-anchor href=#override></a></h3><p>子类继承父类，重写父类中的方法时，如果方法名后面加上override，编译器就会知道此时是重写父类方法，如果参数列表与父类中的参数列表不一样，那么就会出现错误</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306051551487.png alt=image-20230605155107443 style=zoom:67%><p>对于1来说，本意是重写父类中的方法，但是参数列表写错了，编译器认为这是子类自定义的新方法，不会报错</p><p>对于2来说，本意是重写父类中的方法，并且指明<code>override</code>，所以参数列表写错编译器提示错误信息</p><blockquote><p>把继承的本意告诉编译器</p></blockquote><h3 id=final>final
<a class=header-anchor href=#final></a></h3><p><code>final</code>可以作用到两个地方：</p><ol><li>作用到类上，指明这个类是最终的类，不能再被继承了</li><li>作用到虚函数上，子类继承父类后，父类中使用<code>final</code>修饰的虚函数不能在子类中被重写</li></ol><h3 id=decltype>decltype
<a class=header-anchor href=#decltype></a></h3><p>就像是<code>typeof</code>，可以得到一个表达式的类型，c++中其实也可以用<code>typeof</code>获得一个表达式的类型，但是由于<code>typeof</code>主要在c语言中使用，在c++中并不完整，实现也不完全，所以在c++11新标准中提出了一个<code>decltype</code>来替代<code>typeof</code></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>string,<span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> coll;
</span></span><span style=display:flex><span><span style=color:#66d9ef>decltype</span>(coll)<span style=color:#f92672>::</span>value_type elem
</span></span><span style=display:flex><span><span style=color:#75715e>//等价于
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string,<span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> coll;
</span></span><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>string,<span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;::</span>value_type elem 
</span></span><span style=display:flex><span><span style=color:#75715e>//也就是decltype将coll的类型map&lt;string,float&gt;给推导了出来    
</span></span></span></code></pre></td></tr></table></div></div><p>假如知道coll是一个容器，但是忘了他是什么类型的容器，想要使用<code>value_type</code>这个属性时，就可以使用<code>decltype</code>将coll的类型推到出来，从而使用<code>value_type</code></p><p>decltype可以应用在<strong>三个</strong>地方：</p><ol><li><p><font color=red>应用在返回值类型中</font></p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306051625926.png alt=image-20230605162555854 style=zoom:67%><p>如上图所示，函数模板中两个不同类型的参数相加，不知道相加之后的返回结果，所以返回值类型不知道怎么写，此时就可以使用<code>decltype</code>进行推导</p><p>但是x,y在函数体内定义，编译器会先看到<code>decltype(x,y)</code>，所以不认识x,y会报错，此时需要使用<code>auto</code>进行配合</p><p>先指定<code>auto</code>，编译器知道x,y之后，在使用<code>decltype(x,y)</code>推导尾置返回值类型，</p></li><li><p><font color=red>应用在模板中</font></p><p>模板相互调用之后，对象的类型可能并不是那么明朗，此时可使用<code>decltype</code>推导出对象的类型</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306051634868.png alt=image-20230605163446809 style=zoom:67%><p><code>decltype(obj)</code>的结果为T，<code>typename</code>指明后面的部分是一个类型而不是一个函数，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>typename</span> <span style=color:#66d9ef>decltype</span>(ob  j)<span style=color:#f92672>::</span>iterator iType
</span></span><span style=display:flex><span><span style=color:#75715e>//等价于
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>typename</span> T<span style=color:#f92672>::</span>iterator iType
</span></span></code></pre></td></tr></table></div></div></li><li><p><font color=red>应用在lambda中</font></p></li></ol><p>有时候需要使用lambda的类型时，由于lambda的类型太长，所以可以使用decltype来推导出lambda的类型</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306051644009.png alt=image-20230605164445951 style=zoom:67%><h3 id=lambdas>lambdas
<a class=header-anchor href=#lambdas></a></h3><p>类似于内联函数，语法上有所不同，使用lambda可以很方便的声明一个匿名函数（与匿名对象一样），可以将其理解为一个未命名的内联函数</p><p>一个lambda表达式的基本语法为：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span>[capture list] (params list) <span style=color:#66d9ef>mutable</span> exception <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>return</span> type {function body}
</span></span></code></pre></td></tr></table></div></div><p>其中捕获列表可以将lambda范围内的变量进行捕获并在函数体内使用，如果加上mutable就可以对其进行修改，加不加mutable的影响主要是在<code>值捕获</code>的变量上</p><blockquote><p>函数体内想要修改<strong>值捕获</strong>的变量，就需要使用<code>mutable</code>，引用捕获(除了const)本身可修改</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> f <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>a, b](<span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d) <span style=color:#66d9ef>mutable</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;c+d=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> c <span style=color:#f92672>+</span> d <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//不加mutable，引用捕获的a还是可以修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;++a=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>++</span>a <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//++a=11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//不加mutable，值捕获的b无法修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;++b=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>++</span>b <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//++b=21
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>f(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>) ;
</span></span><span style=display:flex><span><span style=color:#75715e>//引用捕获，函数体内的修改影响到外部的a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//a=11
</span></span></span><span style=display:flex><span><span style=color:#75715e>//值捕获，函数体内的修改影响不到外部的b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;b=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> b <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//b=20
</span></span></span></code></pre></td></tr></table></div></div><p>剩下的就是返回值类型，lambda必须使用尾置返回类型</p><p>上面的lambda更简单的形式：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>[<span style=color:#f92672>&amp;</span>a, b](<span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d) <span style=color:#66d9ef>mutable</span> <span style=color:#f92672>-&gt;</span><span style=color:#66d9ef>int</span>{
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;c+d=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> c <span style=color:#f92672>+</span> d <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//不加mutable，引用捕获的a还是可以修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;++a=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>++</span>a <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//++a=11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//不加mutable，值捕获的b无法修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;++b=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>++</span>b <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//++b=21
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>//引用捕获，函数体内的修改影响到外部的a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//a=11
</span></span></span><span style=display:flex><span><span style=color:#75715e>//值捕获，函数体内的修改影响不到外部的b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;b=&#34;</span> <span style=color:#f92672>&lt;&lt;</span> b <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//b=20
</span></span></span></code></pre></td></tr></table></div></div><p>相当于创建了一个匿名对象，使用后即销毁</p><p>lambda最简单的形式为：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span>[capture list] {function body }
</span></span><span style=display:flex><span><span style=color:#75715e>//例如
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>[]{cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;hello&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;}();
</span></span><span style=display:flex><span><span style=color:#75715e>//相当于使用[]{cout&lt;&lt;&#34;hello&#34;&lt;&lt;endl;}创建了一个对象，控制台输出hello
</span></span></span></code></pre></td></tr></table></div></div><h3 id=typename>typename
<a class=header-anchor href=#typename></a></h3><p>一旦使用<code>::</code>，前面就需要加上typename</p><h3 id=string类型转换>string类型转换
<a class=header-anchor href=#string%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2></a></h3><p>string可以和其他类型进行相互转换，有时我们希望字符串代表的含义是数字，就可以使用类型转换</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>44</span>;
</span></span><span style=display:flex><span>string si<span style=color:#f92672>=</span>to_string(i);<span style=color:#75715e>//si=&#34;44&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> newi<span style=color:#f92672>=</span>stoi(si);<span style=color:#75715e>//newi=44;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//还有stod，stof等函数，将string转化为对应的类型
</span></span></span></code></pre></td></tr></table></div></div><h2 id=标准库>标准库
<a class=header-anchor href=#%e6%a0%87%e5%87%86%e5%ba%93></a></h2><h3 id=右值引用httpszhuanlanzhihucomp335994370><a href=https://zhuanlan.zhihu.com/p/335994370 title=右值引用 rel="noopener external nofollow noreferrer" target=_blank class=exturl>右值引用
<i class="fa fa-external-link-alt"></i></a>
<a class=header-anchor href=#%e5%8f%b3%e5%80%bc%e5%bc%95%e7%94%a8httpszhuanlanzhihucomp335994370></a></h3><h4 id=基础>基础
<a class=header-anchor href=#%e5%9f%ba%e7%a1%80></a></h4><p>右值就是<strong>只能</strong>出现在=右边的值，左值就是<strong>可以</strong>出现在=号左边的值，也就是左值也可以出现在=右边</p><p>可以取地址的就是左值，无法取地址的就是右值</p><p>相对的，指向左值的引用就是左值引用，指向右值的引用就是右值引用</p><p>但是由于const无法修改指向值，所以const左值引用可以指向右值，这是一种<strong>特殊情况</strong></p><blockquote><p>左值引用，使用&修饰</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref_a <span style=color:#f92672>=</span> a; <span style=color:#75715e>// 左值引用指向左值，编译通过
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref_a <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>; <span style=color:#75715e>// 左值引用指向了右值，会编译失败
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref_a <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;  <span style=color:#75715e>// 编译通过
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>右值引用，使用&&修饰</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>ref_a_right <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>; <span style=color:#75715e>// ok
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>ref_a_left <span style=color:#f92672>=</span> a; <span style=color:#75715e>// 编译不过，右值引用不可以指向左值
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 右值引用的用途：可以修改右值，相当于原来存放5的地址中现在存放6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ref_a_right <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>; 
</span></span></code></pre></td></tr></table></div></div><p>个人理解右值引用的目的就是为了重新利用地址空间</p><h4 id=move>move
<a class=header-anchor href=#move></a></h4><p>左值引用可以通过加上const修饰指向右值，那么右值有什么方式可以指向左值呢&mdash;&mdash;&ndash;><code>move</code>函数</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>ref_a <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>ref_a <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>; 
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>//等同于以下代码：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//move的目的就是将一个左值转化为右值，这样右值引用就可以指向它
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;&amp;</span>ref_a <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(temp);
</span></span><span style=display:flex><span>ref_a <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
</span></span></code></pre></td></tr></table></div></div><p>左值引用一直是一个左值，右值引用作为名称就是左值，作为返回值就是右值</p><p>例如<code>std::move(temp)</code>返回值肯定是一个右值，所以<code>std::move(temp)</code>是一个右值，但是<code>ref_a</code>是一个左值</p><p>右值引用的应用场景就是避免深拷贝，而是直接移动，将地址<strong>偷</strong>过来并且避免<strong>深浅拷贝</strong>的问题</p><p>浅拷贝就是防止两个指针指向同一块内存，深拷贝就是新建一块地址将值全部拿过来</p><p>上述说的偷在图中表现就是原指针断掉，新指针指向原内存：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306071639957.png alt=image-20230607163936864></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span> Array(Array<span style=color:#f92672>&amp;&amp;</span> temp_array) {
</span></span><span style=display:flex><span>     data_ <span style=color:#f92672>=</span> temp_array.data_;
</span></span><span style=display:flex><span>     size_ <span style=color:#f92672>=</span> temp_array.size_;
</span></span><span style=display:flex><span>     <span style=color:#75715e>// 为防止temp_array析构时delete data，提前置空其data_      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     temp_array.data_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;<span style=color:#75715e>//很重要！！！！  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> }
</span></span></code></pre></td></tr></table></div></div><h4 id=forward>forward
<a class=header-anchor href=#forward></a></h4><p>与move类似，forward也可以做类型转换，但是比move的功能更加强大，move只能将左值转化为右值，forward都可以转换，STL标准库中实现了<strong>完美</strong>的forward转发，那么什么是<strong>不完美转发</strong>呢？</p><blockquote><p><strong>不完美转发</strong></p></blockquote><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202306071700456.png alt=image-20230607170017389></p><p>如上图所示，1调用insert函数传递一个右值，会调用2处的insert函数，因为他接受一个右值，我们最终的想法是可以调用3处的构造函数，因为他也接受一个右值</p><p>但是2处将右值接收过来之后变成了左值，因为有一个参数x接收右值，<strong>右值有了名字就变成了左值</strong>，转发时会转发左值，变成了不完美转发</p><p>STL中的forward可以实现完美转发，也就是右值传递的过程中一直都是右值，不会改变类型</p><h4 id=对容器的影响>对容器的影响
<a class=header-anchor href=#%e5%af%b9%e5%ae%b9%e5%99%a8%e7%9a%84%e5%bd%b1%e5%93%8d></a></h4><p>右值引用和普通深拷贝的构造函数，对于不同容器的影响是不同的</p><ol><li>对vector：右值引用的的速度相比深拷贝更快</li><li>其他容器影响不大</li></ol><p>只要容器中的元素以节点和指针的形式连接起来，那么有没有右值引用版本的构造函数影响不大，如果容器中的元素是连续的地址形式存放，就会有影响</p><p>因为vector有右值引用的构造函数时，可以将地址的映射直接拿过来，而不是一个一个的拷贝</p><h4 id=总结>总结
<a class=header-anchor href=#%e6%80%bb%e7%bb%93></a></h4><p>上述代码可以实现移动构造函数，不用深拷贝，直接传递右值引用实现深拷贝的效果，并且可以通过<strong>move</strong>函数的处理接收左值，功能强大</p><p>但是转发的过程中由于右值有形参数接收，也就相当于有了名字，右值变成了左值，再转发就变成了左值，造成了不完美转发，解决的办法就是<strong>forward完美转发</strong></p><p>但是涉及到右值引用的函数体内部一定要有原指针置空的行为，因为他是右值引用，可以改变右值，并且有移动语义，所以可以将原指针置空，相当于<font color=red><strong>浅拷贝+原指针置空</strong></font> ，之后原指针不能再用</p><p>所以在自己定义类并实现移动构造函数时，需要注意将原指针置空，否则会出现浅拷贝的问题，总之要么右值引用要么深拷贝，不能浅拷贝</p><h3 id=新增容器>新增容器
<a class=header-anchor href=#%e6%96%b0%e5%a2%9e%e5%ae%b9%e5%99%a8></a></h3><h4 id=array>array
<a class=header-anchor href=#array></a></h4><p>是一个不支持动态扩容的数组，定义时指定容量，使用时就和数组一样使用</p><p>在普通数组的基础上，增加了一些成员函数和成员变量</p><blockquote><p>array的初始化</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> a1(<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>2</span>);<span style=color:#75715e>//错误，目的是定义一个array，初始时存放10个2，但是报错
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#ae81ff>10</span><span style=color:#f92672>&gt;</span> a2(<span style=color:#ae81ff>2</span>);<span style=color:#75715e>//错误，不能使用小括号初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#ae81ff>10</span><span style=color:#f92672>&gt;</span> a3{};<span style=color:#75715e>//正确，可以使用花括号，初始化为10个0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#ae81ff>10</span><span style=color:#f92672>&gt;</span> a4{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>};<span style=color:#75715e>//正确，前四个初始化为1，2，3，4，后面的初始化为0
</span></span></span></code></pre></td></tr></table></div></div><h4 id=hashtable>HashTable
<a class=header-anchor href=#hashtable></a></h4><p>哈希表，给<code>unordered</code>容器做底层支撑，使用链地址法解决冲突 ，当元素的个数大于数组的个数时就需要扩容，此时 的元素需要再哈希</p><p>对于系统内置的类型，可以直接调用哈希函数得到哈希值，但是对于自定义数据类型，系统不知道如何哈希，所以需要自定义哈希函数</p><p>自定义类型有了哈希函数之后（
<a href=https://blog.csdn.net/qq_45311905/article/details/121488048 title=四种方式 rel="noopener external nofollow noreferrer" target=_blank class=exturl>四种方式
<i class="fa fa-external-link-alt"></i>
</a>），对应的容器就可以使用这个哈希函数存放自定义类型</p><p>只需要将哈希函数作为参数传递过去即可</p><h2 id=总结-1>总结
<a class=header-anchor href=#%e6%80%bb%e7%bb%93-1></a></h2><p>将c++11/14中的新特性列举了出来，并不全面，但是可以供后期复习使用</p></div><footer class=post-footer><div class=post-tags><a href=/tags/c++>c++</a>
<a href=/tags/%e6%96%b0%e6%a0%87%e5%87%86>新标准</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/ rel=next title=135.分发糖果><i class="fa fa-chevron-left"></i> 135.分发糖果</a></div><div class="post-nav-prev post-nav-item"><a href=/post/134.%E5%8A%A0%E6%B2%B9%E7%AB%99/ rel=prev title=134.加油站>134.加油站
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2024</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>zzzi提供技术支持</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://zzzicode.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":null,"views":null},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"right","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.b0e26367f0461fb41ac6f947dc2af3620375dc44aa8945e6c2b1480d342c65d1.js defer></script>
<script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>