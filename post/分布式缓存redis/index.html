<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.111.3"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon_next.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon_next.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon_next.png><meta itemprop=name content="分布式缓存Redis"><meta itemprop=description content="分布式缓存Redis"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://zzzicode.github.io/imgs/avatar.png"><meta itemprop=keywords content="微服务,Redis"><meta property="og:type" content="article"><meta property="og:title" content="分布式缓存Redis"><meta property="og:description" content="分布式缓存Redis"><meta property="og:image" content="/imgs/avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://zzzicode.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98redis/"><meta property="og:site_name" content="zzzi的小站"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="zzzi"><meta property="article:published_time" content="2024-03-14 13:14:15 +0800 CST"><meta property="article:modified_time" content="2024-03-14 13:14:15 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4b7f3d9c4ef8db1505229a7dcd2c4e3ab17cd4960dd8a78b503c013770ad56a6.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98redis","permalink":"https://zzzicode.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98redis/","title":"分布式缓存Redis"}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>分布式缓存Redis - zzzi的小站</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>zzzi的小站</h1><i class=logo-line></i></a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>225</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#11rdb持久化>1.1.RDB持久化</a><ul><li><a href=#111执行时机>1.1.1.执行时机</a></li><li><a href=#112rdb原理>1.1.2.RDB原理</a></li><li><a href=#113小结>1.1.3.小结</a></li></ul></li><li><a href=#12aof持久化>1.2.AOF持久化</a><ul><li><a href=#121aof原理>1.2.1.AOF原理</a></li><li><a href=#122aof配置>1.2.2.AOF配置</a></li><li><a href=#123aof文件重写>1.2.3.AOF文件重写</a></li></ul></li><li><a href=#13rdb与aof对比>1.3.RDB与AOF对比</a></li></ul><ul><li><a href=#21搭建主从架构>2.1.搭建主从架构</a></li><li><a href=#22主从数据同步原理>2.2.主从数据同步原理</a><ul><li><a href=#221全量同步>2.2.1.全量同步</a></li><li><a href=#222增量同步>2.2.2.增量同步</a></li><li><a href=#223repl_backlog原理>2.2.3.repl_backlog原理</a></li></ul></li><li><a href=#23主从同步优化>2.3.主从同步优化</a></li><li><a href=#24小结>2.4.小结</a></li></ul><ul><li><a href=#31哨兵原理>3.1.哨兵原理</a><ul><li><a href=#311集群结构和作用>3.1.1.集群结构和作用</a></li><li><a href=#312集群监控原理>3.1.2.集群监控原理</a></li><li><a href=#313集群故障恢复原理>3.1.3.集群故障恢复原理</a></li><li><a href=#314小结>3.1.4.小结</a></li></ul></li><li><a href=#32redistemplate>3.2.RedisTemplate</a><ul><li><a href=#321导入demo工程>3.2.1.导入Demo工程</a></li><li><a href=#322引入依赖>3.2.2.引入依赖</a></li><li><a href=#323配置redis地址>3.2.3.配置Redis地址</a></li><li><a href=#324配置读写分离>3.2.4.配置读写分离</a></li></ul></li></ul><ul><li><a href=#41搭建分片集群>4.1.搭建分片集群</a></li><li><a href=#42散列插槽>4.2.散列插槽</a><ul><li><a href=#421插槽原理>4.2.1.插槽原理</a></li><li><a href=#421小结>4.2.1.小结</a></li></ul></li><li><a href=#43集群伸缩>4.3.集群伸缩</a><ul><li><a href=#431需求分析>4.3.1.需求分析</a></li><li><a href=#432创建新的redis实例>4.3.2.创建新的redis实例</a></li><li><a href=#433添加新节点到redis>4.3.3.添加新节点到redis</a></li><li><a href=#434转移插槽>4.3.4.转移插槽</a></li></ul></li><li><a href=#44故障转移>4.4.故障转移</a><ul><li><a href=#441自动故障转移>4.4.1.自动故障转移</a></li><li><a href=#442手动故障转移>4.4.2.手动故障转移</a></li></ul></li><li><a href=#45redistemplate访问分片集群>4.5.RedisTemplate访问分片集群</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=zzzi src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.png><p class=site-author-name itemprop=name>zzzi</p><div class=site-description itemprop=description>make_tuple("工作","论文")</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>225</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>5</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>51</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/zzziCode title="Github → https://github.com/zzziCode" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://zzzicode.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98redis/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.png"><meta itemprop=name content="zzzi"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="zzzi"><meta itemprop=description content="make_tuple(&#34;工作&#34;,&#34;论文&#34;)"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="分布式缓存Redis"><meta itemprop=description content="分布式缓存Redis"></span><header class=post-header><h1 class=post-title itemprop="name headline">分布式缓存Redis</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text title=发表于>发表于：</span>
<time title="创建时间：2024-03-14 13:14:15 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-03-14 13:14:15 +0800 CST">2024-03-14</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text title=分类于>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0 itemprop=url rel=index><span itemprop=name>学习笔记</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span>
<span>8703</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>18分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><blockquote><p>🤘 分布式缓存Redis</p></blockquote><p>本节中主要介绍分布式缓存的相关知识，以Redis的相关知识为主进行介绍，主要包括redis持久化的两种方式，redis主从集群的数据同步，哨兵模式的作用以及分片集群的相关知识</p><h1 id=1redis持久化>1.Redis持久化
<a class=header-anchor href=#1redis%e6%8c%81%e4%b9%85%e5%8c%96></a></h1><p><strong>单机</strong>的Redis存在四大问题：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313751.png alt=image-20210725144240631 style=zoom:33%><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h2 id=11rdb持久化>1.1.RDB持久化
<a class=header-anchor href=#11rdb%e6%8c%81%e4%b9%85%e5%8c%96></a></h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis<strong>数据快照</strong>。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h3 id=111执行时机>1.1.1.执行时机
<a class=header-anchor href=#111%e6%89%a7%e8%a1%8c%e6%97%b6%e6%9c%ba></a></h3><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p><strong>1）save命令</strong></p><p>执行下面的命令，可以立即执行一次RDB：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313755.png alt=image-20210725144536958></p><p>save命令会导致主进程执行RDB，这个过程中其它所有命令<strong>都会被阻塞</strong>。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>下面的命令可以异步执行RDB：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313756.png alt=image-20210725144725943></p><p>命令执行后会开启独立进程<strong>在后台</strong>完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p>Redis停机时会自动执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &#34;&#34; 则表示禁用RDB</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>save</span> <span style=color:#e6db74>900 1  </span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>save</span> <span style=color:#e6db74>300 10  </span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>save</span> <span style=color:#e6db74>60 10000 </span>
</span></span></code></pre></td></tr></table></div></div><p>RDB的其它配置也可以在redis.conf文件中设置：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rdbcompression</span> <span style=color:#e6db74>yes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># RDB文件名称</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dbfilename</span> <span style=color:#e6db74>dump.rdb  </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 文件保存的路径目录</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dir</span> <span style=color:#e6db74>./ </span>
</span></span></code></pre></td></tr></table></div></div><h3 id=112rdb原理>1.1.2.RDB原理
<a class=header-anchor href=#112rdb%e5%8e%9f%e7%90%86></a></h3><p>bgsave开始时会<code>fork</code>主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313757.png alt=image-20210725151319695></p><h3 id=113小结>1.1.3.小结
<a class=header-anchor href=#113%e5%b0%8f%e7%bb%93></a></h3><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件，相当于任何时刻都只存储一个RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改<strong>则</strong>触发RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h2 id=12aof持久化>1.2.AOF持久化
<a class=header-anchor href=#12aof%e6%8c%81%e4%b9%85%e5%8c%96></a></h2><h3 id=121aof原理>1.2.1.AOF原理
<a class=header-anchor href=#121aof%e5%8e%9f%e7%90%86></a></h3><p>AOF全称为Append Only File（<strong>追加</strong>文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是<strong>命令日志文件</strong>。相当于RDB记录的是真实的数据，AOF日志记录的是redis运行过程中执行的命令</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313758.png alt=image-20210725151543640 style=zoom:50%><h3 id=122aof配置>1.2.2.AOF配置
<a class=header-anchor href=#122aof%e9%85%8d%e7%bd%ae></a></h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># 是否开启AOF功能，默认是no</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>appendonly</span> <span style=color:#e6db74>yes</span>
</span></span><span style=display:flex><span><span style=color:#75715e># AOF文件的名称</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>appendfilename</span> <span style=color:#e6db74>&#34;appendonly.aof&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>AOF的命令记录的频率也可以通过redis.conf文件来配，也就是多久记录一次命令：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># 表示每执行一次写命令，立即记录到AOF文件</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>appendfsync</span> <span style=color:#e6db74>always </span>
</span></span><span style=display:flex><span><span style=color:#75715e># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>appendfsync</span> <span style=color:#e6db74>everysec </span>
</span></span><span style=display:flex><span><span style=color:#75715e># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>appendfsync</span> <span style=color:#e6db74>no</span>
</span></span></code></pre></td></tr></table></div></div><p>三种策略对比：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313759.png alt=image-20210725151654046></p><h3 id=123aof文件重写>1.2.3.AOF文件重写
<a class=header-anchor href=#123aof%e6%96%87%e4%bb%b6%e9%87%8d%e5%86%99></a></h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的<strong>多次写</strong>操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行<strong>重写</strong>功能，用最少的命令达到相同效果。实现对QOF文件的<strong>瘦身</strong></p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313760.png alt=image-20210725151729118></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># AOF文件比上次文件 增长超过多少百分比则触发重写</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>auto-aof-rewrite-percentage</span> <span style=color:#e6db74>100</span>
</span></span><span style=display:flex><span><span style=color:#75715e># AOF文件体积最小多大以上才触发重写 </span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>auto-aof-rewrite-min-size</span> <span style=color:#e6db74>64mb </span>
</span></span></code></pre></td></tr></table></div></div><h2 id=13rdb与aof对比>1.3.RDB与AOF对比
<a class=header-anchor href=#13rdb%e4%b8%8eaof%e5%af%b9%e6%af%94></a></h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313761.png alt=image-20210725151940515 style=zoom:50%><h1 id=2redis主从>2.Redis主从
<a class=header-anchor href=#2redis%e4%b8%bb%e4%bb%8e></a></h1><h2 id=21搭建主从架构>2.1.搭建主从架构
<a class=header-anchor href=#21%e6%90%ad%e5%bb%ba%e4%b8%bb%e4%bb%8e%e6%9e%b6%e6%9e%84></a></h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313762.png alt=image-20210725152037611 style=zoom:33%><h2 id=22主从数据同步原理>2.2.主从数据同步原理
<a class=header-anchor href=#22%e4%b8%bb%e4%bb%8e%e6%95%b0%e6%8d%ae%e5%90%8c%e6%ad%a5%e5%8e%9f%e7%90%86></a></h2><h3 id=221全量同步>2.2.1.全量同步
<a class=header-anchor href=#221%e5%85%a8%e9%87%8f%e5%90%8c%e6%ad%a5></a></h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：<img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313765.png alt=image-20210725152222497 style=zoom:50%></p><p>这里有一个问题，master如何得知salve是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会<strong>继承</strong>master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底<strong>需要同步哪些数据</strong>。</p><p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p><p>因此，master判断一个节点是否是第一次同步的依据，<strong>就是看replid是否一致</strong>。因为主从集群中，所有的节点之间的replid是一样的</p><p>如图：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313766.png alt=image-20210725152700914 style=zoom:50%><p>完整流程描述：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，<strong>拒绝增量同步</strong></li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB，也就是完成全量同步</li><li>master将<strong>RDB期间</strong>的命令记录在repl_baklog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步，同步时offset会变化</li></ul><h3 id=222增量同步>2.2.2.增量同步
<a class=header-anchor href=#222%e5%a2%9e%e9%87%8f%e5%90%8c%e6%ad%a5></a></h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313767.png alt=image-20210725153201086 style=zoom:50%><p>那么master怎么知道slave与自己的数据<strong>差异</strong>在哪里呢?</p><h3 id=223repl_backlog原理>2.2.3.repl_backlog原理
<a class=header-anchor href=#223repl_backlog%e5%8e%9f%e7%90%86></a></h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的repl_baklog文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是<strong>环形</strong>，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset，相当于是主节点写到哪了，从节点复制到哪了：</p><p>​ <img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313768.png alt=image-20210725153359022 style=zoom:50%></p><p>slave与master的offset之间的<strong>差异</strong>，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><p>​ <img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313769.png alt=image-20210725153524190 style=zoom:50%></p><p>直到数组被填满：</p><p>​ <img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313770.png alt=image-20210725153715910 style=zoom:50%></p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：</p><p>​ <img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313771.png alt=image-20210725153937031 style=zoom:50%></p><p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p><p>​ <img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313772.png alt=image-20210725154155984 style=zoom:50%></p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现<strong>自己的offset都没有了</strong>，无法完成增量同步了。只能做<strong>全量同步</strong>。全量同步之后，主从的offset是一样的，主节点写到哪从节点就同步到哪，后期主节点有新数据才会使得offset移动</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313773.png alt=image-20210725154216392></p><h2 id=23主从同步优化>2.3.主从同步优化
<a class=header-anchor href=#23%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e4%bc%98%e5%8c%96></a></h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，<strong>尽可能避免全量同步</strong></li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><p>主从从架构图：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313774.png alt=image-20210725154405899></p><h2 id=24小结>2.4.小结
<a class=header-anchor href=#24%e5%b0%8f%e7%bb%93></a></h2><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存<strong>数据</strong>生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的<strong>命令</strong>给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点<strong>第一次</strong>连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的<strong>offset已经被覆盖时</strong></li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul><h1 id=3redis哨兵>3.Redis哨兵
<a class=header-anchor href=#3redis%e5%93%a8%e5%85%b5></a></h1><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的<strong>自动故障恢复</strong>。</p><h2 id=31哨兵原理>3.1.哨兵原理
<a class=header-anchor href=#31%e5%93%a8%e5%85%b5%e5%8e%9f%e7%90%86></a></h2><h3 id=311集群结构和作用>3.1.1.集群结构和作用
<a class=header-anchor href=#311%e9%9b%86%e7%be%a4%e7%bb%93%e6%9e%84%e5%92%8c%e4%bd%9c%e7%94%a8></a></h3><p>哨兵的结构如图：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313775.png alt=image-20210725154528072 style=zoom:50%><p>哨兵的作用如下：</p><ul><li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主，否则会有集群脑裂的情况</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><h3 id=312集群监控原理>3.1.2.集群监控原理
<a class=header-anchor href=#312%e9%9b%86%e7%be%a4%e7%9b%91%e6%8e%a7%e5%8e%9f%e7%90%86></a></h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p><p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313776.png alt=image-20210725154632354 style=zoom:50%><h3 id=313集群故障恢复原理>3.1.3.集群故障恢复原理
<a class=header-anchor href=#313%e9%9b%86%e7%be%a4%e6%95%85%e9%9a%9c%e6%81%a2%e5%a4%8d%e5%8e%9f%e7%90%86></a></h3><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p>当选出一个新的master后，该如何实现切换呢？</p><p>流程如下：</p><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master，不要再当从节点了</li><li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel<strong>将故障节点标记为slave</strong>，当故障节点恢复后会自动成为新的master的slave节点，这样做是为了防止集群脑裂问题</li></ul><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313777.png alt=image-20210725154816841 style=zoom:50%><h3 id=314小结>3.1.4.小结
<a class=header-anchor href=#314%e5%b0%8f%e7%bb%93></a></h3><p>Sentinel的三个作用是什么？</p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li>每隔1秒发送一次<code>ping</code>命令，如果超过一定时间没有相向则认为是<strong>主观</strong>下线</li><li>如果大多数sentinel都认为实例主观下线，则判定服务<strong>客观</strong>下线</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先选定一个slave作为新的master，执行slaveof no one</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点配置，添加slaveof 新master</li></ul><h2 id=32redistemplate>3.2.RedisTemplate
<a class=header-anchor href=#32redistemplate></a></h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p><p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p><h3 id=321导入demo工程>3.2.1.导入Demo工程
<a class=header-anchor href=#321%e5%af%bc%e5%85%a5demo%e5%b7%a5%e7%a8%8b></a></h3><p>首先，我们引入资料提供的Demo工程</p><h3 id=322引入依赖>3.2.2.引入依赖
<a class=header-anchor href=#322%e5%bc%95%e5%85%a5%e4%be%9d%e8%b5%96></a></h3><p>在项目的pom文件中引入依赖：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-data-redis<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=323配置redis地址>3.2.3.配置Redis地址
<a class=header-anchor href=#323%e9%85%8d%e7%bd%aeredis%e5%9c%b0%e5%9d%80></a></h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息，之后Sentinel通知客户端redis集群中主从节点的地址信息，这样就不用讲主从节点的地址信息写死了，一切交给Sentinel来进行控制：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>spring:
</span></span><span style=display:flex><span>  redis<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    sentinel<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      master<span style=color:#f92672>:</span> mymaster
</span></span><span style=display:flex><span>      nodes<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span> <span style=color:#ae81ff>192.168.150.101</span><span style=color:#f92672>:</span><span style=color:#ae81ff>27001</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span> <span style=color:#ae81ff>192.168.150.101</span><span style=color:#f92672>:</span><span style=color:#ae81ff>27002</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span> <span style=color:#ae81ff>192.168.150.101</span><span style=color:#f92672>:</span><span style=color:#ae81ff>27003</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=324配置读写分离>3.2.4.配置读写分离
<a class=header-anchor href=#324%e9%85%8d%e7%bd%ae%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb></a></h3><p>在项目的启动类中，添加一个新的bean，这主要是配置<strong>读写分离策略</strong>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> LettuceClientConfigurationBuilderCustomizer <span style=color:#a6e22e>clientConfigurationBuilderCustomizer</span><span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> clientConfigurationBuilder <span style=color:#f92672>-&gt;</span> clientConfigurationBuilder<span style=color:#f92672>.</span><span style=color:#a6e22e>readFrom</span><span style=color:#f92672>(</span>ReadFrom<span style=color:#f92672>.</span><span style=color:#a6e22e>REPLICA_PREFERRED</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读取</li><li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master，实现读写分离，写操作主要在master，读操作主要在slave</li></ul><p>之后客户端操作redis集群时，读操作就会交给从节点，写操作就会交给主节点，当主从节点变化时，Sentinel会通知客户端，此时读写分离操作又会交给新的主从节点</p><h1 id=4redis分片集群>4.Redis分片集群
<a class=header-anchor href=#4redis%e5%88%86%e7%89%87%e9%9b%86%e7%be%a4></a></h1><h2 id=41搭建分片集群>4.1.搭建分片集群
<a class=header-anchor href=#41%e6%90%ad%e5%bb%ba%e5%88%86%e7%89%87%e9%9b%86%e7%be%a4></a></h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li><p>海量数据存储问题，单节点的数据量过大</p></li><li><p>高并发写的问题，主节点的压力过大</p></li></ul><p>使用分片集群可以解决上述问题，如图:</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313780.png alt=image-20210725155747294 style=zoom:50%><p>分片集群特征：</p><ul><li><p>集群中有多个master，<strong>每个master保存不同数据</strong></p></li><li><p>每个master都可以有多个slave节点，相当于是多master多slave</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><h2 id=42散列插槽>4.2.散列插槽
<a class=header-anchor href=#42%e6%95%a3%e5%88%97%e6%8f%92%e6%a7%bd></a></h2><h3 id=421插槽原理>4.2.1.插槽原理
<a class=header-anchor href=#421%e6%8f%92%e6%a7%bd%e5%8e%9f%e7%90%86></a></h3><p>Redis会把每一个master节点<strong>映射</strong>到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到，也就是redis会将16384均匀分给所有的master节点，之后通过哈希映射就知道数据存储到哪个节点上：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313782.png alt=image-20210725155820320></p><p>相当于数据存储的位置，然后每个主节点都分配一些插槽，这样主节点之间存储的数据就不一样，从而实现<strong>分片集群</strong>，之后使用哈希将数据和对应的插槽绑定，这样后期就知道数据到底存储到了哪个插槽中，之后根据插槽和节点之间的绑定关系就知道数据存储到了哪个节点中</p><p>数据key不是与节点绑定，而是<strong>与插槽绑定</strong> ，这是因为主节点可能宕机，也可能出现新的主节点，这样绑定更加灵活，插槽数量是不变的，但是主节点数量会改变。redis会根据key的有效部分计算插槽值，有效部分分两种情况：</p><ul><li>key中包含"{}"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313783.png alt=image-20210725155850200></p><p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到7003节点。因为7003节点对应的插槽范围为10923-16383</p><p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点，因为7001节点对应的插槽范围为0-5460</p><h3 id=421小结>4.2.1.小结
<a class=header-anchor href=#421%e5%b0%8f%e7%bb%93></a></h3><p>Redis如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽均匀分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用<strong>相同的有效部分</strong>，例如key都以{typeId}为前缀，相当于只要哈希值一样，就可以保存到一起，这就是**{}存在的意义**</li></ul><h2 id=43集群伸缩>4.3.集群伸缩
<a class=header-anchor href=#43%e9%9b%86%e7%be%a4%e4%bc%b8%e7%bc%a9></a></h2><blockquote><p>集群伸缩就是值master的数量变化，这会导致<strong>插槽可能重新分配</strong></p></blockquote><p>redis-cli &ndash;cluster提供了很多操作集群的命令，可以通过下面方式查看：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313784.png alt=image-20210725160138290></p><p>比如，添加节点的命令：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313785.png alt=image-20210725160448139></p><h3 id=431需求分析>4.3.1.需求分析
<a class=header-anchor href=#431%e9%9c%80%e6%b1%82%e5%88%86%e6%9e%90></a></h3><p>需求：向集群中添加一个新的master节点，并向其中存储 num = 10</p><ul><li>启动一个新的redis实例，端口为7004</li><li>添加7004到之前的集群，并作为一个master节点</li><li>给7004节点<strong>分配插槽</strong>，使得num这个key可以存储到7004实例</li></ul><p>这里需要两个新的功能：</p><ul><li>添加一个节点到集群中</li><li>将<strong>部分插槽分配到新插槽</strong>，这个很重要，取决于后面的数据分配到哪个节点中</li></ul><h3 id=432创建新的redis实例>4.3.2.创建新的redis实例
<a class=header-anchor href=#432%e5%88%9b%e5%bb%ba%e6%96%b0%e7%9a%84redis%e5%ae%9e%e4%be%8b></a></h3><p>创建一个文件夹：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sh data-lang=sh><span style=display:flex><span>mkdir <span style=color:#ae81ff>7004</span>
</span></span></code></pre></td></tr></table></div></div><p>拷贝配置文件：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sh data-lang=sh><span style=display:flex><span>cp redis.conf /7004
</span></span></code></pre></td></tr></table></div></div><p>修改配置文件：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sh data-lang=sh><span style=display:flex><span>sed /s/6379/7004/g 7004/redis.conf
</span></span></code></pre></td></tr></table></div></div><p>启动</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sh data-lang=sh><span style=display:flex><span>redis-server 7004/redis.conf
</span></span></code></pre></td></tr></table></div></div><h3 id=433添加新节点到redis>4.3.3.添加新节点到redis
<a class=header-anchor href=#433%e6%b7%bb%e5%8a%a0%e6%96%b0%e8%8a%82%e7%82%b9%e5%88%b0redis></a></h3><p>添加节点的语法如下：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313785.png alt=image-20210725160448139></p><p>执行命令：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sh data-lang=sh><span style=display:flex><span>redis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001
</span></span></code></pre></td></tr></table></div></div><p>通过命令查看集群状态：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sh data-lang=sh><span style=display:flex><span>redis-cli -p <span style=color:#ae81ff>7001</span> cluster nodes
</span></span></code></pre></td></tr></table></div></div><p>如图，7004加入了集群，并且默认是一个master节点：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313786.png alt=image-20210725161007099></p><p>但是，可以看到7004节点的插槽数量为0，<strong>因此没有任何数据可以存储到7004上</strong></p><h3 id=434转移插槽>4.3.4.转移插槽
<a class=header-anchor href=#434%e8%bd%ac%e7%a7%bb%e6%8f%92%e6%a7%bd></a></h3><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313787.png alt=image-20210725161241793></p><p>如上图所示，num的<strong>插槽为2765</strong>.</p><p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313788.png alt=image-20210725161401925 style=zoom:50%><p>具体命令如下：</p><p>建立连接：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313789.png alt=image-20210725161506241></p><p>得到下面的反馈：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313790.png alt=image-20210725161540841></p><p>询问要移动多少个插槽，我们计划是3000个：</p><p>新的问题来了：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313791.png alt=image-20210725161637152></p><p>那个node来接收这些插槽？？</p><p>显然是7004，那么7004节点的id是多少呢？</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313792.png alt=image-20210725161731738></p><p>复制这个id，然后拷贝到刚才的控制台后：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313793.png alt=image-20210725161817642></p><p>这里询问，你的插槽是从哪里移动过来的？</p><ul><li>all：代表全部，也就是三个节点<strong>各转移</strong>一部分</li><li>具体的id：目标节点的id</li><li>done：没有了，这作为一个<strong>结束符</strong></li></ul><p>这里我们要从7001获取，因此填写7001的id：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313794.png alt=image-20210725162030478></p><p>填完后，点击done，这样插槽转移就准备好了：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313795.png alt=image-20210725162101228></p><p>确认要转移吗？输入yes：</p><p>然后，通过命令查看结果：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313796.png alt=image-20210725162145497></p><p>可以看到：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313797.png alt=image-20210725162224058></p><p>目的达成。相当于从现有的7001节点中拿出来一部分插槽分配给新节点就可以实现分片，可以每一个节点分配一点出来，也可以单单从一个节点中拿一部分出来</p><h2 id=44故障转移>4.4.故障转移
<a class=header-anchor href=#44%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb></a></h2><p>集群初识状态是这样的：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313798.png alt=image-20210727161152065></p><p>其中7001、7002、7003都是master，我们计划让7002宕机。</p><h3 id=441自动故障转移>4.4.1.自动故障转移
<a class=header-anchor href=#441%e8%87%aa%e5%8a%a8%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb></a></h3><p>当集群中有一个master宕机会发生什么呢？</p><p>直接停止一个redis实例，例如7002：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sh data-lang=sh><span style=display:flex><span>redis-cli -p <span style=color:#ae81ff>7002</span> shutdown
</span></span></code></pre></td></tr></table></div></div><p>1）首先是该实例与其它实例失去连接</p><p>2）然后是疑似宕机：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313799.png alt=image-20210725162319490></p><p>3）最后是确定下线，自动提升一个slave为新的master：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313800.png alt=image-20210725162408979></p><p>4）当7002再次启动，就会变为一个slave节点了：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313801.png alt=image-20210727160803386 style=zoom:80%><blockquote><p>新的主节点会建立与原先主节点对应的插槽之间的映射关系</p></blockquote><h3 id=442手动故障转移>4.4.2.手动故障转移
<a class=header-anchor href=#442%e6%89%8b%e5%8a%a8%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb></a></h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现<strong>无感知的数据迁移</strong>。其流程如下，也就是在内部手动的进行切换：</p><img src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313802.png alt=image-20210725162441407 style=zoom:50%><p>这种failover命令可以指定三种模式：</p><ul><li>缺省：默认的流程，如图1~6歩</li><li>force：省略了对offset的一致性校验</li><li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li></ul><p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p><p>步骤如下：</p><p>1）利用redis-cli连接7002这个节点</p><p>2）执行cluster failover命令</p><p>如图：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313803.png alt=image-20210727160037766></p><p>效果：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://zzzi-img-1313100942.cos.ap-beijing.myqcloud.com/img/202403141313798.png alt=image-20210727161152065></p><h2 id=45redistemplate访问分片集群>4.5.RedisTemplate访问分片集群
<a class=header-anchor href=#45redistemplate%e8%ae%bf%e9%97%ae%e5%88%86%e7%89%87%e9%9b%86%e7%be%a4></a></h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><p>1）引入redis的starter依赖</p><p>2）配置分片集群地址</p><p>3）配置读写分离</p><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下，这里不再使用Sentinel来对集群进行监控，而是直接将集群的地址写死：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>cluster</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>nodes</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>192.168.150.101</span>:<span style=color:#ae81ff>7001</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>192.168.150.101</span>:<span style=color:#ae81ff>7002</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>192.168.150.101</span>:<span style=color:#ae81ff>7003</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>192.168.150.101</span>:<span style=color:#ae81ff>8001</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>192.168.150.101</span>:<span style=color:#ae81ff>8002</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>192.168.150.101</span>:<span style=color:#ae81ff>8003</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/%e5%be%ae%e6%9c%8d%e5%8a%a1>微服务</a>
<a href=/tags/redis>Redis</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/ rel=next title=多级缓存><i class="fa fa-chevron-left"></i> 多级缓存</a></div><div class="post-nav-prev post-nav-item"><a href=/post/%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/ rel=prev title=网络面经>网络面经
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2024</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>zzzi提供技术支持</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://zzzicode.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":null,"views":null},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"right","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.b0e26367f0461fb41ac6f947dc2af3620375dc44aa8945e6c2b1480d342c65d1.js defer></script>
<script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>